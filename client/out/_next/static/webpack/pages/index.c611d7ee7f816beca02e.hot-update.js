webpackHotUpdate_N_E("pages/index",{

/***/ "./components/libs/Particles.js":
false,

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../next/dist/compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../next/dist/compiled/webpack/module.js */ "./node_modules/next/dist/compiled/webpack/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isEqual.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEqual.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/react-particles-js/cjs/particles.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-particles-js/cjs/particles.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){for(var r in t)e[r]=t[r]}(exports,function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=1)}([function(e,t){e.exports=__webpack_require__(/*! react */ "./node_modules/react/index.js")},function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||t.hasOwnProperty(r)||n(t,e,r)},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Particles=void 0;var a=o(r(2));t.Particles=a.default,i(r(10),t),i(r(11),t),i(r(12),t),i(r(13),t),i(r(14),t),i(r(15),t),i(r(16),t),i(r(17),t),i(r(18),t),i(r(19),t),i(r(20),t),i(r(21),t),t.default=a.default},function(e,t,r){"use strict";function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function o(e,t,r){return(o="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=l(e)););return e}(e,t);if(n){var i=Object.getOwnPropertyDescriptor(n,t);return i.get?i.get.call(r):i.value}})(e,t,r||e)}function a(e,t){return(a=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function s(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=l(e);if(t){var i=l(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return u(this,r)}}function u(e,t){return!t||"object"!==n(t)&&"function"!=typeof t?c(e):t}function c(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var f=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),p=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),d=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.hasOwnProperty.call(e,r)&&f(t,e,r);return p(t,e),t},y=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var v=d(r(0)),b=r(0),h=y(r(3)),m=r(4),g=r(5),P=r(6),O=r(9),_=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&a(e,t)}(f,e);var t,r,n,u=s(f);function f(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),(t=u.call(this,e)).state={canvas:void 0,library:void 0},t.loadCanvas=t.loadCanvas.bind(c(t)),t}return t=f,(r=[{key:"buildParticlesLibrary",value:function(e,t){try{if(void 0===window)return null}catch(e){return null}O.tsParticles.init();var r=new m.Options;r.load(P.defaultParams),r.load(t);var n=new g.Container(e,r);return this.props.particlesRef&&(this.props.particlesRef.current=n),n}},{key:"refresh",value:function(e){var t=this,r=this.state.canvas;r&&(this.destroy(),this.setState({library:this.buildParticlesLibrary(e.id,e.params)},(function(){t.loadCanvas(r)})))}},{key:"destroy",value:function(){this.state.library&&this.state.library.destroy()}},{key:"loadCanvas",value:function(e){var t=this;e&&this.setState({canvas:e},(function(){var r=t.state.library;r&&(r.canvas.loadCanvas(e),r.start())}))}},{key:"shouldComponentUpdate",value:function(e){return!h.default(e,this.props)}},{key:"componentDidUpdate",value:function(){this.refresh(this.props)}},{key:"forceUpdate",value:function(){this.refresh(this.props),o(l(f.prototype),"forceUpdate",this).call(this)}},{key:"componentDidMount",value:function(){this.setState({library:this.buildParticlesLibrary(this.props.id,this.props.params)})}},{key:"componentWillUnmount",value:function(){this.destroy(),this.setState({library:void 0})}},{key:"render",value:function(){var e=this.props,t=e.width,r=e.height,n=e.className,i=e.canvasClassName,o=e.id;return v.createElement("div",{className:n,id:o},v.createElement("canvas",{ref:this.loadCanvas,className:i,style:Object.assign(Object.assign({},this.props.style),{width:t,height:r})}))}}])&&i(t.prototype,r),n&&i(t,n),f}(b.Component);t.default=_,_.defaultProps={width:"100%",height:"100%",params:P.defaultParams,style:{},id:"tsparticles"}},function(e,t){e.exports=__webpack_require__(/*! lodash/isEqual */ "./node_modules/lodash/isEqual.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Options/Classes/Options */ "./node_modules/tsparticles/dist/Options/Classes/Options.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Core/Container */ "./node_modules/tsparticles/dist/Core/Container.js")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.defaultParams=void 0;var n=r(7),i=r(8);t.defaultParams={particles:{number:{value:40,max:-1,density:{enable:!1,area:1200}},color:{value:"#FFF"},shape:{type:n.ShapeType.circle,polygon:{sides:5},image:{src:"",width:100,height:100}},stroke:{width:0,color:"#000000"},opacity:{value:.5,random:!1,anim:{enable:!0,speed:1,minimumValue:.1,sync:!1}},size:{value:1,random:!1,anim:{enable:!1,speed:40,minimumValue:0,sync:!1}},links:{enable:!0,distance:150,color:"#FFF",opacity:.6,width:1,shadow:{enable:!1,blur:5,color:"lime"}},move:{enable:!0,speed:3,direction:n.MoveDirection.none,random:!1,straight:!1,outMode:n.OutMode.bounce,bounce:!0,attract:{enable:!1,rotateX:3e3,rotateY:3e3}}},interactivity:{detectsOn:n.InteractivityDetect.canvas,events:{onHover:{enable:!1,mode:n.HoverMode.grab},onClick:{enable:!1,mode:n.ClickMode.repulse},resize:!0},modes:{grab:{distance:180,links:{opacity:.35}},bubble:{distance:200,size:80,duration:.4},repulse:{distance:100,duration:5},push:{quantity:4},remove:{quantity:2}}},detectRetina:!0,fpsLimit:999,polygon:{enable:!1,scale:1,type:i.Type.inline,inline:{arrangement:i.InlineArrangement.onePerPoint},draw:{enable:!1,stroke:{width:.5,color:"rgba(255, 255, 255, .1)"}},move:{radius:10,type:i.MoveType.path},url:""}}},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums */ "./node_modules/tsparticles/dist/Enums/index.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles */ "./node_modules/tsparticles/dist/index.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/InteractivityDetect */ "./node_modules/tsparticles/dist/Enums/InteractivityDetect.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/MoveDirection */ "./node_modules/tsparticles/dist/Enums/MoveDirection.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/OutMode */ "./node_modules/tsparticles/dist/Enums/OutMode.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/PolygonMaskInlineArrangement */ "./node_modules/tsparticles/dist/Enums/PolygonMaskInlineArrangement.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/PolygonMaskMoveType */ "./node_modules/tsparticles/dist/Enums/PolygonMaskMoveType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/PolygonMaskType */ "./node_modules/tsparticles/dist/Enums/PolygonMaskType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/ProcessBubbleType */ "./node_modules/tsparticles/dist/Enums/ProcessBubbleType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/RotateDirection */ "./node_modules/tsparticles/dist/Enums/RotateDirection.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/ShapeType */ "./node_modules/tsparticles/dist/Enums/ShapeType.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/Modes/ClickMode */ "./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/Modes/DivMode */ "./node_modules/tsparticles/dist/Enums/Modes/DivMode.js")},function(e,t){e.exports=__webpack_require__(/*! tsparticles/dist/Enums/Modes/HoverMode */ "./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js")}]));

/***/ }),

/***/ "./node_modules/react-particles-js/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-particles-js/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ReactParticles = __webpack_require__(/*! ./cjs/particles */ "./node_modules/react-particles-js/cjs/particles.js");
for (let key in ReactParticles) {
    ReactParticles.default[key] = ReactParticles[key];
}
module.exports = ReactParticles.default;

/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Canvas.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Canvas.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Canvas = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Canvas {
    constructor(container) {
        this.container = container;
        this.size = {
            height: 0,
            width: 0,
        };
        this.context = null;
        this.generatedCanvas = false;
    }
    init() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.resize();
        const options = this.container.actualOptions;
        const element = this.element;
        if (element) {
            if (options.fullScreen.enable) {
                this.originalStyle = Utils_1.Utils.deepExtend({}, element.style);
                element.style.position = "fixed";
                element.style.zIndex = options.fullScreen.zIndex.toString(10);
                element.style.top = "0";
                element.style.left = "0";
                element.style.width = "100%";
                element.style.height = "100%";
            }
            else {
                element.style.position = (_b = (_a = this.originalStyle) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : "";
                element.style.zIndex = (_d = (_c = this.originalStyle) === null || _c === void 0 ? void 0 : _c.zIndex) !== null && _d !== void 0 ? _d : "";
                element.style.top = (_f = (_e = this.originalStyle) === null || _e === void 0 ? void 0 : _e.top) !== null && _f !== void 0 ? _f : "";
                element.style.left = (_h = (_g = this.originalStyle) === null || _g === void 0 ? void 0 : _g.left) !== null && _h !== void 0 ? _h : "";
                element.style.width = (_k = (_j = this.originalStyle) === null || _j === void 0 ? void 0 : _j.width) !== null && _k !== void 0 ? _k : "";
                element.style.height = (_m = (_l = this.originalStyle) === null || _l === void 0 ? void 0 : _l.height) !== null && _m !== void 0 ? _m : "";
            }
        }
        const cover = options.backgroundMask.cover;
        const color = cover.color;
        const trail = options.particles.move.trail;
        const coverRgb = Utils_1.ColorUtils.colorToRgb(color);
        this.coverColor =
            coverRgb !== undefined
                ? {
                    r: coverRgb.r,
                    g: coverRgb.g,
                    b: coverRgb.b,
                    a: cover.opacity,
                }
                : undefined;
        this.trailFillColor = Utils_1.ColorUtils.colorToRgb(trail.fillColor);
        this.initBackground();
        this.paint();
    }
    loadCanvas(canvas, generatedCanvas) {
        var _a;
        if (!canvas.className) {
            canvas.className = Utils_1.Constants.canvasClass;
        }
        if (this.generatedCanvas) {
            (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        }
        this.generatedCanvas = generatedCanvas !== null && generatedCanvas !== void 0 ? generatedCanvas : this.generatedCanvas;
        this.element = canvas;
        this.originalStyle = Utils_1.Utils.deepExtend({}, this.element.style);
        this.size.height = canvas.offsetHeight;
        this.size.width = canvas.offsetWidth;
        this.context = this.element.getContext("2d");
        this.container.retina.init();
        this.initBackground();
    }
    destroy() {
        var _a;
        if (this.generatedCanvas) {
            (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        }
        if (this.context) {
            Utils_1.CanvasUtils.clear(this.context, this.size);
        }
    }
    paint() {
        const options = this.container.actualOptions;
        if (!this.context) {
            return;
        }
        if (options.backgroundMask.enable && options.backgroundMask.cover && this.coverColor) {
            Utils_1.CanvasUtils.clear(this.context, this.size);
            this.paintBase(Utils_1.ColorUtils.getStyleFromRgb(this.coverColor, this.coverColor.a));
        }
        else {
            this.paintBase();
        }
    }
    clear() {
        const options = this.container.actualOptions;
        const trail = options.particles.move.trail;
        if (options.backgroundMask.enable) {
            this.paint();
        }
        else if (trail.enable && trail.length > 0 && this.trailFillColor) {
            this.paintBase(Utils_1.ColorUtils.getStyleFromRgb(this.trailFillColor, 1 / trail.length));
        }
        else if (this.context) {
            Utils_1.CanvasUtils.clear(this.context, this.size);
        }
    }
    windowResize() {
        if (!this.element) {
            return;
        }
        const container = this.container;
        this.resize();
        container.actualOptions.setResponsive(this.size.width, container.retina.pixelRatio, container.options);
        container.particles.setDensity();
        for (const [, plugin] of container.plugins) {
            if (plugin.resize !== undefined) {
                plugin.resize();
            }
        }
    }
    resize() {
        if (!this.element) {
            return;
        }
        const container = this.container;
        const pxRatio = container.retina.pixelRatio;
        const size = container.canvas.size;
        const oldSize = {
            width: size.width,
            height: size.height,
        };
        size.width = this.element.offsetWidth * pxRatio;
        size.height = this.element.offsetHeight * pxRatio;
        this.element.width = size.width;
        this.element.height = size.height;
        if (this.container.started) {
            this.resizeFactor = {
                width: size.width / oldSize.width,
                height: size.height / oldSize.height,
            };
        }
    }
    drawConnectLine(p1, p2) {
        var _a;
        const ctx = this.context;
        if (!ctx) {
            return;
        }
        const lineStyle = this.lineStyle(p1, p2);
        if (!lineStyle) {
            return;
        }
        const pos1 = p1.getPosition();
        const pos2 = p2.getPosition();
        Utils_1.CanvasUtils.drawConnectLine(ctx, (_a = p1.linksWidth) !== null && _a !== void 0 ? _a : this.container.retina.linksWidth, lineStyle, pos1, pos2);
    }
    drawGrabLine(particle, lineColor, opacity, mousePos) {
        var _a;
        const container = this.container;
        const ctx = container.canvas.context;
        if (!ctx) {
            return;
        }
        const beginPos = particle.getPosition();
        Utils_1.CanvasUtils.drawGrabLine(ctx, (_a = particle.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth, beginPos, mousePos, lineColor, opacity);
    }
    drawParticleShadow(particle, mousePos) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.drawParticleShadow(this.container, this.context, particle, mousePos);
    }
    drawLinkTriangle(p1, link1, link2) {
        var _a;
        const container = this.container;
        const options = container.actualOptions;
        const p2 = link1.destination;
        const p3 = link2.destination;
        const triangleOptions = p1.options.links.triangles;
        const opacityTriangle = (_a = triangleOptions.opacity) !== null && _a !== void 0 ? _a : (link1.opacity + link2.opacity) / 2;
        if (opacityTriangle <= 0) {
            return;
        }
        const pos1 = p1.getPosition();
        const pos2 = p2.getPosition();
        const pos3 = p3.getPosition();
        const ctx = this.context;
        if (!ctx) {
            return;
        }
        if (Utils_1.NumberUtils.getDistance(pos1, pos2) > container.retina.linksDistance ||
            Utils_1.NumberUtils.getDistance(pos3, pos2) > container.retina.linksDistance ||
            Utils_1.NumberUtils.getDistance(pos3, pos1) > container.retina.linksDistance) {
            return;
        }
        let colorTriangle = Utils_1.ColorUtils.colorToRgb(triangleOptions.color);
        if (!colorTriangle) {
            const linksOptions = p1.options.links;
            const linkColor = linksOptions.id !== undefined
                ? container.particles.linksColors.get(linksOptions.id)
                : container.particles.linksColor;
            colorTriangle = Utils_1.ColorUtils.getLinkColor(p1, p2, linkColor);
        }
        if (!colorTriangle) {
            return;
        }
        Utils_1.CanvasUtils.drawLinkTriangle(ctx, pos1, pos2, pos3, options.backgroundMask.enable, options.backgroundMask.composite, colorTriangle, opacityTriangle);
    }
    drawLinkLine(p1, link) {
        var _a, _b;
        const container = this.container;
        const options = container.actualOptions;
        const p2 = link.destination;
        let opacity = link.opacity;
        const pos1 = p1.getPosition();
        const pos2 = p2.getPosition();
        const ctx = this.context;
        if (!ctx) {
            return;
        }
        let colorLine;
        const twinkle = p1.options.twinkle.lines;
        if (twinkle.enable) {
            const twinkleFreq = twinkle.frequency;
            const twinkleRgb = Utils_1.ColorUtils.colorToRgb(twinkle.color);
            const twinkling = Math.random() < twinkleFreq;
            if (twinkling && twinkleRgb !== undefined) {
                colorLine = twinkleRgb;
                opacity = twinkle.opacity;
            }
        }
        if (!colorLine) {
            const linksOptions = p1.options.links;
            const linkColor = linksOptions.id !== undefined
                ? container.particles.linksColors.get(linksOptions.id)
                : container.particles.linksColor;
            colorLine = Utils_1.ColorUtils.getLinkColor(p1, p2, linkColor);
        }
        if (!colorLine) {
            return;
        }
        const width = (_a = p1.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth;
        const maxDistance = (_b = p1.linksDistance) !== null && _b !== void 0 ? _b : container.retina.linksDistance;
        Utils_1.CanvasUtils.drawLinkLine(ctx, width, pos1, pos2, maxDistance, container.canvas.size, p1.options.links.warp, options.backgroundMask.enable, options.backgroundMask.composite, colorLine, opacity, p1.options.links.shadow);
    }
    drawParticle(particle, delta) {
        var _a, _b, _c, _d;
        if (((_a = particle.image) === null || _a === void 0 ? void 0 : _a.loaded) === false || particle.spawning || particle.destroyed) {
            return;
        }
        const pfColor = particle.getFillColor();
        const psColor = (_b = particle.getStrokeColor()) !== null && _b !== void 0 ? _b : pfColor;
        if (!pfColor && !psColor) {
            return;
        }
        const options = this.container.actualOptions;
        const pOptions = particle.options;
        const twinkle = pOptions.twinkle.particles;
        const twinkleFreq = twinkle.frequency;
        const twinkleRgb = Utils_1.ColorUtils.colorToRgb(twinkle.color);
        const twinkling = twinkle.enable && Math.random() < twinkleFreq;
        const radius = particle.getRadius();
        const opacity = twinkling ? twinkle.opacity : (_c = particle.bubble.opacity) !== null && _c !== void 0 ? _c : particle.opacity.value;
        const infectionStage = particle.infecter.infectionStage;
        const infection = options.infection;
        const infectionStages = infection.stages;
        const infectionColor = infectionStage !== undefined ? infectionStages[infectionStage].color : undefined;
        const infectionRgb = Utils_1.ColorUtils.colorToRgb(infectionColor);
        const fColor = twinkling && twinkleRgb !== undefined
            ? twinkleRgb
            : infectionRgb !== null && infectionRgb !== void 0 ? infectionRgb : (pfColor ? Utils_1.ColorUtils.hslToRgb(pfColor) : undefined);
        const sColor = twinkling && twinkleRgb !== undefined
            ? twinkleRgb
            : infectionRgb !== null && infectionRgb !== void 0 ? infectionRgb : (psColor ? Utils_1.ColorUtils.hslToRgb(psColor) : undefined);
        const fillColorValue = fColor !== undefined ? Utils_1.ColorUtils.getStyleFromRgb(fColor, opacity) : undefined;
        if (!this.context || (!fillColorValue && !sColor)) {
            return;
        }
        const strokeColorValue = sColor !== undefined
            ? Utils_1.ColorUtils.getStyleFromRgb(sColor, (_d = particle.stroke.opacity) !== null && _d !== void 0 ? _d : opacity)
            : fillColorValue;
        this.drawParticleLinks(particle);
        if (radius > 0) {
            Utils_1.CanvasUtils.drawParticle(this.container, this.context, particle, delta, fillColorValue, strokeColorValue, options.backgroundMask.enable, options.backgroundMask.composite, radius, opacity, particle.options.shadow);
        }
    }
    drawParticleLinks(particle) {
        if (!this.context) {
            return;
        }
        const container = this.container;
        const particles = container.particles;
        const pOptions = particle.options;
        if (particle.links.length > 0) {
            this.context.save();
            const p1Links = particle.links.filter((l) => {
                const linkFreq = container.particles.getLinkFrequency(particle, l.destination);
                return linkFreq <= pOptions.links.frequency;
            });
            for (const link of p1Links) {
                const p2 = link.destination;
                if (pOptions.links.triangles.enable) {
                    const links = p1Links.map((l) => l.destination);
                    const vertices = p2.links.filter((t) => {
                        const linkFreq = container.particles.getLinkFrequency(p2, t.destination);
                        return linkFreq <= p2.options.links.frequency && links.indexOf(t.destination) >= 0;
                    });
                    if (vertices.length) {
                        for (const vertex of vertices) {
                            const p3 = vertex.destination;
                            const triangleFreq = particles.getTriangleFrequency(particle, p2, p3);
                            if (triangleFreq > pOptions.links.triangles.frequency) {
                                continue;
                            }
                            this.drawLinkTriangle(particle, link, vertex);
                        }
                    }
                }
                if (link.opacity > 0 && container.retina.linksWidth > 0) {
                    this.drawLinkLine(particle, link);
                }
            }
            this.context.restore();
        }
    }
    drawPlugin(plugin, delta) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.drawPlugin(this.context, plugin, delta);
    }
    drawLight(mousePos) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.drawLight(this.container, this.context, mousePos);
    }
    paintBase(baseColor) {
        if (!this.context) {
            return;
        }
        Utils_1.CanvasUtils.paintBase(this.context, this.size, baseColor);
    }
    lineStyle(p1, p2) {
        if (!this.context) {
            return;
        }
        const options = this.container.actualOptions;
        const connectOptions = options.interactivity.modes.connect;
        return Utils_1.CanvasUtils.gradient(this.context, p1, p2, connectOptions.links.opacity);
    }
    initBackground() {
        const options = this.container.actualOptions;
        const background = options.background;
        const element = this.element;
        const elementStyle = element === null || element === void 0 ? void 0 : element.style;
        if (!elementStyle) {
            return;
        }
        if (background.color) {
            const color = Utils_1.ColorUtils.colorToRgb(background.color);
            elementStyle.backgroundColor = color ? Utils_1.ColorUtils.getStyleFromRgb(color, background.opacity) : "";
        }
        else {
            elementStyle.backgroundColor = "";
        }
        elementStyle.backgroundImage = background.image || "";
        elementStyle.backgroundPosition = background.position || "";
        elementStyle.backgroundRepeat = background.repeat || "";
        elementStyle.backgroundSize = background.size || "";
    }
}
exports.Canvas = Canvas;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Container.js":
/*!*********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Container.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Canvas_1 = __webpack_require__(/*! ./Canvas */ "./node_modules/tsparticles/dist/Core/Canvas.js");
const Particles_1 = __webpack_require__(/*! ./Particles */ "./node_modules/tsparticles/dist/Core/Particles.js");
const Retina_1 = __webpack_require__(/*! ./Retina */ "./node_modules/tsparticles/dist/Core/Retina.js");
const FrameManager_1 = __webpack_require__(/*! ./FrameManager */ "./node_modules/tsparticles/dist/Core/FrameManager.js");
const Options_1 = __webpack_require__(/*! ../Options/Classes/Options */ "./node_modules/tsparticles/dist/Options/Classes/Options.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Vector_1 = __webpack_require__(/*! ./Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js");
class Container {
    constructor(id, sourceOptions, ...presets) {
        this.id = id;
        this.fpsLimit = 60;
        this.firstStart = true;
        this.started = false;
        this.destroyed = false;
        this.paused = true;
        this.lastFrameTime = 0;
        this.pageHidden = false;
        this._sourceOptions = sourceOptions;
        this.retina = new Retina_1.Retina(this);
        this.canvas = new Canvas_1.Canvas(this);
        this.particles = new Particles_1.Particles(this);
        this.drawer = new FrameManager_1.FrameManager(this);
        this.pathGenerator = {
            generate: () => {
                const v = Vector_1.Vector.create(0, 0);
                v.length = Math.random();
                v.angle = Math.random() * Math.PI * 2;
                return v;
            },
            init: () => {
            },
            update: () => {
            },
        };
        this.interactivity = {
            mouse: {
                clicking: false,
                inside: false,
            },
        };
        this.bubble = {};
        this.repulse = { particles: [] };
        this.attract = { particles: [] };
        this.plugins = new Map();
        this.drawers = new Map();
        this.density = 1;
        this._options = new Options_1.Options();
        this.actualOptions = new Options_1.Options();
        for (const preset of presets) {
            this._options.load(Utils_1.Plugins.getPreset(preset));
        }
        const shapes = Utils_1.Plugins.getSupportedShapes();
        for (const type of shapes) {
            const drawer = Utils_1.Plugins.getShapeDrawer(type);
            if (drawer) {
                this.drawers.set(type, drawer);
            }
        }
        if (this._options) {
            this._options.load(this._sourceOptions);
        }
        this.eventListeners = new Utils_1.EventListeners(this);
        if (typeof IntersectionObserver !== "undefined" && IntersectionObserver) {
            this.intersectionObserver = new IntersectionObserver((entries) => this.intersectionManager(entries));
        }
    }
    get options() {
        return this._options;
    }
    get sourceOptions() {
        return this._sourceOptions;
    }
    play(force) {
        const needsUpdate = this.paused || force;
        if (this.firstStart && !this.actualOptions.autoPlay) {
            this.firstStart = false;
            return;
        }
        if (this.paused) {
            this.paused = false;
        }
        if (needsUpdate) {
            for (const [, plugin] of this.plugins) {
                if (plugin.play) {
                    plugin.play();
                }
            }
            this.lastFrameTime = performance.now();
        }
        this.draw();
    }
    pause() {
        if (this.drawAnimationFrame !== undefined) {
            Utils_1.Utils.cancelAnimation(this.drawAnimationFrame);
            delete this.drawAnimationFrame;
        }
        if (this.paused) {
            return;
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.pause) {
                plugin.pause();
            }
        }
        if (!this.pageHidden) {
            this.paused = true;
        }
    }
    draw() {
        this.drawAnimationFrame = Utils_1.Utils.animate((timestamp) => this.drawer.nextFrame(timestamp));
    }
    getAnimationStatus() {
        return !this.paused;
    }
    setNoise(noiseOrGenerator, init, update) {
        this.setPath(noiseOrGenerator, init, update);
    }
    setPath(pathOrGenerator, init, update) {
        if (!pathOrGenerator) {
            return;
        }
        if (typeof pathOrGenerator === "function") {
            this.pathGenerator.generate = pathOrGenerator;
            if (init) {
                this.pathGenerator.init = init;
            }
            if (update) {
                this.pathGenerator.update = update;
            }
        }
        else {
            if (pathOrGenerator.generate) {
                this.pathGenerator.generate = pathOrGenerator.generate;
            }
            if (pathOrGenerator.init) {
                this.pathGenerator.init = pathOrGenerator.init;
            }
            if (pathOrGenerator.update) {
                this.pathGenerator.update = pathOrGenerator.update;
            }
        }
    }
    destroy() {
        this.stop();
        this.canvas.destroy();
        for (const [, drawer] of this.drawers) {
            if (drawer.destroy) {
                drawer.destroy(this);
            }
        }
        for (const key of this.drawers.keys()) {
            this.drawers.delete(key);
        }
        this.destroyed = true;
    }
    exportImg(callback) {
        this.exportImage(callback);
    }
    exportImage(callback, type, quality) {
        var _a;
        return (_a = this.canvas.element) === null || _a === void 0 ? void 0 : _a.toBlob(callback, type !== null && type !== void 0 ? type : "image/png", quality);
    }
    exportConfiguration() {
        return JSON.stringify(this.actualOptions, undefined, 2);
    }
    refresh() {
        this.stop();
        return this.start();
    }
    reset() {
        this._options = new Options_1.Options();
        return this.refresh();
    }
    stop() {
        if (!this.started) {
            return;
        }
        this.firstStart = true;
        this.started = false;
        this.eventListeners.removeListeners();
        this.pause();
        this.particles.clear();
        this.canvas.clear();
        if (this.interactivity.element instanceof HTMLElement && this.intersectionObserver) {
            this.intersectionObserver.observe(this.interactivity.element);
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.stop) {
                plugin.stop();
            }
        }
        for (const key of this.plugins.keys()) {
            this.plugins.delete(key);
        }
        this.particles.linksColors = new Map();
        delete this.particles.grabLineColor;
        delete this.particles.linksColor;
    }
    loadTheme(name) {
        return __awaiter(this, void 0, void 0, function* () {
            this.actualOptions.setTheme(name);
            yield this.refresh();
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.started) {
                return;
            }
            yield this.init();
            this.started = true;
            this.eventListeners.addListeners();
            if (this.interactivity.element instanceof HTMLElement && this.intersectionObserver) {
                this.intersectionObserver.observe(this.interactivity.element);
            }
            for (const [, plugin] of this.plugins) {
                if (plugin.startAsync !== undefined) {
                    yield plugin.startAsync();
                }
                else if (plugin.start !== undefined) {
                    plugin.start();
                }
            }
            this.play();
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.actualOptions = new Options_1.Options();
            this.actualOptions.load(this._options);
            this.retina.init();
            this.canvas.init();
            this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options);
            this.actualOptions.setTheme(undefined);
            this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 60;
            const availablePlugins = Utils_1.Plugins.getAvailablePlugins(this);
            for (const [id, plugin] of availablePlugins) {
                this.plugins.set(id, plugin);
            }
            for (const [, drawer] of this.drawers) {
                if (drawer.init) {
                    yield drawer.init(this);
                }
            }
            for (const [, plugin] of this.plugins) {
                if (plugin.init) {
                    plugin.init(this.actualOptions);
                }
                else if (plugin.initAsync !== undefined) {
                    yield plugin.initAsync(this.actualOptions);
                }
            }
            this.canvas.resize();
            this.particles.init();
            this.particles.setDensity();
        });
    }
    intersectionManager(entries) {
        if (!this.actualOptions.pauseOnOutsideViewport) {
            return;
        }
        for (const entry of entries) {
            if (entry.target !== this.interactivity.element) {
                continue;
            }
            if (entry.isIntersecting) {
                this.play();
            }
            else {
                this.pause();
            }
        }
    }
}
exports.Container = Container;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/FrameManager.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/FrameManager.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameManager = void 0;
class FrameManager {
    constructor(container) {
        this.container = container;
    }
    nextFrame(timestamp) {
        try {
            const container = this.container;
            if (container.lastFrameTime !== undefined &&
                timestamp < container.lastFrameTime + 1000 / container.fpsLimit) {
                container.draw();
                return;
            }
            const deltaValue = timestamp - container.lastFrameTime;
            const delta = {
                value: deltaValue,
                factor: (60 * deltaValue) / 1000,
            };
            container.lastFrameTime = timestamp;
            container.particles.draw(delta);
            if (container.getAnimationStatus()) {
                container.draw();
            }
        }
        catch (e) {
            console.error("tsParticles error in animation loop", e);
        }
    }
}
exports.FrameManager = FrameManager;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Loader.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loader = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/tsparticles/dist/Core/Container.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const tsParticlesDom = [];
function fetchError(statusCode) {
    console.error(`Error tsParticles - fetch status: ${statusCode}`);
    console.error("Error tsParticles - File config not found");
}
class Loader {
    static dom() {
        return tsParticlesDom;
    }
    static domItem(index) {
        const dom = Loader.dom();
        const item = dom[index];
        if (item && !item.destroyed) {
            return item;
        }
        dom.splice(index, 1);
    }
    static load(tagId, options, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const domContainer = document.getElementById(tagId);
            if (!domContainer) {
                return;
            }
            return Loader.set(tagId, domContainer, options, index);
        });
    }
    static set(id, domContainer, options, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentOptions = options instanceof Array ? Utils_1.Utils.itemFromArray(options, index) : options;
            const dom = Loader.dom();
            const oldIndex = dom.findIndex((v) => v.id === id);
            if (oldIndex >= 0) {
                const old = Loader.domItem(oldIndex);
                if (old && !old.destroyed) {
                    old.destroy();
                    dom.splice(oldIndex, 1);
                }
            }
            let canvasEl;
            let generatedCanvas;
            if (domContainer.tagName.toLowerCase() === "canvas") {
                canvasEl = domContainer;
                generatedCanvas = false;
            }
            else {
                const existingCanvases = domContainer.getElementsByTagName("canvas");
                if (existingCanvases.length) {
                    canvasEl = existingCanvases[0];
                    if (!canvasEl.className) {
                        canvasEl.className = Utils_1.Constants.canvasClass;
                    }
                    generatedCanvas = false;
                }
                else {
                    generatedCanvas = true;
                    canvasEl = document.createElement("canvas");
                    canvasEl.className = Utils_1.Constants.canvasClass;
                    canvasEl.style.width = "100%";
                    canvasEl.style.height = "100%";
                    domContainer.appendChild(canvasEl);
                }
            }
            const newItem = new Container_1.Container(id, currentOptions);
            if (oldIndex >= 0) {
                dom.splice(oldIndex, 0, newItem);
            }
            else {
                dom.push(newItem);
            }
            newItem.canvas.loadCanvas(canvasEl, generatedCanvas);
            yield newItem.start();
            return newItem;
        });
    }
    static loadJSON(tagId, jsonUrl, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = jsonUrl instanceof Array ? Utils_1.Utils.itemFromArray(jsonUrl, index) : jsonUrl;
            const response = yield fetch(url);
            if (response.ok) {
                return Loader.load(tagId, yield response.json());
            }
            else {
                fetchError(response.status);
            }
        });
    }
    static setJSON(id, domContainer, jsonUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(jsonUrl);
            if (response.ok) {
                const options = yield response.json();
                return Loader.set(id, domContainer, options);
            }
            else {
                fetchError(response.status);
            }
        });
    }
    static setOnClickHandler(callback) {
        const dom = Loader.dom();
        if (dom.length === 0) {
            throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()");
        }
        for (const domItem of dom) {
            const el = domItem.interactivity.element;
            if (!el) {
                continue;
            }
            const clickOrTouchHandler = (e, pos) => {
                if (domItem.destroyed) {
                    return;
                }
                const pxRatio = domItem.retina.pixelRatio;
                const posRetina = {
                    x: pos.x * pxRatio,
                    y: pos.y * pxRatio,
                };
                const particles = domItem.particles.quadTree.queryCircle(posRetina, domItem.retina.sizeValue);
                callback(e, particles);
            };
            const clickHandler = (e) => {
                if (domItem.destroyed) {
                    return;
                }
                const mouseEvent = e;
                const pos = {
                    x: mouseEvent.offsetX || mouseEvent.clientX,
                    y: mouseEvent.offsetY || mouseEvent.clientY,
                };
                clickOrTouchHandler(e, pos);
            };
            const touchStartHandler = () => {
                if (domItem.destroyed) {
                    return;
                }
                touched = true;
                touchMoved = false;
            };
            const touchMoveHandler = () => {
                if (domItem.destroyed) {
                    return;
                }
                touchMoved = true;
            };
            const touchEndHandler = (e) => {
                var _a, _b, _c;
                if (domItem.destroyed) {
                    return;
                }
                if (touched && !touchMoved) {
                    const touchEvent = e;
                    const lastTouch = touchEvent.touches[touchEvent.touches.length - 1];
                    const canvasRect = (_a = domItem.canvas.element) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
                    const pos = {
                        x: lastTouch.clientX - ((_b = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) !== null && _b !== void 0 ? _b : 0),
                        y: lastTouch.clientY - ((_c = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) !== null && _c !== void 0 ? _c : 0),
                    };
                    clickOrTouchHandler(e, pos);
                }
                touched = false;
                touchMoved = false;
            };
            const touchCancelHandler = () => {
                if (domItem.destroyed) {
                    return;
                }
                touched = false;
                touchMoved = false;
            };
            let touched = false;
            let touchMoved = false;
            el.addEventListener("click", clickHandler);
            el.addEventListener("touchstart", touchStartHandler);
            el.addEventListener("touchmove", touchMoveHandler);
            el.addEventListener("touchend", touchEndHandler);
            el.addEventListener("touchcancel", touchCancelHandler);
        }
    }
}
exports.Loader = Loader;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle.js":
/*!********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Particle = void 0;
const Updater_1 = __webpack_require__(/*! ./Particle/Updater */ "./node_modules/tsparticles/dist/Core/Particle/Updater.js");
const ParticlesOptions_1 = __webpack_require__(/*! ../Options/Classes/Particles/ParticlesOptions */ "./node_modules/tsparticles/dist/Options/Classes/Particles/ParticlesOptions.js");
const Shape_1 = __webpack_require__(/*! ../Options/Classes/Particles/Shape/Shape */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js");
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Infecter_1 = __webpack_require__(/*! ./Particle/Infecter */ "./node_modules/tsparticles/dist/Core/Particle/Infecter.js");
const Mover_1 = __webpack_require__(/*! ./Particle/Mover */ "./node_modules/tsparticles/dist/Core/Particle/Mover.js");
const Vector_1 = __webpack_require__(/*! ./Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js");
class Particle {
    constructor(id, container, position, overrideOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.id = id;
        this.container = container;
        this.links = [];
        this.fill = true;
        this.close = true;
        this.lastPathTime = 0;
        this.destroyed = false;
        this.unbreakable = false;
        this.splitCount = 0;
        this.misplaced = false;
        this.loops = {
            opacity: 0,
            size: 0,
        };
        const pxRatio = container.retina.pixelRatio;
        const options = container.actualOptions;
        const particlesOptions = new ParticlesOptions_1.ParticlesOptions();
        particlesOptions.load(options.particles);
        const shapeType = particlesOptions.shape.type;
        const reduceDuplicates = particlesOptions.reduceDuplicates;
        this.shape = shapeType instanceof Array ? Utils_1.Utils.itemFromArray(shapeType, this.id, reduceDuplicates) : shapeType;
        if (overrideOptions === null || overrideOptions === void 0 ? void 0 : overrideOptions.shape) {
            if (overrideOptions.shape.type) {
                const overrideShapeType = overrideOptions.shape.type;
                this.shape =
                    overrideShapeType instanceof Array
                        ? Utils_1.Utils.itemFromArray(overrideShapeType, this.id, reduceDuplicates)
                        : overrideShapeType;
            }
            const shapeOptions = new Shape_1.Shape();
            shapeOptions.load(overrideOptions.shape);
            if (this.shape) {
                const shapeData = shapeOptions.options[this.shape];
                if (shapeData) {
                    this.shapeData = Utils_1.Utils.deepExtend({}, shapeData instanceof Array
                        ? Utils_1.Utils.itemFromArray(shapeData, this.id, reduceDuplicates)
                        : shapeData);
                }
            }
        }
        else {
            const shapeData = particlesOptions.shape.options[this.shape];
            if (shapeData) {
                this.shapeData = Utils_1.Utils.deepExtend({}, shapeData instanceof Array ? Utils_1.Utils.itemFromArray(shapeData, this.id, reduceDuplicates) : shapeData);
            }
        }
        if (overrideOptions !== undefined) {
            particlesOptions.load(overrideOptions);
        }
        if (((_a = this.shapeData) === null || _a === void 0 ? void 0 : _a.particles) !== undefined) {
            particlesOptions.load((_b = this.shapeData) === null || _b === void 0 ? void 0 : _b.particles);
        }
        this.fill = (_d = (_c = this.shapeData) === null || _c === void 0 ? void 0 : _c.fill) !== null && _d !== void 0 ? _d : this.fill;
        this.close = (_f = (_e = this.shapeData) === null || _e === void 0 ? void 0 : _e.close) !== null && _f !== void 0 ? _f : this.close;
        this.options = particlesOptions;
        this.pathDelay = Utils_1.NumberUtils.getValue(this.options.move.path.delay) * 1000;
        container.retina.initParticle(this);
        const color = this.options.color;
        const sizeOptions = this.options.size;
        const sizeValue = Utils_1.NumberUtils.getValue(sizeOptions) * container.retina.pixelRatio;
        const randomSize = typeof sizeOptions.random === "boolean" ? sizeOptions.random : sizeOptions.random.enable;
        this.size = {
            value: sizeValue,
        };
        this.direction = this.options.move.direction;
        this.bubble = {
            inRange: false,
        };
        this.initialVelocity = this.calculateVelocity();
        this.velocity = this.initialVelocity.copy();
        const rotateOptions = this.options.rotate;
        this.rotate = {
            value: (Utils_1.NumberUtils.getRangeValue(rotateOptions.value) * Math.PI) / 180,
        };
        let rotateDirection = rotateOptions.direction;
        if (rotateDirection === Enums_1.RotateDirection.random) {
            const index = Math.floor(Math.random() * 2);
            rotateDirection = index > 0 ? Enums_1.RotateDirection.counterClockwise : Enums_1.RotateDirection.clockwise;
        }
        switch (rotateDirection) {
            case Enums_1.RotateDirection.counterClockwise:
            case "counterClockwise":
                this.rotate.status = Enums_1.AnimationStatus.decreasing;
                break;
            case Enums_1.RotateDirection.clockwise:
                this.rotate.status = Enums_1.AnimationStatus.increasing;
                break;
        }
        const rotateAnimation = this.options.rotate.animation;
        if (rotateAnimation.enable) {
            this.rotate.velocity = (rotateAnimation.speed / 360) * container.retina.reduceFactor;
            if (!rotateAnimation.sync) {
                this.rotate.velocity *= Math.random();
            }
        }
        const sizeAnimation = this.options.size.animation;
        if (sizeAnimation.enable) {
            this.size.status = Enums_1.AnimationStatus.increasing;
            if (!randomSize) {
                switch (sizeAnimation.startValue) {
                    case Enums_1.StartValueType.min:
                        this.size.value = sizeAnimation.minimumValue * pxRatio;
                        break;
                    case Enums_1.StartValueType.random:
                        this.size.value = Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(sizeAnimation.minimumValue * pxRatio, this.size.value));
                        break;
                    case Enums_1.StartValueType.max:
                    default:
                        this.size.status = Enums_1.AnimationStatus.decreasing;
                        break;
                }
            }
            this.size.velocity =
                (((_g = this.sizeAnimationSpeed) !== null && _g !== void 0 ? _g : container.retina.sizeAnimationSpeed) / 100) *
                    container.retina.reduceFactor;
            if (!sizeAnimation.sync) {
                this.size.velocity *= Math.random();
            }
        }
        const hslColor = Utils_1.ColorUtils.colorToHsl(color, this.id, reduceDuplicates);
        if (hslColor) {
            this.color = {
                h: {
                    value: hslColor.h,
                },
                s: {
                    value: hslColor.s,
                },
                l: {
                    value: hslColor.l,
                },
            };
            const colorAnimation = this.options.color.animation;
            this.setColorAnimation(colorAnimation.h, this.color.h);
            this.setColorAnimation(colorAnimation.s, this.color.s);
            this.setColorAnimation(colorAnimation.l, this.color.l);
        }
        this.position = this.calcPosition(this.container, position);
        this.initialPosition = this.position.copy();
        this.offset = Vector_1.Vector.create(0, 0);
        const opacityOptions = this.options.opacity;
        const randomOpacity = typeof opacityOptions.random === "boolean" ? opacityOptions.random : opacityOptions.random.enable;
        this.opacity = {
            value: Utils_1.NumberUtils.getValue(opacityOptions),
        };
        const opacityAnimation = opacityOptions.animation;
        if (opacityAnimation.enable) {
            this.opacity.status = Enums_1.AnimationStatus.increasing;
            if (!randomOpacity) {
                switch (opacityAnimation.startValue) {
                    case Enums_1.StartValueType.min:
                        this.opacity.value = opacityAnimation.minimumValue;
                        break;
                    case Enums_1.StartValueType.random:
                        this.opacity.value = Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(opacityAnimation.minimumValue, this.opacity.value));
                        break;
                    case Enums_1.StartValueType.max:
                    default:
                        this.opacity.status = Enums_1.AnimationStatus.decreasing;
                        break;
                }
            }
            this.opacity.velocity = (opacityAnimation.speed / 100) * container.retina.reduceFactor;
            if (!opacityAnimation.sync) {
                this.opacity.velocity *= Math.random();
            }
        }
        this.sides = 24;
        let drawer = container.drawers.get(this.shape);
        if (!drawer) {
            drawer = Utils_1.Plugins.getShapeDrawer(this.shape);
            if (drawer) {
                container.drawers.set(this.shape, drawer);
            }
        }
        const sideCountFunc = drawer === null || drawer === void 0 ? void 0 : drawer.getSidesCount;
        if (sideCountFunc) {
            this.sides = sideCountFunc(this);
        }
        const imageShape = this.loadImageShape(container, drawer);
        if (imageShape) {
            this.image = imageShape.image;
            this.fill = imageShape.fill;
            this.close = imageShape.close;
        }
        this.stroke =
            this.options.stroke instanceof Array
                ? Utils_1.Utils.itemFromArray(this.options.stroke, this.id, reduceDuplicates)
                : this.options.stroke;
        this.strokeWidth = this.stroke.width * container.retina.pixelRatio;
        const strokeHslColor = (_h = Utils_1.ColorUtils.colorToHsl(this.stroke.color)) !== null && _h !== void 0 ? _h : this.getFillColor();
        if (strokeHslColor) {
            this.strokeColor = {
                h: {
                    value: strokeHslColor.h,
                },
                s: {
                    value: strokeHslColor.s,
                },
                l: {
                    value: strokeHslColor.l,
                },
            };
            const strokeColorAnimation = (_j = this.stroke.color) === null || _j === void 0 ? void 0 : _j.animation;
            if (strokeColorAnimation && this.strokeColor) {
                this.setColorAnimation(strokeColorAnimation.h, this.strokeColor.h);
                this.setColorAnimation(strokeColorAnimation.s, this.strokeColor.s);
                this.setColorAnimation(strokeColorAnimation.l, this.strokeColor.l);
            }
        }
        const lifeOptions = particlesOptions.life;
        this.lifeDelay = container.retina.reduceFactor
            ? ((Utils_1.NumberUtils.getValue(lifeOptions.delay) * (lifeOptions.delay.sync ? 1 : Math.random())) /
                container.retina.reduceFactor) *
                1000
            : 0;
        this.lifeDelayTime = 0;
        this.lifeDuration = container.retina.reduceFactor
            ? ((Utils_1.NumberUtils.getValue(lifeOptions.duration) * (lifeOptions.duration.sync ? 1 : Math.random())) /
                container.retina.reduceFactor) *
                1000
            : 0;
        this.lifeTime = 0;
        this.livesRemaining = particlesOptions.life.count;
        this.spawning = this.lifeDelay > 0;
        if (this.lifeDuration <= 0) {
            this.lifeDuration = -1;
        }
        if (this.livesRemaining <= 0) {
            this.livesRemaining = -1;
        }
        this.shadowColor = Utils_1.ColorUtils.colorToRgb(this.options.shadow.color);
        this.updater = new Updater_1.Updater(container, this);
        this.infecter = new Infecter_1.Infecter(container);
        this.mover = new Mover_1.Mover(container, this);
        if (drawer && drawer.particleInit) {
            drawer.particleInit(container, this);
        }
    }
    move(delta) {
        this.mover.move(delta);
    }
    update(delta) {
        this.updater.update(delta);
    }
    draw(delta) {
        this.container.canvas.drawParticle(this, delta);
    }
    getPosition() {
        return this.position.add(this.offset);
    }
    getRadius() {
        return this.bubble.radius || this.size.value;
    }
    getMass() {
        const radius = this.getRadius();
        return (Math.pow(radius, 2) * Math.PI) / 2;
    }
    getFillColor() {
        var _a;
        return (_a = this.bubble.color) !== null && _a !== void 0 ? _a : Utils_1.ColorUtils.getHslFromAnimation(this.color);
    }
    getStrokeColor() {
        var _a, _b;
        return (_b = (_a = this.bubble.color) !== null && _a !== void 0 ? _a : Utils_1.ColorUtils.getHslFromAnimation(this.strokeColor)) !== null && _b !== void 0 ? _b : this.getFillColor();
    }
    destroy(override) {
        this.destroyed = true;
        this.bubble.inRange = false;
        this.links = [];
        if (this.unbreakable) {
            return;
        }
        this.destroyed = true;
        this.bubble.inRange = false;
        for (const [, plugin] of this.container.plugins) {
            if (plugin.particleDestroyed) {
                plugin.particleDestroyed(this, override);
            }
        }
        if (override) {
            return;
        }
        const destroyOptions = this.options.destroy;
        if (destroyOptions.mode === Enums_1.DestroyMode.split) {
            this.split();
        }
    }
    reset() {
        this.loops.opacity = 0;
        this.loops.size = 0;
    }
    split() {
        const splitOptions = this.options.destroy.split;
        if (splitOptions.count >= 0 && this.splitCount++ > splitOptions.count) {
            return;
        }
        const rate = Utils_1.NumberUtils.getRangeValue(splitOptions.rate.value);
        for (let i = 0; i < rate; i++) {
            this.container.particles.addSplitParticle(this);
        }
    }
    setColorAnimation(colorAnimation, colorValue) {
        if (colorAnimation.enable) {
            colorValue.velocity = (colorAnimation.speed / 100) * this.container.retina.reduceFactor;
            if (colorAnimation.sync) {
                return;
            }
            colorValue.status = Enums_1.AnimationStatus.increasing;
            colorValue.velocity *= Math.random();
            if (colorValue.value) {
                colorValue.value *= Math.random();
            }
        }
        else {
            colorValue.velocity = 0;
        }
    }
    calcPosition(container, position, tryCount = 0) {
        var _a, _b;
        for (const [, plugin] of container.plugins) {
            const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;
            if (pluginPos !== undefined) {
                return Vector_1.Vector.create(pluginPos.x, pluginPos.y);
            }
        }
        const pos = Vector_1.Vector.create((_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * container.canvas.size.width, (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * container.canvas.size.height);
        const outMode = this.options.move.outMode;
        if (Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounce) || Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounceHorizontal)) {
            if (pos.x > container.canvas.size.width - this.size.value * 2) {
                pos.x -= this.size.value;
            }
            else if (pos.x < this.size.value * 2) {
                pos.x += this.size.value;
            }
        }
        if (Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounce) || Utils_1.Utils.isInArray(outMode, Enums_1.OutMode.bounceVertical)) {
            if (pos.y > container.canvas.size.height - this.size.value * 2) {
                pos.y -= this.size.value;
            }
            else if (pos.y < this.size.value * 2) {
                pos.y += this.size.value;
            }
        }
        if (this.checkOverlap(pos, tryCount)) {
            return this.calcPosition(container, undefined, tryCount + 1);
        }
        return pos;
    }
    checkOverlap(pos, tryCount = 0) {
        const overlapOptions = this.options.collisions.overlap;
        if (!overlapOptions.enable) {
            const retries = overlapOptions.retries;
            if (retries >= 0 && tryCount > retries) {
                throw new Error("Particle is overlapping and can't be placed");
            }
            let overlaps = false;
            for (const particle of this.container.particles.array) {
                if (Utils_1.NumberUtils.getDistance(pos, particle.position) < this.size.value + particle.size.value) {
                    overlaps = true;
                    break;
                }
            }
            return overlaps;
        }
        return false;
    }
    calculateVelocity() {
        const baseVelocity = Utils_1.NumberUtils.getParticleBaseVelocity(this.direction);
        const res = baseVelocity.copy();
        const moveOptions = this.options.move;
        let rad;
        let radOffset = Math.PI / 4;
        if (typeof moveOptions.angle === "number") {
            rad = (Math.PI / 180) * moveOptions.angle;
        }
        else {
            rad = (Math.PI / 180) * moveOptions.angle.value;
            radOffset = (Math.PI / 180) * moveOptions.angle.offset;
        }
        const range = {
            left: Math.sin(radOffset + rad / 2) - Math.sin(radOffset - rad / 2),
            right: Math.cos(radOffset + rad / 2) - Math.cos(radOffset - rad / 2),
        };
        if (!moveOptions.straight || moveOptions.random) {
            res.x += Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(range.left, range.right)) / 2;
            res.y += Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(range.left, range.right)) / 2;
        }
        return res;
    }
    loadImageShape(container, drawer) {
        var _a, _b, _c, _d, _e;
        if (!(this.shape === Enums_1.ShapeType.image || this.shape === Enums_1.ShapeType.images)) {
            return;
        }
        const imageDrawer = drawer;
        const images = imageDrawer.getImages(container).images;
        const imageData = this.shapeData;
        const image = (_a = images.find((t) => t.source === imageData.src)) !== null && _a !== void 0 ? _a : images[0];
        const color = this.getFillColor();
        let imageRes;
        if (!image) {
            return;
        }
        if (image.svgData !== undefined && imageData.replaceColor && color) {
            const svgColoredData = Utils_1.ColorUtils.replaceColorSvg(image, color, this.opacity.value);
            const svg = new Blob([svgColoredData], { type: "image/svg+xml" });
            const domUrl = URL || window.URL || window.webkitURL || window;
            const url = domUrl.createObjectURL(svg);
            const img = new Image();
            imageRes = {
                data: image,
                loaded: false,
                ratio: imageData.width / imageData.height,
                replaceColor: (_b = imageData.replaceColor) !== null && _b !== void 0 ? _b : imageData.replace_color,
                source: imageData.src,
            };
            img.addEventListener("load", () => {
                if (this.image) {
                    this.image.loaded = true;
                    image.element = img;
                }
                domUrl.revokeObjectURL(url);
            });
            img.addEventListener("error", () => {
                domUrl.revokeObjectURL(url);
                Utils_1.Utils.loadImage(imageData.src).then((img2) => {
                    if (this.image && img2) {
                        image.element = img2.element;
                        this.image.loaded = true;
                    }
                });
            });
            img.src = url;
        }
        else {
            imageRes = {
                data: image,
                loaded: true,
                ratio: imageData.width / imageData.height,
                replaceColor: (_c = imageData.replaceColor) !== null && _c !== void 0 ? _c : imageData.replace_color,
                source: imageData.src,
            };
        }
        if (!imageRes.ratio) {
            imageRes.ratio = 1;
        }
        const fill = (_d = imageData.fill) !== null && _d !== void 0 ? _d : this.fill;
        const close = (_e = imageData.close) !== null && _e !== void 0 ? _e : this.close;
        return {
            image: imageRes,
            fill,
            close,
        };
    }
}
exports.Particle = Particle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Infecter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Infecter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Infecter = void 0;
class Infecter {
    constructor(container) {
        this.container = container;
    }
    startInfection(stage) {
        const options = this.container.actualOptions;
        const stages = options.infection.stages;
        const stagesCount = stages.length;
        if (stage > stagesCount || stage < 0) {
            return;
        }
        this.infectionDelay = 0;
        this.infectionDelayStage = stage;
    }
    updateInfectionStage(stage) {
        const options = this.container.actualOptions;
        const stagesCount = options.infection.stages.length;
        if (stage > stagesCount || stage < 0 || (this.infectionStage !== undefined && this.infectionStage > stage)) {
            return;
        }
        this.infectionStage = stage;
        this.infectionTime = 0;
    }
    updateInfection(delta) {
        const options = this.container.actualOptions;
        const infection = options.infection;
        const stages = options.infection.stages;
        const stagesCount = stages.length;
        if (this.infectionDelay !== undefined && this.infectionDelayStage !== undefined) {
            const stage = this.infectionDelayStage;
            if (stage > stagesCount || stage < 0) {
                return;
            }
            if (this.infectionDelay > infection.delay * 1000) {
                this.infectionStage = stage;
                this.infectionTime = 0;
                delete this.infectionDelay;
                delete this.infectionDelayStage;
            }
            else {
                this.infectionDelay += delta;
            }
        }
        else {
            delete this.infectionDelay;
            delete this.infectionDelayStage;
        }
        if (this.infectionStage !== undefined && this.infectionTime !== undefined) {
            const infectionStage = stages[this.infectionStage];
            if (infectionStage.duration !== undefined && infectionStage.duration >= 0) {
                if (this.infectionTime > infectionStage.duration * 1000) {
                    this.nextInfectionStage();
                }
                else {
                    this.infectionTime += delta;
                }
            }
            else {
                this.infectionTime += delta;
            }
        }
        else {
            delete this.infectionStage;
            delete this.infectionTime;
        }
    }
    nextInfectionStage() {
        const options = this.container.actualOptions;
        const stagesCount = options.infection.stages.length;
        if (stagesCount <= 0 || this.infectionStage === undefined) {
            return;
        }
        this.infectionTime = 0;
        if (stagesCount <= ++this.infectionStage) {
            if (options.infection.cure) {
                delete this.infectionStage;
                delete this.infectionTime;
                return;
            }
            else {
                this.infectionStage = 0;
                this.infectionTime = 0;
            }
        }
    }
}
exports.Infecter = Infecter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/InteractionManager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/InteractionManager.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionManager = void 0;
const Grabber_1 = __webpack_require__(/*! ../../Interactions/External/Grabber */ "./node_modules/tsparticles/dist/Interactions/External/Grabber.js");
const Repulser_1 = __webpack_require__(/*! ../../Interactions/External/Repulser */ "./node_modules/tsparticles/dist/Interactions/External/Repulser.js");
const Bubbler_1 = __webpack_require__(/*! ../../Interactions/External/Bubbler */ "./node_modules/tsparticles/dist/Interactions/External/Bubbler.js");
const Connector_1 = __webpack_require__(/*! ../../Interactions/External/Connector */ "./node_modules/tsparticles/dist/Interactions/External/Connector.js");
const Linker_1 = __webpack_require__(/*! ../../Interactions/Particles/Linker */ "./node_modules/tsparticles/dist/Interactions/Particles/Linker.js");
const Attractor_1 = __webpack_require__(/*! ../../Interactions/Particles/Attractor */ "./node_modules/tsparticles/dist/Interactions/Particles/Attractor.js");
const Collider_1 = __webpack_require__(/*! ../../Interactions/Particles/Collider */ "./node_modules/tsparticles/dist/Interactions/Particles/Collider.js");
const Infecter_1 = __webpack_require__(/*! ../../Interactions/Particles/Infecter */ "./node_modules/tsparticles/dist/Interactions/Particles/Infecter.js");
const TrailMaker_1 = __webpack_require__(/*! ../../Interactions/External/TrailMaker */ "./node_modules/tsparticles/dist/Interactions/External/TrailMaker.js");
const Attractor_2 = __webpack_require__(/*! ../../Interactions/External/Attractor */ "./node_modules/tsparticles/dist/Interactions/External/Attractor.js");
const Lighter_1 = __webpack_require__(/*! ../../Interactions/Particles/Lighter */ "./node_modules/tsparticles/dist/Interactions/Particles/Lighter.js");
const Lighter_2 = __webpack_require__(/*! ../../Interactions/External/Lighter */ "./node_modules/tsparticles/dist/Interactions/External/Lighter.js");
const Bouncer_1 = __webpack_require__(/*! ../../Interactions/External/Bouncer */ "./node_modules/tsparticles/dist/Interactions/External/Bouncer.js");
class InteractionManager {
    constructor(container) {
        this.container = container;
        this.externalInteractors = [
            new Bouncer_1.Bouncer(container),
            new Bubbler_1.Bubbler(container),
            new Connector_1.Connector(container),
            new Grabber_1.Grabber(container),
            new Lighter_2.Lighter(container),
            new Attractor_2.Attractor(container),
            new Repulser_1.Repulser(container),
            new TrailMaker_1.TrailMaker(container),
        ];
        this.particleInteractors = [
            new Attractor_1.Attractor(container),
            new Lighter_1.Lighter(container),
            new Collider_1.Collider(container),
            new Infecter_1.Infecter(container),
            new Linker_1.Linker(container),
        ];
    }
    init() {
    }
    externalInteract(delta) {
        for (const interactor of this.externalInteractors) {
            if (interactor.isEnabled()) {
                interactor.interact(delta);
            }
        }
    }
    particlesInteract(particle, delta) {
        for (const interactor of this.externalInteractors) {
            interactor.reset(particle);
        }
        for (const interactor of this.particleInteractors) {
            if (interactor.isEnabled(particle)) {
                interactor.interact(particle, delta);
            }
        }
    }
}
exports.InteractionManager = InteractionManager;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Mover.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Mover.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mover = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class Mover {
    constructor(container, particle) {
        this.container = container;
        this.particle = particle;
    }
    move(delta) {
        const particle = this.particle;
        particle.bubble.inRange = false;
        particle.links = [];
        for (const [, plugin] of this.container.plugins) {
            if (particle.destroyed) {
                break;
            }
            if (plugin.particleUpdate) {
                plugin.particleUpdate(particle, delta);
            }
        }
        if (particle.destroyed) {
            return;
        }
        this.moveParticle(delta);
        this.moveParallax();
    }
    moveParticle(delta) {
        var _a, _b;
        const particle = this.particle;
        const particlesOptions = particle.options;
        if (!particlesOptions.move.enable) {
            return;
        }
        const container = this.container;
        const slowFactor = this.getProximitySpeedFactor();
        const baseSpeed = ((_a = particle.moveSpeed) !== null && _a !== void 0 ? _a : Utils_1.NumberUtils.getRangeValue(particle.options.move.speed) * container.retina.pixelRatio) *
            container.retina.reduceFactor;
        const maxSize = Utils_1.NumberUtils.getRangeMax(particle.options.size.value) * container.retina.pixelRatio;
        const sizeFactor = particlesOptions.move.size ? particle.getRadius() / maxSize : 1;
        const moveSpeed = (baseSpeed / 2) * sizeFactor * slowFactor * delta.factor;
        const moveDrift = (_b = particle.moveDrift) !== null && _b !== void 0 ? _b : Utils_1.NumberUtils.getRangeValue(particle.options.move.drift) * container.retina.pixelRatio;
        this.applyPath(delta);
        const gravityOptions = particlesOptions.move.gravity;
        if (gravityOptions.enable) {
            particle.velocity.y += (gravityOptions.acceleration * delta.factor) / (60 * moveSpeed);
        }
        particle.velocity.x += (moveDrift * delta.factor) / (60 * moveSpeed);
        const decay = 1 - particle.options.move.decay;
        particle.velocity.multTo(decay);
        const velocity = particle.velocity.mult(moveSpeed);
        if (gravityOptions.enable && velocity.y >= gravityOptions.maxSpeed && gravityOptions.maxSpeed > 0) {
            velocity.y = gravityOptions.maxSpeed;
            particle.velocity.y = velocity.y / moveSpeed;
        }
        particle.position.addTo(velocity);
        if (particlesOptions.move.vibrate) {
            particle.position.x += Math.sin(particle.position.x * Math.cos(particle.position.y));
            particle.position.y += Math.cos(particle.position.y * Math.sin(particle.position.x));
        }
        const initialPosition = particle.initialPosition;
        const initialDistance = Utils_1.NumberUtils.getDistance(initialPosition, particle.position);
        if (particle.maxDistance) {
            if (initialDistance >= particle.maxDistance && !particle.misplaced) {
                particle.misplaced = initialDistance > particle.maxDistance;
                particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;
                particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;
            }
            else if (initialDistance < particle.maxDistance && particle.misplaced) {
                particle.misplaced = false;
            }
            else if (particle.misplaced) {
                if ((particle.position.x < initialPosition.x && particle.velocity.x < 0) ||
                    (particle.position.x > initialPosition.x && particle.velocity.x > 0)) {
                    particle.velocity.x *= -Math.random();
                }
                if ((particle.position.y < initialPosition.y && particle.velocity.y < 0) ||
                    (particle.position.y > initialPosition.y && particle.velocity.y > 0)) {
                    particle.velocity.y *= -Math.random();
                }
            }
        }
    }
    applyPath(delta) {
        const particle = this.particle;
        const particlesOptions = particle.options;
        const pathOptions = particlesOptions.move.path;
        const pathEnabled = pathOptions.enable;
        if (!pathEnabled) {
            return;
        }
        const container = this.container;
        if (particle.lastPathTime <= particle.pathDelay) {
            particle.lastPathTime += delta.value;
            return;
        }
        let generator = container.pathGenerator;
        if (pathOptions.generator) {
            const customGenerator = Utils_1.Plugins.getPathGenerator(pathOptions.generator);
            if (customGenerator) {
                generator = customGenerator;
            }
        }
        const path = generator.generate(particle);
        particle.velocity.addTo(path);
        if (pathOptions.clamp) {
            particle.velocity.x = Utils_1.NumberUtils.clamp(particle.velocity.x, -1, 1);
            particle.velocity.y = Utils_1.NumberUtils.clamp(particle.velocity.y, -1, 1);
        }
        particle.lastPathTime -= particle.pathDelay;
    }
    moveParallax() {
        const container = this.container;
        const options = container.actualOptions;
        if (Utils_1.Utils.isSsr() || !options.interactivity.events.onHover.parallax.enable) {
            return;
        }
        const particle = this.particle;
        const parallaxForce = options.interactivity.events.onHover.parallax.force;
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const canvasCenter = {
            x: container.canvas.size.width / 2,
            y: container.canvas.size.height / 2,
        };
        const parallaxSmooth = options.interactivity.events.onHover.parallax.smooth;
        const factor = particle.getRadius() / parallaxForce;
        const tmp = {
            x: (mousePos.x - canvasCenter.x) * factor,
            y: (mousePos.y - canvasCenter.y) * factor,
        };
        particle.offset.x += (tmp.x - particle.offset.x) / parallaxSmooth;
        particle.offset.y += (tmp.y - particle.offset.y) / parallaxSmooth;
    }
    getProximitySpeedFactor() {
        const container = this.container;
        const options = container.actualOptions;
        const active = Utils_1.Utils.isInArray(Enums_1.HoverMode.slow, options.interactivity.events.onHover.mode);
        if (!active) {
            return 1;
        }
        const mousePos = this.container.interactivity.mouse.position;
        if (!mousePos) {
            return 1;
        }
        const particlePos = this.particle.getPosition();
        const dist = Utils_1.NumberUtils.getDistance(mousePos, particlePos);
        const radius = container.retina.slowModeRadius;
        if (dist > radius) {
            return 1;
        }
        const proximityFactor = dist / radius || 0;
        const slowFactor = options.interactivity.modes.slow.factor;
        return proximityFactor / slowFactor;
    }
}
exports.Mover = Mover;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Updater.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Updater.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Updater = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const OutModeDirection_1 = __webpack_require__(/*! ../../Enums/Directions/OutModeDirection */ "./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js");
function bounceHorizontal(data) {
    if (data.outMode === Enums_1.OutMode.bounce ||
        data.outMode === Enums_1.OutMode.bounceHorizontal ||
        data.outMode === "bounceHorizontal" ||
        data.outMode === Enums_1.OutMode.split) {
        const velocity = data.particle.velocity.x;
        let bounced = false;
        if ((data.direction === OutModeDirection_1.OutModeDirection.right && data.bounds.right >= data.canvasSize.width && velocity > 0) ||
            (data.direction === OutModeDirection_1.OutModeDirection.left && data.bounds.left <= 0 && velocity < 0)) {
            const newVelocity = Utils_1.NumberUtils.getValue(data.particle.options.bounce.horizontal);
            data.particle.velocity.x *= -newVelocity;
            bounced = true;
        }
        if (!bounced) {
            return;
        }
        const minPos = data.offset.x + data.size;
        if (data.bounds.right >= data.canvasSize.width) {
            data.particle.position.x = data.canvasSize.width - minPos;
        }
        else if (data.bounds.left <= 0) {
            data.particle.position.x = minPos;
        }
        if (data.outMode === Enums_1.OutMode.split) {
            data.particle.destroy();
        }
    }
}
function bounceVertical(data) {
    if (data.outMode === Enums_1.OutMode.bounce ||
        data.outMode === Enums_1.OutMode.bounceVertical ||
        data.outMode === "bounceVertical" ||
        data.outMode === Enums_1.OutMode.split) {
        const velocity = data.particle.velocity.y;
        let bounced = false;
        if ((data.direction === OutModeDirection_1.OutModeDirection.bottom &&
            data.bounds.bottom >= data.canvasSize.height &&
            velocity > 0) ||
            (data.direction === OutModeDirection_1.OutModeDirection.top && data.bounds.top <= 0 && velocity < 0)) {
            const newVelocity = Utils_1.NumberUtils.getValue(data.particle.options.bounce.vertical);
            data.particle.velocity.y *= -newVelocity;
            bounced = true;
        }
        if (!bounced) {
            return;
        }
        const minPos = data.offset.y + data.size;
        if (data.bounds.bottom >= data.canvasSize.height) {
            data.particle.position.y = data.canvasSize.height - minPos;
        }
        else if (data.bounds.top <= 0) {
            data.particle.position.y = minPos;
        }
        if (data.outMode === Enums_1.OutMode.split) {
            data.particle.destroy();
        }
    }
}
function checkDestroy(particle, destroy, value, minValue, maxValue) {
    switch (destroy) {
        case Enums_1.DestroyType.max:
            if (value >= maxValue) {
                particle.destroy();
            }
            break;
        case Enums_1.DestroyType.min:
            if (value <= minValue) {
                particle.destroy();
            }
            break;
    }
}
class Updater {
    constructor(container, particle) {
        this.container = container;
        this.particle = particle;
    }
    update(delta) {
        if (this.particle.destroyed) {
            return;
        }
        this.updateLife(delta);
        if (this.particle.destroyed || this.particle.spawning) {
            return;
        }
        this.updateOpacity(delta);
        this.updateSize(delta);
        this.updateAngle(delta);
        this.updateColor(delta);
        this.updateStrokeColor(delta);
        this.updateOutModes(delta);
    }
    updateLife(delta) {
        const particle = this.particle;
        let justSpawned = false;
        if (particle.spawning) {
            particle.lifeDelayTime += delta.value;
            if (particle.lifeDelayTime >= particle.lifeDelay) {
                justSpawned = true;
                particle.spawning = false;
                particle.lifeDelayTime = 0;
                particle.lifeTime = 0;
            }
        }
        if (particle.lifeDuration === -1) {
            return;
        }
        if (!particle.spawning) {
            if (justSpawned) {
                particle.lifeTime = 0;
            }
            else {
                particle.lifeTime += delta.value;
            }
            if (particle.lifeTime >= particle.lifeDuration) {
                particle.lifeTime = 0;
                if (particle.livesRemaining > 0) {
                    particle.livesRemaining--;
                }
                if (particle.livesRemaining === 0) {
                    particle.destroy();
                    return;
                }
                const canvasSize = this.container.canvas.size;
                particle.position.x = Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(0, canvasSize.width));
                particle.position.y = Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(0, canvasSize.height));
                particle.spawning = true;
                particle.lifeDelayTime = 0;
                particle.lifeTime = 0;
                particle.reset();
                const lifeOptions = particle.options.life;
                particle.lifeDelay = Utils_1.NumberUtils.getValue(lifeOptions.delay) * 1000;
                particle.lifeDuration = Utils_1.NumberUtils.getValue(lifeOptions.duration) * 1000;
            }
        }
    }
    updateOpacity(delta) {
        var _a, _b;
        const particle = this.particle;
        const opacityOpt = particle.options.opacity;
        const opacityAnim = opacityOpt.animation;
        const minValue = Utils_1.NumberUtils.getRangeMin(opacityOpt.value);
        const maxValue = Utils_1.NumberUtils.getRangeMax(opacityOpt.value);
        if (!particle.destroyed &&
            opacityAnim.enable &&
            (opacityAnim.count <= 0 || particle.loops.size < opacityAnim.count)) {
            switch (particle.opacity.status) {
                case Enums_1.AnimationStatus.increasing:
                    if (particle.opacity.value >= maxValue) {
                        particle.opacity.status = Enums_1.AnimationStatus.decreasing;
                        particle.loops.opacity++;
                    }
                    else {
                        particle.opacity.value += ((_a = particle.opacity.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
                    }
                    break;
                case Enums_1.AnimationStatus.decreasing:
                    if (particle.opacity.value <= minValue) {
                        particle.opacity.status = Enums_1.AnimationStatus.increasing;
                        particle.loops.opacity++;
                    }
                    else {
                        particle.opacity.value -= ((_b = particle.opacity.velocity) !== null && _b !== void 0 ? _b : 0) * delta.factor;
                    }
                    break;
            }
            checkDestroy(particle, opacityAnim.destroy, particle.opacity.value, minValue, maxValue);
            if (!particle.destroyed) {
                particle.opacity.value = Utils_1.NumberUtils.clamp(particle.opacity.value, minValue, maxValue);
            }
        }
    }
    updateSize(delta) {
        var _a;
        const container = this.container;
        const particle = this.particle;
        const sizeOpt = particle.options.size;
        const sizeAnim = sizeOpt.animation;
        const sizeVelocity = ((_a = particle.size.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
        const minValue = Utils_1.NumberUtils.getRangeMin(sizeOpt.value) * container.retina.pixelRatio;
        const maxValue = Utils_1.NumberUtils.getRangeMax(sizeOpt.value) * container.retina.pixelRatio;
        if (!particle.destroyed && sizeAnim.enable && (sizeAnim.count <= 0 || particle.loops.size < sizeAnim.count)) {
            switch (particle.size.status) {
                case Enums_1.AnimationStatus.increasing:
                    if (particle.size.value >= maxValue) {
                        particle.size.status = Enums_1.AnimationStatus.decreasing;
                        particle.loops.size++;
                    }
                    else {
                        particle.size.value += sizeVelocity;
                    }
                    break;
                case Enums_1.AnimationStatus.decreasing:
                    if (particle.size.value <= minValue) {
                        particle.size.status = Enums_1.AnimationStatus.increasing;
                        particle.loops.size++;
                    }
                    else {
                        particle.size.value -= sizeVelocity;
                    }
            }
            checkDestroy(particle, sizeAnim.destroy, particle.size.value, minValue, maxValue);
            if (!particle.destroyed) {
                particle.size.value = Utils_1.NumberUtils.clamp(particle.size.value, minValue, maxValue);
            }
        }
    }
    updateAngle(delta) {
        var _a;
        const particle = this.particle;
        const rotate = particle.options.rotate;
        const rotateAnimation = rotate.animation;
        const speed = ((_a = particle.rotate.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor;
        const max = 2 * Math.PI;
        if (rotateAnimation.enable) {
            switch (particle.rotate.status) {
                case Enums_1.AnimationStatus.increasing:
                    particle.rotate.value += speed;
                    if (particle.rotate.value > max) {
                        particle.rotate.value -= max;
                    }
                    break;
                case Enums_1.AnimationStatus.decreasing:
                default:
                    particle.rotate.value -= speed;
                    if (particle.rotate.value < 0) {
                        particle.rotate.value += max;
                    }
                    break;
            }
        }
    }
    updateColor(delta) {
        var _a, _b, _c;
        const particle = this.particle;
        const animationOptions = particle.options.color.animation;
        if (((_a = particle.color) === null || _a === void 0 ? void 0 : _a.h) !== undefined) {
            this.updateColorValue(particle, delta, particle.color.h, animationOptions.h, 360, false);
        }
        if (((_b = particle.color) === null || _b === void 0 ? void 0 : _b.s) !== undefined) {
            this.updateColorValue(particle, delta, particle.color.s, animationOptions.s, 100, true);
        }
        if (((_c = particle.color) === null || _c === void 0 ? void 0 : _c.l) !== undefined) {
            this.updateColorValue(particle, delta, particle.color.l, animationOptions.l, 100, true);
        }
    }
    updateStrokeColor(delta) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const particle = this.particle;
        if (!particle.stroke.color) {
            return;
        }
        const animationOptions = particle.stroke.color.animation;
        const valueAnimations = animationOptions;
        if (valueAnimations.enable !== undefined) {
            const hue = (_b = (_a = particle.strokeColor) === null || _a === void 0 ? void 0 : _a.h) !== null && _b !== void 0 ? _b : (_c = particle.color) === null || _c === void 0 ? void 0 : _c.h;
            if (hue) {
                this.updateColorValue(particle, delta, hue, valueAnimations, 360, false);
            }
        }
        else {
            const hslAnimations = animationOptions;
            const h = (_e = (_d = particle.strokeColor) === null || _d === void 0 ? void 0 : _d.h) !== null && _e !== void 0 ? _e : (_f = particle.color) === null || _f === void 0 ? void 0 : _f.h;
            if (h) {
                this.updateColorValue(particle, delta, h, hslAnimations.h, 360, false);
            }
            const s = (_h = (_g = particle.strokeColor) === null || _g === void 0 ? void 0 : _g.s) !== null && _h !== void 0 ? _h : (_j = particle.color) === null || _j === void 0 ? void 0 : _j.s;
            if (s) {
                this.updateColorValue(particle, delta, s, hslAnimations.s, 100, true);
            }
            const l = (_l = (_k = particle.strokeColor) === null || _k === void 0 ? void 0 : _k.l) !== null && _l !== void 0 ? _l : (_m = particle.color) === null || _m === void 0 ? void 0 : _m.l;
            if (l) {
                this.updateColorValue(particle, delta, l, hslAnimations.l, 100, true);
            }
        }
    }
    updateColorValue(particle, delta, value, valueAnimation, max, decrease) {
        var _a;
        const colorValue = value;
        if (!colorValue || !valueAnimation.enable) {
            return;
        }
        const offset = Utils_1.NumberUtils.randomInRange(valueAnimation.offset);
        const velocity = ((_a = value.velocity) !== null && _a !== void 0 ? _a : 0) * delta.factor + offset * 3.6;
        if (!decrease || colorValue.status === Enums_1.AnimationStatus.increasing) {
            colorValue.value += velocity;
            if (decrease && colorValue.value > max) {
                colorValue.status = Enums_1.AnimationStatus.decreasing;
                colorValue.value -= colorValue.value % max;
            }
        }
        else {
            colorValue.value -= velocity;
            if (colorValue.value < 0) {
                colorValue.status = Enums_1.AnimationStatus.increasing;
                colorValue.value += colorValue.value;
            }
        }
        if (colorValue.value > max) {
            colorValue.value %= max;
        }
    }
    updateOutModes(delta) {
        var _a, _b, _c, _d;
        const outModes = this.particle.options.move.outModes;
        this.updateOutMode(delta, (_a = outModes.bottom) !== null && _a !== void 0 ? _a : outModes.default, OutModeDirection_1.OutModeDirection.bottom);
        this.updateOutMode(delta, (_b = outModes.left) !== null && _b !== void 0 ? _b : outModes.default, OutModeDirection_1.OutModeDirection.left);
        this.updateOutMode(delta, (_c = outModes.right) !== null && _c !== void 0 ? _c : outModes.default, OutModeDirection_1.OutModeDirection.right);
        this.updateOutMode(delta, (_d = outModes.top) !== null && _d !== void 0 ? _d : outModes.default, OutModeDirection_1.OutModeDirection.top);
    }
    updateOutMode(delta, outMode, direction) {
        const container = this.container;
        const particle = this.particle;
        switch (outMode) {
            case Enums_1.OutMode.bounce:
            case Enums_1.OutMode.bounceVertical:
            case Enums_1.OutMode.bounceHorizontal:
            case "bounceVertical":
            case "bounceHorizontal":
            case Enums_1.OutMode.split:
                this.updateBounce(delta, direction, outMode);
                break;
            case Enums_1.OutMode.destroy:
                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                    container.particles.remove(particle, true);
                }
                break;
            case Enums_1.OutMode.out:
                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                    this.fixOutOfCanvasPosition(direction);
                }
                break;
            case Enums_1.OutMode.none:
                this.bounceNone(direction);
                break;
        }
    }
    fixOutOfCanvasPosition(direction) {
        const container = this.container;
        const particle = this.particle;
        const wrap = particle.options.move.warp;
        const canvasSize = container.canvas.size;
        const newPos = {
            bottom: canvasSize.height + particle.getRadius() - particle.offset.y,
            left: -particle.getRadius() - particle.offset.x,
            right: canvasSize.width + particle.getRadius() + particle.offset.x,
            top: -particle.getRadius() - particle.offset.y,
        };
        const sizeValue = particle.getRadius();
        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);
        if (direction === OutModeDirection_1.OutModeDirection.right && nextBounds.left > canvasSize.width - particle.offset.x) {
            particle.position.x = newPos.left;
            if (!wrap) {
                particle.position.y = Math.random() * canvasSize.height;
            }
        }
        else if (direction === OutModeDirection_1.OutModeDirection.left && nextBounds.right < -particle.offset.x) {
            particle.position.x = newPos.right;
            if (!wrap) {
                particle.position.y = Math.random() * canvasSize.height;
            }
        }
        if (direction === OutModeDirection_1.OutModeDirection.bottom && nextBounds.top > canvasSize.height - particle.offset.y) {
            if (!wrap) {
                particle.position.x = Math.random() * canvasSize.width;
            }
            particle.position.y = newPos.top;
        }
        else if (direction === OutModeDirection_1.OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {
            if (!wrap) {
                particle.position.x = Math.random() * canvasSize.width;
            }
            particle.position.y = newPos.bottom;
        }
    }
    updateBounce(delta, direction, outMode) {
        const container = this.container;
        const particle = this.particle;
        let handled = false;
        for (const [, plugin] of container.plugins) {
            if (plugin.particleBounce !== undefined) {
                handled = plugin.particleBounce(particle, delta, direction);
            }
            if (handled) {
                break;
            }
        }
        if (handled) {
            return;
        }
        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;
        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });
        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });
    }
    bounceNone(direction) {
        const particle = this.particle;
        if (particle.options.move.distance) {
            return;
        }
        const gravityOptions = particle.options.move.gravity;
        const container = this.container;
        if (!gravityOptions.enable) {
            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.getRadius(), direction)) {
                container.particles.remove(particle);
            }
        }
        else {
            const position = particle.position;
            if ((gravityOptions.acceleration >= 0 &&
                position.y > container.canvas.size.height &&
                direction === OutModeDirection_1.OutModeDirection.bottom) ||
                (gravityOptions.acceleration < 0 && position.y < 0 && direction === OutModeDirection_1.OutModeDirection.top)) {
                container.particles.remove(particle);
            }
        }
    }
}
exports.Updater = Updater;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particle/Vector.js":
/*!***************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particle/Vector.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Vector = void 0;
class Vector {
    constructor(x, y) {
        let defX, defY;
        if (y === undefined) {
            if (typeof x === "number") {
                throw new Error("tsParticles - Vector not initialized correctly");
            }
            const coords = x;
            [defX, defY] = [coords.x, coords.y];
        }
        else {
            [defX, defY] = [x, y];
        }
        this.x = defX;
        this.y = defY;
    }
    static clone(source) {
        return Vector.create(source.x, source.y);
    }
    static create(x, y) {
        return new Vector(x, y);
    }
    get angle() {
        return Math.atan2(this.y, this.x);
    }
    set angle(angle) {
        this.updateFromAngle(angle, this.length);
    }
    get length() {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
    }
    set length(length) {
        this.updateFromAngle(this.angle, length);
    }
    add(v) {
        return Vector.create(this.x + v.x, this.y + v.y);
    }
    addTo(v) {
        this.x += v.x;
        this.y += v.y;
    }
    sub(v) {
        return Vector.create(this.x - v.x, this.y - v.y);
    }
    subFrom(v) {
        this.x -= v.x;
        this.y -= v.y;
    }
    mult(n) {
        return Vector.create(this.x * n, this.y * n);
    }
    multTo(n) {
        this.x *= n;
        this.y *= n;
    }
    div(n) {
        return Vector.create(this.x / n, this.y / n);
    }
    divTo(n) {
        this.x /= n;
        this.y /= n;
    }
    distanceTo(v) {
        return this.sub(v).length;
    }
    getLengthSq() {
        return Math.pow(this.x, 2) + Math.pow(this.y, 2);
    }
    distanceToSq(v) {
        return this.sub(v).getLengthSq();
    }
    manhattanDistanceTo(v) {
        return Math.abs(v.x - this.x) + Math.abs(v.y - this.y);
    }
    copy() {
        return Vector.clone(this);
    }
    setTo(velocity) {
        this.x = velocity.x;
        this.y = velocity.y;
    }
    rotate(angle) {
        return Vector.create(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
    }
    updateFromAngle(angle, length) {
        this.x = Math.cos(angle) * length;
        this.y = Math.sin(angle) * length;
    }
}
exports.Vector = Vector;
Vector.origin = Vector.create(0, 0);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Particles.js":
/*!*********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Particles.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Particles = void 0;
const Particle_1 = __webpack_require__(/*! ./Particle */ "./node_modules/tsparticles/dist/Core/Particle.js");
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const InteractionManager_1 = __webpack_require__(/*! ./Particle/InteractionManager */ "./node_modules/tsparticles/dist/Core/Particle/InteractionManager.js");
const ParticlesOptions_1 = __webpack_require__(/*! ../Options/Classes/Particles/ParticlesOptions */ "./node_modules/tsparticles/dist/Options/Classes/Particles/ParticlesOptions.js");
class Particles {
    constructor(container) {
        this.container = container;
        this.nextId = 0;
        this.array = [];
        this.limit = 0;
        this.linksFreq = new Map();
        this.trianglesFreq = new Map();
        this.interactionManager = new InteractionManager_1.InteractionManager(container);
        const canvasSize = this.container.canvas.size;
        this.linksColors = new Map();
        this.quadTree = new Utils_1.QuadTree(new Utils_1.Rectangle(-canvasSize.width / 4, -canvasSize.height / 4, (canvasSize.width * 3) / 2, (canvasSize.height * 3) / 2), 4);
    }
    get count() {
        return this.array.length;
    }
    init() {
        const container = this.container;
        const options = container.actualOptions;
        this.linksFreq = new Map();
        this.trianglesFreq = new Map();
        let handled = false;
        for (const particle of options.manualParticles) {
            const pos = particle.position
                ? {
                    x: (particle.position.x * container.canvas.size.width) / 100,
                    y: (particle.position.y * container.canvas.size.height) / 100,
                }
                : undefined;
            this.addParticle(pos, particle.options);
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.particlesInitialization !== undefined) {
                handled = plugin.particlesInitialization();
            }
            if (handled) {
                break;
            }
        }
        if (!handled) {
            for (let i = this.count; i < options.particles.number.value; i++) {
                this.addParticle();
            }
        }
        if (options.infection.enable) {
            for (let i = 0; i < options.infection.infections; i++) {
                const notInfected = this.array.filter((p) => p.infecter.infectionStage === undefined);
                const infected = Utils_1.Utils.itemFromArray(notInfected);
                infected.infecter.startInfection(0);
            }
        }
        this.interactionManager.init();
        container.pathGenerator.init();
    }
    redraw() {
        this.clear();
        this.init();
        this.draw({ value: 0, factor: 0 });
    }
    removeAt(index, quantity, override) {
        if (index >= 0 && index <= this.count) {
            for (const particle of this.array.splice(index, quantity !== null && quantity !== void 0 ? quantity : 1)) {
                particle.destroy(override);
            }
        }
    }
    remove(particle, override) {
        this.removeAt(this.array.indexOf(particle), undefined, override);
    }
    update(delta) {
        const container = this.container;
        const particlesToDelete = [];
        container.pathGenerator.update();
        for (const [, plugin] of container.plugins) {
            if (plugin.update !== undefined) {
                plugin.update(delta);
            }
        }
        for (const particle of this.array) {
            const resizeFactor = this.container.canvas.resizeFactor;
            if (resizeFactor) {
                particle.position.x *= resizeFactor.width;
                particle.position.y *= resizeFactor.height;
            }
            particle.move(delta);
            if (particle.destroyed) {
                particlesToDelete.push(particle);
                continue;
            }
            this.quadTree.insert(new Utils_1.Point(particle.getPosition(), particle));
        }
        for (const particle of particlesToDelete) {
            this.remove(particle);
        }
        this.interactionManager.externalInteract(delta);
        for (const particle of this.container.particles.array) {
            particle.update(delta);
            if (!particle.destroyed && !particle.spawning) {
                this.interactionManager.particlesInteract(particle, delta);
            }
        }
        delete container.canvas.resizeFactor;
    }
    draw(delta) {
        const container = this.container;
        container.canvas.clear();
        const canvasSize = this.container.canvas.size;
        this.quadTree = new Utils_1.QuadTree(new Utils_1.Rectangle(-canvasSize.width / 4, -canvasSize.height / 4, (canvasSize.width * 3) / 2, (canvasSize.height * 3) / 2), 4);
        this.update(delta);
        for (const [, plugin] of container.plugins) {
            container.canvas.drawPlugin(plugin, delta);
        }
        for (const p of this.array) {
            p.draw(delta);
        }
    }
    clear() {
        this.array = [];
    }
    push(nb, mouse, overrideOptions) {
        const container = this.container;
        const options = container.actualOptions;
        const limit = options.particles.number.limit * container.density;
        this.pushing = true;
        if (limit > 0) {
            const countToRemove = this.count + nb - limit;
            if (countToRemove > 0) {
                this.removeQuantity(countToRemove);
            }
        }
        for (let i = 0; i < nb; i++) {
            this.addParticle(mouse === null || mouse === void 0 ? void 0 : mouse.position, overrideOptions);
        }
        this.pushing = false;
    }
    addParticle(position, overrideOptions) {
        return this.pushParticle(position, overrideOptions);
    }
    addSplitParticle(parent) {
        const splitOptions = parent.options.destroy.split;
        const options = new ParticlesOptions_1.ParticlesOptions();
        options.load(parent.options);
        const factor = Utils_1.NumberUtils.getRangeValue(splitOptions.factor.value);
        options.color.load({
            value: {
                hsl: parent.getFillColor(),
            },
        });
        if (typeof options.size.value === "number") {
            options.size.value /= factor;
        }
        else {
            options.size.value.min /= factor;
            options.size.value.max /= factor;
        }
        options.load(splitOptions.particles);
        const offset = Utils_1.NumberUtils.setRangeValue(-parent.size.value, parent.size.value);
        const position = {
            x: parent.position.x + Utils_1.NumberUtils.randomInRange(offset),
            y: parent.position.y + Utils_1.NumberUtils.randomInRange(offset),
        };
        return this.pushParticle(position, options, (particle) => {
            if (particle.size.value < 0.5) {
                return false;
            }
            particle.velocity.length = Utils_1.NumberUtils.randomInRange(Utils_1.NumberUtils.setRangeValue(parent.velocity.length, particle.velocity.length));
            particle.splitCount = parent.splitCount + 1;
            particle.unbreakable = true;
            setTimeout(() => {
                particle.unbreakable = false;
            }, 500);
            return true;
        });
    }
    removeQuantity(quantity) {
        this.removeAt(0, quantity);
    }
    getLinkFrequency(p1, p2) {
        const key = `${Math.min(p1.id, p2.id)}_${Math.max(p1.id, p2.id)}`;
        let res = this.linksFreq.get(key);
        if (res === undefined) {
            res = Math.random();
            this.linksFreq.set(key, res);
        }
        return res;
    }
    getTriangleFrequency(p1, p2, p3) {
        let [id1, id2, id3] = [p1.id, p2.id, p3.id];
        if (id1 > id2) {
            [id2, id1] = [id1, id2];
        }
        if (id2 > id3) {
            [id3, id2] = [id2, id3];
        }
        if (id1 > id3) {
            [id3, id1] = [id1, id3];
        }
        const key = `${id1}_${id2}_${id3}`;
        let res = this.trianglesFreq.get(key);
        if (res === undefined) {
            res = Math.random();
            this.trianglesFreq.set(key, res);
        }
        return res;
    }
    setDensity() {
        const options = this.container.actualOptions;
        this.applyDensity(options.particles);
    }
    applyDensity(options) {
        var _a;
        if (!((_a = options.number.density) === null || _a === void 0 ? void 0 : _a.enable)) {
            return;
        }
        const numberOptions = options.number;
        const densityFactor = this.initDensityFactor(numberOptions.density);
        const optParticlesNumber = numberOptions.value;
        const optParticlesLimit = numberOptions.limit > 0 ? numberOptions.limit : optParticlesNumber;
        const particlesNumber = Math.min(optParticlesNumber, optParticlesLimit) * densityFactor;
        const particlesCount = this.count;
        this.limit = numberOptions.limit * densityFactor;
        if (particlesCount < particlesNumber) {
            this.push(Math.abs(particlesNumber - particlesCount), undefined, options);
        }
        else if (particlesCount > particlesNumber) {
            this.removeQuantity(particlesCount - particlesNumber);
        }
    }
    initDensityFactor(densityOptions) {
        const container = this.container;
        if (!container.canvas.element || !densityOptions.enable) {
            return 1;
        }
        const canvas = container.canvas.element;
        const pxRatio = container.retina.pixelRatio;
        return (canvas.width * canvas.height) / (densityOptions.factor * pxRatio * pxRatio * densityOptions.area);
    }
    pushParticle(position, overrideOptions, initializer) {
        try {
            const particle = new Particle_1.Particle(this.nextId, this.container, position, overrideOptions);
            let canAdd = true;
            if (initializer) {
                canAdd = initializer(particle);
            }
            if (!canAdd) {
                return;
            }
            this.array.push(particle);
            this.nextId++;
            return particle;
        }
        catch (e) {
            console.warn(`error adding particle: ${e}`);
            return;
        }
    }
}
exports.Particles = Particles;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Core/Retina.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Core/Retina.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Retina = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Retina {
    constructor(container) {
        this.container = container;
    }
    init() {
        const container = this.container;
        const options = container.actualOptions;
        this.pixelRatio = !options.detectRetina || Utils_1.Utils.isSsr() ? 1 : window.devicePixelRatio;
        const motionOptions = this.container.actualOptions.motion;
        if (motionOptions && (motionOptions.disable || motionOptions.reduce.value)) {
            if (Utils_1.Utils.isSsr() || typeof matchMedia === "undefined" || !matchMedia) {
                this.reduceFactor = 1;
            }
            else {
                const mediaQuery = matchMedia("(prefers-reduced-motion: reduce)");
                if (mediaQuery) {
                    this.handleMotionChange(mediaQuery);
                    const handleChange = () => {
                        this.handleMotionChange(mediaQuery);
                        container.refresh().catch(() => {
                        });
                    };
                    if (mediaQuery.addEventListener !== undefined) {
                        mediaQuery.addEventListener("change", handleChange);
                    }
                    else if (mediaQuery.addListener !== undefined) {
                        mediaQuery.addListener(handleChange);
                    }
                }
            }
        }
        else {
            this.reduceFactor = 1;
        }
        const ratio = this.pixelRatio;
        if (container.canvas.element) {
            const element = container.canvas.element;
            container.canvas.size.width = element.offsetWidth * ratio;
            container.canvas.size.height = element.offsetHeight * ratio;
        }
        const particles = options.particles;
        this.linksDistance = particles.links.distance * ratio;
        this.linksWidth = particles.links.width * ratio;
        this.sizeAnimationSpeed = particles.size.animation.speed * ratio;
        const modes = options.interactivity.modes;
        this.connectModeDistance = modes.connect.distance * ratio;
        this.connectModeRadius = modes.connect.radius * ratio;
        this.grabModeDistance = modes.grab.distance * ratio;
        this.repulseModeDistance = modes.repulse.distance * ratio;
        this.bounceModeDistance = modes.bounce.distance * ratio;
        this.attractModeDistance = modes.attract.distance * ratio;
        this.slowModeRadius = modes.slow.radius * ratio;
        this.bubbleModeDistance = modes.bubble.distance * ratio;
        if (modes.bubble.size) {
            this.bubbleModeSize = modes.bubble.size * ratio;
        }
    }
    initParticle(particle) {
        const particlesOptions = particle.options;
        const ratio = this.pixelRatio;
        particle.linksDistance = particlesOptions.links.distance * ratio;
        particle.linksWidth = particlesOptions.links.width * ratio;
        particle.moveDrift = Utils_1.NumberUtils.getRangeValue(particlesOptions.move.drift) * ratio;
        particle.moveSpeed = Utils_1.NumberUtils.getRangeValue(particlesOptions.move.speed) * ratio;
        particle.sizeAnimationSpeed = particlesOptions.size.animation.speed * ratio;
        particle.maxDistance = particlesOptions.move.distance * ratio;
    }
    handleMotionChange(mediaQuery) {
        const options = this.container.actualOptions;
        if (mediaQuery.matches) {
            const motion = options.motion;
            this.reduceFactor = motion.disable ? 0 : motion.reduce.value ? 1 / motion.reduce.factor : 1;
        }
        else {
            this.reduceFactor = 1;
        }
    }
}
exports.Retina = Retina;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/AnimationStatus.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/AnimationStatus.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationStatus = void 0;
var AnimationStatus;
(function (AnimationStatus) {
    AnimationStatus[AnimationStatus["increasing"] = 0] = "increasing";
    AnimationStatus[AnimationStatus["decreasing"] = 1] = "decreasing";
})(AnimationStatus = exports.AnimationStatus || (exports.AnimationStatus = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/MoveDirection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/MoveDirection.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveDirection = void 0;
var MoveDirection;
(function (MoveDirection) {
    MoveDirection["bottom"] = "bottom";
    MoveDirection["bottomLeft"] = "bottom-left";
    MoveDirection["bottomRight"] = "bottom-right";
    MoveDirection["left"] = "left";
    MoveDirection["none"] = "none";
    MoveDirection["right"] = "right";
    MoveDirection["top"] = "top";
    MoveDirection["topLeft"] = "top-left";
    MoveDirection["topRight"] = "top-right";
})(MoveDirection = exports.MoveDirection || (exports.MoveDirection = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutModeDirection = void 0;
var OutModeDirection;
(function (OutModeDirection) {
    OutModeDirection["bottom"] = "bottom";
    OutModeDirection["left"] = "left";
    OutModeDirection["right"] = "right";
    OutModeDirection["top"] = "top";
})(OutModeDirection = exports.OutModeDirection || (exports.OutModeDirection = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/RotateDirection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/RotateDirection.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateDirection = void 0;
var RotateDirection;
(function (RotateDirection) {
    RotateDirection["clockwise"] = "clockwise";
    RotateDirection["counterClockwise"] = "counter-clockwise";
    RotateDirection["random"] = "random";
})(RotateDirection = exports.RotateDirection || (exports.RotateDirection = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Directions/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Directions/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./MoveDirection */ "./node_modules/tsparticles/dist/Enums/Directions/MoveDirection.js"), exports);
__exportStar(__webpack_require__(/*! ./RotateDirection */ "./node_modules/tsparticles/dist/Enums/Directions/RotateDirection.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/InteractivityDetect.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/InteractivityDetect.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractivityDetect = void 0;
var InteractivityDetect;
(function (InteractivityDetect) {
    InteractivityDetect["canvas"] = "canvas";
    InteractivityDetect["parent"] = "parent";
    InteractivityDetect["window"] = "window";
})(InteractivityDetect = exports.InteractivityDetect || (exports.InteractivityDetect = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClickMode = void 0;
var ClickMode;
(function (ClickMode) {
    ClickMode["attract"] = "attract";
    ClickMode["bubble"] = "bubble";
    ClickMode["push"] = "push";
    ClickMode["remove"] = "remove";
    ClickMode["repulse"] = "repulse";
    ClickMode["pause"] = "pause";
    ClickMode["trail"] = "trail";
})(ClickMode = exports.ClickMode || (exports.ClickMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/CollisionMode.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/CollisionMode.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CollisionMode = void 0;
var CollisionMode;
(function (CollisionMode) {
    CollisionMode["absorb"] = "absorb";
    CollisionMode["bounce"] = "bounce";
    CollisionMode["destroy"] = "destroy";
})(CollisionMode = exports.CollisionMode || (exports.CollisionMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/DestroyMode.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/DestroyMode.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DestroyMode = void 0;
var DestroyMode;
(function (DestroyMode) {
    DestroyMode["none"] = "none";
    DestroyMode["split"] = "split";
})(DestroyMode = exports.DestroyMode || (exports.DestroyMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/DivMode.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/DivMode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DivMode = void 0;
var DivMode;
(function (DivMode) {
    DivMode["bounce"] = "bounce";
    DivMode["bubble"] = "bubble";
    DivMode["repulse"] = "repulse";
})(DivMode = exports.DivMode || (exports.DivMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverMode = void 0;
var HoverMode;
(function (HoverMode) {
    HoverMode["attract"] = "attract";
    HoverMode["bounce"] = "bounce";
    HoverMode["bubble"] = "bubble";
    HoverMode["connect"] = "connect";
    HoverMode["grab"] = "grab";
    HoverMode["light"] = "light";
    HoverMode["repulse"] = "repulse";
    HoverMode["slow"] = "slow";
    HoverMode["trail"] = "trail";
})(HoverMode = exports.HoverMode || (exports.HoverMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/OutMode.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/OutMode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutMode = void 0;
var OutMode;
(function (OutMode) {
    OutMode["bounce"] = "bounce";
    OutMode["bounceHorizontal"] = "bounce-horizontal";
    OutMode["bounceVertical"] = "bounce-vertical";
    OutMode["none"] = "none";
    OutMode["out"] = "out";
    OutMode["destroy"] = "destroy";
    OutMode["split"] = "split";
})(OutMode = exports.OutMode || (exports.OutMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/SizeMode.js":
/*!***************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/SizeMode.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SizeMode = void 0;
var SizeMode;
(function (SizeMode) {
    SizeMode["precise"] = "precise";
    SizeMode["percent"] = "percent";
})(SizeMode = exports.SizeMode || (exports.SizeMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/ThemeMode.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/ThemeMode.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ThemeMode = void 0;
var ThemeMode;
(function (ThemeMode) {
    ThemeMode["any"] = "any";
    ThemeMode["dark"] = "dark";
    ThemeMode["light"] = "light";
})(ThemeMode = exports.ThemeMode || (exports.ThemeMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Modes/index.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Modes/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./ClickMode */ "./node_modules/tsparticles/dist/Enums/Modes/ClickMode.js"), exports);
__exportStar(__webpack_require__(/*! ./DestroyMode */ "./node_modules/tsparticles/dist/Enums/Modes/DestroyMode.js"), exports);
__exportStar(__webpack_require__(/*! ./DivMode */ "./node_modules/tsparticles/dist/Enums/Modes/DivMode.js"), exports);
__exportStar(__webpack_require__(/*! ./HoverMode */ "./node_modules/tsparticles/dist/Enums/Modes/HoverMode.js"), exports);
__exportStar(__webpack_require__(/*! ./CollisionMode */ "./node_modules/tsparticles/dist/Enums/Modes/CollisionMode.js"), exports);
__exportStar(__webpack_require__(/*! ./OutMode */ "./node_modules/tsparticles/dist/Enums/Modes/OutMode.js"), exports);
__exportStar(__webpack_require__(/*! ./SizeMode */ "./node_modules/tsparticles/dist/Enums/Modes/SizeMode.js"), exports);
__exportStar(__webpack_require__(/*! ./ThemeMode */ "./node_modules/tsparticles/dist/Enums/Modes/ThemeMode.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/MoveDirection.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/MoveDirection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/OutMode.js":
/*!********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/OutMode.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/PolygonMaskInlineArrangement.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/PolygonMaskInlineArrangement.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskInlineArrangement = void 0;
const Enums_1 = __webpack_require__(/*! ../Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
Object.defineProperty(exports, "PolygonMaskInlineArrangement", { enumerable: true, get: function () { return Enums_1.InlineArrangement; } });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/PolygonMaskMoveType.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/PolygonMaskMoveType.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskMoveType = void 0;
const Enums_1 = __webpack_require__(/*! ../Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
Object.defineProperty(exports, "PolygonMaskMoveType", { enumerable: true, get: function () { return Enums_1.MoveType; } });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/PolygonMaskType.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/PolygonMaskType.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskType = void 0;
const Enums_1 = __webpack_require__(/*! ../Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
Object.defineProperty(exports, "PolygonMaskType", { enumerable: true, get: function () { return Enums_1.Type; } });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/ProcessBubbleType.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/ProcessBubbleType.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/RotateDirection.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/RotateDirection.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/ShapeType.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/ShapeType.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/DestroyType.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/DestroyType.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DestroyType = void 0;
var DestroyType;
(function (DestroyType) {
    DestroyType["none"] = "none";
    DestroyType["max"] = "max";
    DestroyType["min"] = "min";
})(DestroyType = exports.DestroyType || (exports.DestroyType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/DivType.js":
/*!**************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/DivType.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DivType = void 0;
var DivType;
(function (DivType) {
    DivType["circle"] = "circle";
    DivType["rectangle"] = "rectangle";
})(DivType = exports.DivType || (exports.DivType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/ProcessBubbleType.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/ProcessBubbleType.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessBubbleType = void 0;
var ProcessBubbleType;
(function (ProcessBubbleType) {
    ProcessBubbleType["color"] = "color";
    ProcessBubbleType["opacity"] = "opacity";
    ProcessBubbleType["size"] = "size";
})(ProcessBubbleType = exports.ProcessBubbleType || (exports.ProcessBubbleType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/ShapeType.js":
/*!****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/ShapeType.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeType = void 0;
var ShapeType;
(function (ShapeType) {
    ShapeType["char"] = "char";
    ShapeType["character"] = "character";
    ShapeType["circle"] = "circle";
    ShapeType["edge"] = "edge";
    ShapeType["image"] = "image";
    ShapeType["images"] = "images";
    ShapeType["line"] = "line";
    ShapeType["polygon"] = "polygon";
    ShapeType["square"] = "square";
    ShapeType["star"] = "star";
    ShapeType["triangle"] = "triangle";
})(ShapeType = exports.ShapeType || (exports.ShapeType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/StartValueType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/StartValueType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StartValueType = void 0;
var StartValueType;
(function (StartValueType) {
    StartValueType["max"] = "max";
    StartValueType["min"] = "min";
    StartValueType["random"] = "random";
})(StartValueType = exports.StartValueType || (exports.StartValueType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/Types/index.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/Types/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./DestroyType */ "./node_modules/tsparticles/dist/Enums/Types/DestroyType.js"), exports);
__exportStar(__webpack_require__(/*! ./ProcessBubbleType */ "./node_modules/tsparticles/dist/Enums/Types/ProcessBubbleType.js"), exports);
__exportStar(__webpack_require__(/*! ./ShapeType */ "./node_modules/tsparticles/dist/Enums/Types/ShapeType.js"), exports);
__exportStar(__webpack_require__(/*! ./StartValueType */ "./node_modules/tsparticles/dist/Enums/Types/StartValueType.js"), exports);
__exportStar(__webpack_require__(/*! ./DivType */ "./node_modules/tsparticles/dist/Enums/Types/DivType.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Enums/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Enums/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js"), exports);
__exportStar(__webpack_require__(/*! ./AnimationStatus */ "./node_modules/tsparticles/dist/Enums/AnimationStatus.js"), exports);
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js"), exports);
__exportStar(__webpack_require__(/*! ./InteractivityDetect */ "./node_modules/tsparticles/dist/Enums/InteractivityDetect.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Attractor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Attractor.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attractor = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Attractor {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.actualOptions;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        if (!((events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return Utils_1.Utils.isInArray(Enums_1.HoverMode.attract, hoverMode) || Utils_1.Utils.isInArray(Enums_1.ClickMode.attract, clickMode);
    }
    reset() {
    }
    interact() {
        const container = this.container;
        const options = container.actualOptions;
        const mouseMoveStatus = container.interactivity.status === Utils_1.Constants.mouseMoveEvent;
        const events = options.interactivity.events;
        const hoverEnabled = events.onHover.enable;
        const hoverMode = events.onHover.mode;
        const clickEnabled = events.onClick.enable;
        const clickMode = events.onClick.mode;
        if (mouseMoveStatus && hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.attract, hoverMode)) {
            this.hoverAttract();
        }
        else if (clickEnabled && Utils_1.Utils.isInArray(Enums_1.ClickMode.attract, clickMode)) {
            this.clickAttract();
        }
    }
    hoverAttract() {
        const container = this.container;
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const attractRadius = container.retina.attractModeDistance;
        this.processAttract(mousePos, attractRadius, new Utils_1.Circle(mousePos.x, mousePos.y, attractRadius));
    }
    processAttract(position, attractRadius, area) {
        const container = this.container;
        const query = container.particles.quadTree.query(area);
        for (const particle of query) {
            const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(particle.position, position);
            const normVec = {
                x: dx / distance,
                y: dy / distance,
            };
            const velocity = container.actualOptions.interactivity.modes.attract.speed;
            const attractFactor = Utils_1.NumberUtils.clamp((1 - Math.pow(distance / attractRadius, 2)) * velocity, 0, 50);
            particle.position.x -= normVec.x * attractFactor;
            particle.position.y -= normVec.y * attractFactor;
        }
    }
    clickAttract() {
        const container = this.container;
        if (!container.attract.finish) {
            if (!container.attract.count) {
                container.attract.count = 0;
            }
            container.attract.count++;
            if (container.attract.count === container.particles.count) {
                container.attract.finish = true;
            }
        }
        if (container.attract.clicking) {
            const mousePos = container.interactivity.mouse.clickPosition;
            if (!mousePos) {
                return;
            }
            const attractRadius = container.retina.attractModeDistance;
            this.processAttract(mousePos, attractRadius, new Utils_1.Circle(mousePos.x, mousePos.y, attractRadius));
        }
        else if (container.attract.clicking === false) {
            container.attract.particles = [];
        }
        return;
    }
}
exports.Attractor = Attractor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Bouncer.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Bouncer.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bouncer = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Vector_1 = __webpack_require__(/*! ../../Core/Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js");
class Bouncer {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.actualOptions;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        const divs = events.onDiv;
        return ((mouse.position && events.onHover.enable && Utils_1.Utils.isInArray(Enums_1.HoverMode.bounce, events.onHover.mode)) ||
            Utils_1.Utils.isDivModeEnabled(Enums_1.DivMode.bounce, divs));
    }
    interact() {
        const container = this.container;
        const options = container.actualOptions;
        const events = options.interactivity.events;
        const mouseMoveStatus = container.interactivity.status === Utils_1.Constants.mouseMoveEvent;
        const hoverEnabled = events.onHover.enable;
        const hoverMode = events.onHover.mode;
        const divs = events.onDiv;
        if (mouseMoveStatus && hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.bounce, hoverMode)) {
            this.processMouseBounce();
        }
        else {
            Utils_1.Utils.divModeExecute(Enums_1.DivMode.bounce, divs, (selector, div) => this.singleSelectorBounce(selector, div));
        }
    }
    reset() {
    }
    processMouseBounce() {
        const container = this.container;
        const pxRatio = container.retina.pixelRatio;
        const tolerance = 10 * pxRatio;
        const mousePos = container.interactivity.mouse.position;
        const radius = container.retina.bounceModeDistance;
        if (mousePos) {
            this.processBounce(mousePos, radius, new Utils_1.Circle(mousePos.x, mousePos.y, radius + tolerance));
        }
    }
    singleSelectorBounce(selector, div) {
        const container = this.container;
        const query = document.querySelectorAll(selector);
        if (!query.length) {
            return;
        }
        query.forEach((item) => {
            const elem = item;
            const pxRatio = container.retina.pixelRatio;
            const pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            };
            const radius = (elem.offsetWidth / 2) * pxRatio;
            const tolerance = 10 * pxRatio;
            const area = div.type === Enums_1.DivType.circle
                ? new Utils_1.Circle(pos.x, pos.y, radius + tolerance)
                : new Utils_1.Rectangle(elem.offsetLeft * pxRatio - tolerance, elem.offsetTop * pxRatio - tolerance, elem.offsetWidth * pxRatio + tolerance * 2, elem.offsetHeight * pxRatio + tolerance * 2);
            this.processBounce(pos, radius, area);
        });
    }
    processBounce(position, radius, area) {
        const query = this.container.particles.quadTree.query(area);
        for (const particle of query) {
            if (area instanceof Utils_1.Circle) {
                Utils_1.Utils.circleBounce(Utils_1.Utils.circleBounceDataFromParticle(particle), {
                    position,
                    radius,
                    mass: (Math.pow(radius, 2) * Math.PI) / 2,
                    velocity: Vector_1.Vector.create(0, 0),
                    factor: {
                        horizontal: 0,
                        vertical: 0,
                    },
                });
            }
            else if (area instanceof Utils_1.Rectangle) {
                Utils_1.Utils.rectBounce(particle, Utils_1.Utils.calculateBounds(position, radius));
            }
        }
    }
}
exports.Bouncer = Bouncer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Bubbler.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Bubbler.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bubbler = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
function calculateBubbleValue(particleValue, modeValue, optionsValue, ratio) {
    if (modeValue > optionsValue) {
        const size = particleValue + (modeValue - optionsValue) * ratio;
        return Utils_1.NumberUtils.clamp(size, particleValue, modeValue);
    }
    else if (modeValue < optionsValue) {
        const size = particleValue - (optionsValue - modeValue) * ratio;
        return Utils_1.NumberUtils.clamp(size, modeValue, particleValue);
    }
}
class Bubbler {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.actualOptions;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        const divs = events.onDiv;
        const divBubble = Utils_1.Utils.isDivModeEnabled(Enums_1.DivMode.bubble, divs);
        if (!(divBubble || (events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return (Utils_1.Utils.isInArray(Enums_1.HoverMode.bubble, hoverMode) || Utils_1.Utils.isInArray(Enums_1.ClickMode.bubble, clickMode) || divBubble);
    }
    reset(particle, force) {
        if (!particle.bubble.inRange || force) {
            delete particle.bubble.div;
            delete particle.bubble.opacity;
            delete particle.bubble.radius;
            delete particle.bubble.color;
        }
    }
    interact() {
        const options = this.container.actualOptions;
        const events = options.interactivity.events;
        const onHover = events.onHover;
        const onClick = events.onClick;
        const hoverEnabled = onHover.enable;
        const hoverMode = onHover.mode;
        const clickEnabled = onClick.enable;
        const clickMode = onClick.mode;
        const divs = events.onDiv;
        if (hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.bubble, hoverMode)) {
            this.hoverBubble();
        }
        else if (clickEnabled && Utils_1.Utils.isInArray(Enums_1.ClickMode.bubble, clickMode)) {
            this.clickBubble();
        }
        else {
            Utils_1.Utils.divModeExecute(Enums_1.DivMode.bubble, divs, (selector, div) => this.singleSelectorHover(selector, div));
        }
    }
    singleSelectorHover(selector, div) {
        const container = this.container;
        const selectors = document.querySelectorAll(selector);
        if (!selectors.length) {
            return;
        }
        selectors.forEach((item) => {
            const elem = item;
            const pxRatio = container.retina.pixelRatio;
            const pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            };
            const repulseRadius = (elem.offsetWidth / 2) * pxRatio;
            const area = div.type === Enums_1.DivType.circle
                ? new Utils_1.Circle(pos.x, pos.y, repulseRadius)
                : new Utils_1.Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio);
            const query = container.particles.quadTree.query(area);
            for (const particle of query) {
                if (!area.contains(particle.getPosition())) {
                    continue;
                }
                particle.bubble.inRange = true;
                const divs = container.actualOptions.interactivity.modes.bubble.divs;
                const divBubble = Utils_1.Utils.divMode(divs, elem);
                if (!particle.bubble.div || particle.bubble.div !== elem) {
                    this.reset(particle, true);
                    particle.bubble.div = elem;
                }
                this.hoverBubbleSize(particle, 1, divBubble);
                this.hoverBubbleOpacity(particle, 1, divBubble);
                this.hoverBubbleColor(particle, divBubble);
            }
        });
    }
    process(particle, distMouse, timeSpent, data) {
        const container = this.container;
        const bubbleParam = data.bubbleObj.optValue;
        if (bubbleParam === undefined) {
            return;
        }
        const options = container.actualOptions;
        const bubbleDuration = options.interactivity.modes.bubble.duration;
        const bubbleDistance = container.retina.bubbleModeDistance;
        const particlesParam = data.particlesObj.optValue;
        const pObjBubble = data.bubbleObj.value;
        const pObj = data.particlesObj.value || 0;
        const type = data.type;
        if (bubbleParam !== particlesParam) {
            if (!container.bubble.durationEnd) {
                if (distMouse <= bubbleDistance) {
                    const obj = pObjBubble !== null && pObjBubble !== void 0 ? pObjBubble : pObj;
                    if (obj !== bubbleParam) {
                        const value = pObj - (timeSpent * (pObj - bubbleParam)) / bubbleDuration;
                        if (type === Enums_1.ProcessBubbleType.size) {
                            particle.bubble.radius = value;
                        }
                        if (type === Enums_1.ProcessBubbleType.opacity) {
                            particle.bubble.opacity = value;
                        }
                    }
                }
                else {
                    if (type === Enums_1.ProcessBubbleType.size) {
                        delete particle.bubble.radius;
                    }
                    if (type === Enums_1.ProcessBubbleType.opacity) {
                        delete particle.bubble.opacity;
                    }
                }
            }
            else if (pObjBubble) {
                if (type === Enums_1.ProcessBubbleType.size) {
                    delete particle.bubble.radius;
                }
                if (type === Enums_1.ProcessBubbleType.opacity) {
                    delete particle.bubble.opacity;
                }
            }
        }
    }
    clickBubble() {
        const container = this.container;
        const options = container.actualOptions;
        const mouseClickPos = container.interactivity.mouse.clickPosition;
        if (mouseClickPos === undefined) {
            return;
        }
        const distance = container.retina.bubbleModeDistance;
        const query = container.particles.quadTree.queryCircle(mouseClickPos, distance);
        for (const particle of query) {
            if (!container.bubble.clicking) {
                continue;
            }
            particle.bubble.inRange = !container.bubble.durationEnd;
            const pos = particle.getPosition();
            const distMouse = Utils_1.NumberUtils.getDistance(pos, mouseClickPos);
            const timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;
            if (timeSpent > options.interactivity.modes.bubble.duration) {
                container.bubble.durationEnd = true;
            }
            if (timeSpent > options.interactivity.modes.bubble.duration * 2) {
                container.bubble.clicking = false;
                container.bubble.durationEnd = false;
            }
            const sizeData = {
                bubbleObj: {
                    optValue: container.retina.bubbleModeSize,
                    value: particle.bubble.radius,
                },
                particlesObj: {
                    optValue: Utils_1.NumberUtils.getRangeMax(particle.options.size.value) * container.retina.pixelRatio,
                    value: particle.size.value,
                },
                type: Enums_1.ProcessBubbleType.size,
            };
            this.process(particle, distMouse, timeSpent, sizeData);
            const opacityData = {
                bubbleObj: {
                    optValue: options.interactivity.modes.bubble.opacity,
                    value: particle.bubble.opacity,
                },
                particlesObj: {
                    optValue: Utils_1.NumberUtils.getRangeMax(particle.options.opacity.value),
                    value: particle.opacity.value,
                },
                type: Enums_1.ProcessBubbleType.opacity,
            };
            this.process(particle, distMouse, timeSpent, opacityData);
            if (!container.bubble.durationEnd) {
                if (distMouse <= container.retina.bubbleModeDistance) {
                    this.hoverBubbleColor(particle);
                }
                else {
                    delete particle.bubble.color;
                }
            }
            else {
                delete particle.bubble.color;
            }
        }
    }
    hoverBubble() {
        const container = this.container;
        const mousePos = container.interactivity.mouse.position;
        if (mousePos === undefined) {
            return;
        }
        const distance = container.retina.bubbleModeDistance;
        const query = container.particles.quadTree.queryCircle(mousePos, distance);
        for (const particle of query) {
            particle.bubble.inRange = true;
            const pos = particle.getPosition();
            const pointDistance = Utils_1.NumberUtils.getDistance(pos, mousePos);
            const ratio = 1 - pointDistance / distance;
            if (pointDistance <= distance) {
                if (ratio >= 0 && container.interactivity.status === Utils_1.Constants.mouseMoveEvent) {
                    this.hoverBubbleSize(particle, ratio);
                    this.hoverBubbleOpacity(particle, ratio);
                    this.hoverBubbleColor(particle);
                }
            }
            else {
                this.reset(particle);
            }
            if (container.interactivity.status === Utils_1.Constants.mouseLeaveEvent) {
                this.reset(particle);
            }
        }
    }
    hoverBubbleSize(particle, ratio, divBubble) {
        const container = this.container;
        const modeSize = (divBubble === null || divBubble === void 0 ? void 0 : divBubble.size)
            ? divBubble.size * container.retina.pixelRatio
            : container.retina.bubbleModeSize;
        if (modeSize === undefined) {
            return;
        }
        const optSize = Utils_1.NumberUtils.getRangeMax(particle.options.size.value) * container.retina.pixelRatio;
        const pSize = particle.size.value;
        const size = calculateBubbleValue(pSize, modeSize, optSize, ratio);
        if (size !== undefined) {
            particle.bubble.radius = size;
        }
    }
    hoverBubbleOpacity(particle, ratio, divBubble) {
        var _a;
        const options = this.container.actualOptions;
        const modeOpacity = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.opacity) !== null && _a !== void 0 ? _a : options.interactivity.modes.bubble.opacity;
        if (modeOpacity === undefined) {
            return;
        }
        const optOpacity = particle.options.opacity.value;
        const pOpacity = particle.opacity.value;
        const opacity = calculateBubbleValue(pOpacity, modeOpacity, Utils_1.NumberUtils.getRangeMax(optOpacity), ratio);
        if (opacity !== undefined) {
            particle.bubble.opacity = opacity;
        }
    }
    hoverBubbleColor(particle, divBubble) {
        var _a;
        const options = this.container.actualOptions;
        if (particle.bubble.color === undefined) {
            const modeColor = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.color) !== null && _a !== void 0 ? _a : options.interactivity.modes.bubble.color;
            if (modeColor === undefined) {
                return;
            }
            const bubbleColor = modeColor instanceof Array ? Utils_1.Utils.itemFromArray(modeColor) : modeColor;
            particle.bubble.color = Utils_1.ColorUtils.colorToHsl(bubbleColor);
        }
    }
}
exports.Bubbler = Bubbler;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Connector.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Connector.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Connector = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Connector {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.actualOptions.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.connect, hoverMode);
    }
    reset() {
    }
    interact() {
        const container = this.container;
        const options = container.actualOptions;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "mousemove") {
            const mousePos = container.interactivity.mouse.position;
            if (!mousePos) {
                return;
            }
            const distance = Math.abs(container.retina.connectModeRadius);
            const query = container.particles.quadTree.queryCircle(mousePos, distance);
            let i = 0;
            for (const p1 of query) {
                const pos1 = p1.getPosition();
                for (const p2 of query.slice(i + 1)) {
                    const pos2 = p2.getPosition();
                    const distMax = Math.abs(container.retina.connectModeDistance);
                    const xDiff = Math.abs(pos1.x - pos2.x);
                    const yDiff = Math.abs(pos1.y - pos2.y);
                    if (xDiff < distMax && yDiff < distMax) {
                        container.canvas.drawConnectLine(p1, p2);
                    }
                }
                ++i;
            }
        }
    }
}
exports.Connector = Connector;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Grabber.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Grabber.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Grabber = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Grabber {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.actualOptions.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.grab, hoverMode);
    }
    reset() {
    }
    interact() {
        var _a;
        const container = this.container;
        const options = container.actualOptions;
        const interactivity = options.interactivity;
        if (interactivity.events.onHover.enable && container.interactivity.status === Utils_1.Constants.mouseMoveEvent) {
            const mousePos = container.interactivity.mouse.position;
            if (mousePos === undefined) {
                return;
            }
            const distance = container.retina.grabModeDistance;
            const query = container.particles.quadTree.queryCircle(mousePos, distance);
            for (const particle of query) {
                const pos = particle.getPosition();
                const pointDistance = Utils_1.NumberUtils.getDistance(pos, mousePos);
                if (pointDistance <= distance) {
                    const grabLineOptions = interactivity.modes.grab.links;
                    const lineOpacity = grabLineOptions.opacity;
                    const opacityLine = lineOpacity - (pointDistance * lineOpacity) / distance;
                    if (opacityLine > 0) {
                        const optColor = (_a = grabLineOptions.color) !== null && _a !== void 0 ? _a : particle.options.links.color;
                        if (!container.particles.grabLineColor) {
                            const linksOptions = container.actualOptions.interactivity.modes.grab.links;
                            container.particles.grabLineColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);
                        }
                        const colorLine = Utils_1.ColorUtils.getLinkColor(particle, undefined, container.particles.grabLineColor);
                        if (colorLine === undefined) {
                            return;
                        }
                        container.canvas.drawGrabLine(particle, colorLine, opacityLine, mousePos);
                    }
                }
            }
        }
    }
}
exports.Grabber = Grabber;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Lighter.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Lighter.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Lighter = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Lighter {
    constructor(container) {
        this.container = container;
    }
    interact() {
        const container = this.container;
        const options = container.actualOptions;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "mousemove") {
            const mousePos = container.interactivity.mouse.position;
            if (!mousePos) {
                return;
            }
            container.canvas.drawLight(mousePos);
        }
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.actualOptions.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.light, hoverMode);
    }
    reset() {
    }
}
exports.Lighter = Lighter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/Repulser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/Repulser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Repulser = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Vector_1 = __webpack_require__(/*! ../../Core/Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js");
class Repulser {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        const container = this.container;
        const options = container.actualOptions;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        const divs = events.onDiv;
        const divRepulse = Utils_1.Utils.isDivModeEnabled(Enums_1.DivMode.repulse, divs);
        if (!(divRepulse || (events.onHover.enable && mouse.position) || (events.onClick.enable && mouse.clickPosition))) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        const clickMode = events.onClick.mode;
        return (Utils_1.Utils.isInArray(Enums_1.HoverMode.repulse, hoverMode) || Utils_1.Utils.isInArray(Enums_1.ClickMode.repulse, clickMode) || divRepulse);
    }
    reset() {
    }
    interact() {
        const container = this.container;
        const options = container.actualOptions;
        const mouseMoveStatus = container.interactivity.status === Utils_1.Constants.mouseMoveEvent;
        const events = options.interactivity.events;
        const hoverEnabled = events.onHover.enable;
        const hoverMode = events.onHover.mode;
        const clickEnabled = events.onClick.enable;
        const clickMode = events.onClick.mode;
        const divs = events.onDiv;
        if (mouseMoveStatus && hoverEnabled && Utils_1.Utils.isInArray(Enums_1.HoverMode.repulse, hoverMode)) {
            this.hoverRepulse();
        }
        else if (clickEnabled && Utils_1.Utils.isInArray(Enums_1.ClickMode.repulse, clickMode)) {
            this.clickRepulse();
        }
        else {
            Utils_1.Utils.divModeExecute(Enums_1.DivMode.repulse, divs, (selector, div) => this.singleSelectorRepulse(selector, div));
        }
    }
    singleSelectorRepulse(selector, div) {
        const container = this.container;
        const query = document.querySelectorAll(selector);
        if (!query.length) {
            return;
        }
        query.forEach((item) => {
            const elem = item;
            const pxRatio = container.retina.pixelRatio;
            const pos = {
                x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,
                y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio,
            };
            const repulseRadius = (elem.offsetWidth / 2) * pxRatio;
            const area = div.type === Enums_1.DivType.circle
                ? new Utils_1.Circle(pos.x, pos.y, repulseRadius)
                : new Utils_1.Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio);
            const divs = container.actualOptions.interactivity.modes.repulse.divs;
            const divRepulse = Utils_1.Utils.divMode(divs, elem);
            this.processRepulse(pos, repulseRadius, area, divRepulse);
        });
    }
    hoverRepulse() {
        const container = this.container;
        const mousePos = container.interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        const repulseRadius = container.retina.repulseModeDistance;
        this.processRepulse(mousePos, repulseRadius, new Utils_1.Circle(mousePos.x, mousePos.y, repulseRadius));
    }
    processRepulse(position, repulseRadius, area, divRepulse) {
        var _a;
        const container = this.container;
        const query = container.particles.quadTree.query(area);
        for (const particle of query) {
            const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(particle.position, position);
            const normVec = {
                x: dx / distance,
                y: dy / distance,
            };
            const velocity = ((_a = divRepulse === null || divRepulse === void 0 ? void 0 : divRepulse.speed) !== null && _a !== void 0 ? _a : container.actualOptions.interactivity.modes.repulse.speed) * 100;
            const repulseFactor = Utils_1.NumberUtils.clamp((1 - Math.pow(distance / repulseRadius, 2)) * velocity, 0, 50);
            particle.position.x += normVec.x * repulseFactor;
            particle.position.y += normVec.y * repulseFactor;
        }
    }
    clickRepulse() {
        const container = this.container;
        if (!container.repulse.finish) {
            if (!container.repulse.count) {
                container.repulse.count = 0;
            }
            container.repulse.count++;
            if (container.repulse.count === container.particles.count) {
                container.repulse.finish = true;
            }
        }
        if (container.repulse.clicking) {
            const repulseDistance = container.retina.repulseModeDistance;
            const repulseRadius = Math.pow(repulseDistance / 6, 3);
            const mouseClickPos = container.interactivity.mouse.clickPosition;
            if (mouseClickPos === undefined) {
                return;
            }
            const range = new Utils_1.Circle(mouseClickPos.x, mouseClickPos.y, repulseRadius);
            const query = container.particles.quadTree.query(range);
            for (const particle of query) {
                const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(mouseClickPos, particle.position);
                const d = distance * distance;
                if (d <= repulseRadius) {
                    container.repulse.particles.push(particle);
                    const velocity = container.actualOptions.interactivity.modes.repulse.speed;
                    const v = Vector_1.Vector.create(dx, dy);
                    v.length = (-repulseRadius * velocity) / d;
                    particle.velocity.setTo(v);
                }
            }
        }
        else if (container.repulse.clicking === false) {
            for (const particle of container.repulse.particles) {
                particle.velocity.setTo(particle.initialVelocity);
            }
            container.repulse.particles = [];
        }
    }
}
exports.Repulser = Repulser;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/External/TrailMaker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/External/TrailMaker.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TrailMaker = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class TrailMaker {
    constructor(container) {
        this.container = container;
        this.delay = 0;
    }
    interact(delta) {
        if (!this.container.retina.reduceFactor) {
            return;
        }
        const container = this.container;
        const options = container.actualOptions;
        const trailOptions = options.interactivity.modes.trail;
        const optDelay = (trailOptions.delay * 1000) / this.container.retina.reduceFactor;
        if (this.delay < optDelay) {
            this.delay += delta.value;
        }
        if (this.delay >= optDelay) {
            container.particles.push(trailOptions.quantity, container.interactivity.mouse, trailOptions.particles);
            this.delay -= optDelay;
        }
    }
    isEnabled() {
        const container = this.container;
        const options = container.actualOptions;
        const mouse = container.interactivity.mouse;
        const events = options.interactivity.events;
        return ((mouse.clicking &&
            mouse.inside &&
            !!mouse.position &&
            Utils_1.Utils.isInArray(Modes_1.ClickMode.trail, events.onClick.mode)) ||
            (mouse.inside && !!mouse.position && Utils_1.Utils.isInArray(Modes_1.HoverMode.trail, events.onHover.mode)));
    }
    reset() {
    }
}
exports.TrailMaker = TrailMaker;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Attractor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Attractor.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attractor = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Attractor {
    constructor(container) {
        this.container = container;
    }
    interact(p1) {
        var _a;
        const container = this.container;
        const distance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;
        const pos1 = p1.getPosition();
        const query = container.particles.quadTree.queryCircle(pos1, distance);
        for (const p2 of query) {
            if (p1 === p2 || !p2.options.move.attract.enable || p2.destroyed || p2.spawning) {
                continue;
            }
            const pos2 = p2.getPosition();
            const { dx, dy } = Utils_1.NumberUtils.getDistances(pos1, pos2);
            const rotate = p1.options.move.attract.rotate;
            const ax = dx / (rotate.x * 1000);
            const ay = dy / (rotate.y * 1000);
            p1.velocity.x -= ax;
            p1.velocity.y -= ay;
            p2.velocity.x += ax;
            p2.velocity.y += ay;
        }
    }
    isEnabled(particle) {
        return particle.options.move.attract.enable;
    }
    reset() {
    }
}
exports.Attractor = Attractor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Collider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Collider.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Collider = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
function bounce(p1, p2) {
    Utils_1.Utils.circleBounce(Utils_1.Utils.circleBounceDataFromParticle(p1), Utils_1.Utils.circleBounceDataFromParticle(p2));
}
function destroy(p1, p2) {
    if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {
        p1.destroy();
    }
    else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {
        p2.destroy();
    }
    else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {
        if (p1.getRadius() >= p2.getRadius()) {
            p2.destroy();
        }
        else {
            p1.destroy();
        }
    }
}
class Collider {
    constructor(container) {
        this.container = container;
    }
    isEnabled(particle) {
        return particle.options.collisions.enable;
    }
    reset() {
    }
    interact(p1) {
        const container = this.container;
        const pos1 = p1.getPosition();
        const query = container.particles.quadTree.queryCircle(pos1, p1.getRadius() * 2);
        for (const p2 of query) {
            if (p1 === p2 ||
                !p2.options.collisions.enable ||
                p1.options.collisions.mode !== p2.options.collisions.mode ||
                p2.destroyed ||
                p2.spawning) {
                continue;
            }
            const pos2 = p2.getPosition();
            const dist = Utils_1.NumberUtils.getDistance(pos1, pos2);
            const radius1 = p1.getRadius();
            const radius2 = p2.getRadius();
            const distP = radius1 + radius2;
            if (dist <= distP) {
                this.resolveCollision(p1, p2);
            }
        }
    }
    resolveCollision(p1, p2) {
        switch (p1.options.collisions.mode) {
            case Enums_1.CollisionMode.absorb: {
                this.absorb(p1, p2);
                break;
            }
            case Enums_1.CollisionMode.bounce: {
                bounce(p1, p2);
                break;
            }
            case Enums_1.CollisionMode.destroy: {
                destroy(p1, p2);
                break;
            }
        }
    }
    absorb(p1, p2) {
        const container = this.container;
        const fps = container.actualOptions.fpsLimit / 1000;
        if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {
            p1.destroy();
        }
        else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {
            p2.destroy();
        }
        else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {
            if (p1.getRadius() >= p2.getRadius()) {
                const factor = Utils_1.NumberUtils.clamp(p1.getRadius() / p2.getRadius(), 0, p2.getRadius()) * fps;
                p1.size.value += factor;
                p2.size.value -= factor;
                if (p2.getRadius() <= container.retina.pixelRatio) {
                    p2.size.value = 0;
                    p2.destroy();
                }
            }
            else {
                const factor = Utils_1.NumberUtils.clamp(p2.getRadius() / p1.getRadius(), 0, p1.getRadius()) * fps;
                p1.size.value -= factor;
                p2.size.value += factor;
                if (p1.getRadius() <= container.retina.pixelRatio) {
                    p1.size.value = 0;
                    p1.destroy();
                }
            }
        }
    }
}
exports.Collider = Collider;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Infecter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Infecter.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Infecter = void 0;
class Infecter {
    constructor(container) {
        this.container = container;
    }
    isEnabled() {
        return this.container.actualOptions.infection.enable;
    }
    reset() {
    }
    interact(p1, delta) {
        var _a, _b;
        const infecter1 = p1.infecter;
        infecter1.updateInfection(delta.value);
        if (infecter1.infectionStage === undefined) {
            return;
        }
        const container = this.container;
        const options = container.actualOptions;
        const infectionOptions = options.infection;
        if (!infectionOptions.enable || infectionOptions.stages.length < 1) {
            return;
        }
        const infectionStage1 = infectionOptions.stages[infecter1.infectionStage];
        const pxRatio = container.retina.pixelRatio;
        const radius = p1.getRadius() * 2 + infectionStage1.radius * pxRatio;
        const pos = p1.getPosition();
        const infectedStage1 = (_a = infectionStage1.infectedStage) !== null && _a !== void 0 ? _a : infecter1.infectionStage;
        const query = container.particles.quadTree.queryCircle(pos, radius);
        const infections = infectionStage1.rate;
        const neighbors = query.length;
        for (const p2 of query) {
            if (p2 === p1 ||
                p2.destroyed ||
                p2.spawning ||
                !(p2.infecter.infectionStage === undefined || p2.infecter.infectionStage !== infecter1.infectionStage)) {
                continue;
            }
            const infecter2 = p2.infecter;
            if (Math.random() < infections / neighbors) {
                if (infecter2.infectionStage === undefined) {
                    infecter2.startInfection(infectedStage1);
                }
                else if (infecter2.infectionStage < infecter1.infectionStage) {
                    infecter2.updateInfectionStage(infectedStage1);
                }
                else if (infecter2.infectionStage > infecter1.infectionStage) {
                    const infectionStage2 = infectionOptions.stages[infecter2.infectionStage];
                    const infectedStage2 = (_b = infectionStage2 === null || infectionStage2 === void 0 ? void 0 : infectionStage2.infectedStage) !== null && _b !== void 0 ? _b : infecter2.infectionStage;
                    infecter1.updateInfectionStage(infectedStage2);
                }
            }
        }
    }
}
exports.Infecter = Infecter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Lighter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Lighter.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Lighter = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Modes_1 = __webpack_require__(/*! ../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class Lighter {
    constructor(container) {
        this.container = container;
    }
    interact(particle) {
        const container = this.container;
        const options = container.actualOptions;
        if (options.interactivity.events.onHover.enable && container.interactivity.status === "mousemove") {
            const mousePos = this.container.interactivity.mouse.position;
            if (mousePos) {
                container.canvas.drawParticleShadow(particle, mousePos);
            }
        }
    }
    isEnabled() {
        const container = this.container;
        const mouse = container.interactivity.mouse;
        const events = container.actualOptions.interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const hoverMode = events.onHover.mode;
        return Utils_1.Utils.isInArray(Modes_1.HoverMode.light, hoverMode);
    }
    reset() {
    }
}
exports.Lighter = Lighter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Interactions/Particles/Linker.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Interactions/Particles/Linker.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Linker = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Linker {
    constructor(container) {
        this.container = container;
    }
    isEnabled(particle) {
        return particle.options.links.enable;
    }
    reset() {
    }
    interact(p1) {
        var _a;
        const container = this.container;
        const linkOpt1 = p1.options.links;
        const optOpacity = linkOpt1.opacity;
        const optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;
        const canvasSize = container.canvas.size;
        const warp = linkOpt1.warp;
        const pos1 = p1.getPosition();
        const range = warp
            ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)
            : new Utils_1.Circle(pos1.x, pos1.y, optDistance);
        const query = container.particles.quadTree.query(range);
        for (const p2 of query) {
            const linkOpt2 = p2.options.links;
            if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed) {
                continue;
            }
            const pos2 = p2.getPosition();
            let distance = Utils_1.NumberUtils.getDistance(pos1, pos2);
            if (warp) {
                if (distance > optDistance) {
                    const pos2NE = {
                        x: pos2.x - canvasSize.width,
                        y: pos2.y,
                    };
                    distance = Utils_1.NumberUtils.getDistance(pos1, pos2NE);
                    if (distance > optDistance) {
                        const pos2SE = {
                            x: pos2.x - canvasSize.width,
                            y: pos2.y - canvasSize.height,
                        };
                        distance = Utils_1.NumberUtils.getDistance(pos1, pos2SE);
                        if (distance > optDistance) {
                            const pos2SW = {
                                x: pos2.x,
                                y: pos2.y - canvasSize.height,
                            };
                            distance = Utils_1.NumberUtils.getDistance(pos1, pos2SW);
                        }
                    }
                }
            }
            if (distance > optDistance) {
                return;
            }
            const opacityLine = (1 - distance / optDistance) * optOpacity;
            const linksOptions = p1.options.links;
            let linkColor = linksOptions.id !== undefined
                ? container.particles.linksColors.get(linksOptions.id)
                : container.particles.linksColor;
            if (!linkColor) {
                const optColor = linksOptions.color;
                linkColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);
                if (linksOptions.id !== undefined) {
                    container.particles.linksColors.set(linksOptions.id, linkColor);
                }
                else {
                    container.particles.linksColor = linkColor;
                }
            }
            if (p2.links.map((t) => t.destination).indexOf(p1) === -1 &&
                p1.links.map((t) => t.destination).indexOf(p2) === -1) {
                p1.links.push({
                    destination: p2,
                    opacity: opacityLine,
                });
            }
        }
    }
}
exports.Linker = Linker;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/AnimationOptions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/AnimationOptions.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationOptions = void 0;
class AnimationOptions {
    constructor() {
        this.count = 0;
        this.enable = false;
        this.speed = 1;
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.AnimationOptions = AnimationOptions;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Background/Background.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Background/Background.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Background = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Background {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "";
        this.image = "";
        this.position = "";
        this.repeat = "";
        this.size = "";
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.image !== undefined) {
            this.image = data.image;
        }
        if (data.position !== undefined) {
            this.position = data.position;
        }
        if (data.repeat !== undefined) {
            this.repeat = data.repeat;
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.Background = Background;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMask.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMask.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundMask = void 0;
const BackgroundMaskCover_1 = __webpack_require__(/*! ./BackgroundMaskCover */ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMaskCover.js");
class BackgroundMask {
    constructor() {
        this.composite = "destination-out";
        this.cover = new BackgroundMaskCover_1.BackgroundMaskCover();
        this.enable = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.composite !== undefined) {
            this.composite = data.composite;
        }
        if (data.cover !== undefined) {
            const cover = data.cover;
            const color = (typeof data.cover === "string" ? { color: data.cover } : data.cover);
            this.cover.load(cover.color !== undefined ? cover : { color: color });
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}
exports.BackgroundMask = BackgroundMask;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMaskCover.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMaskCover.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundMaskCover = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class BackgroundMaskCover {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.BackgroundMaskCover = BackgroundMaskCover;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/ColorAnimation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/ColorAnimation.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorAnimation = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class ColorAnimation {
    constructor() {
        this.count = 0;
        this.enable = false;
        this.offset = 0;
        this.speed = 1;
        this.sync = true;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.offset !== undefined) {
            this.offset = Utils_1.NumberUtils.setRangeValue(data.offset);
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.ColorAnimation = ColorAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/FullScreen/FullScreen.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/FullScreen/FullScreen.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FullScreen = void 0;
class FullScreen {
    constructor() {
        this.enable = false;
        this.zIndex = -1;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.zIndex !== undefined) {
            this.zIndex = data.zIndex;
        }
    }
}
exports.FullScreen = FullScreen;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Infection/Infection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Infection/Infection.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Infection = void 0;
const InfectionStage_1 = __webpack_require__(/*! ./InfectionStage */ "./node_modules/tsparticles/dist/Options/Classes/Infection/InfectionStage.js");
class Infection {
    constructor() {
        this.cure = false;
        this.delay = 0;
        this.enable = false;
        this.infections = 0;
        this.stages = [];
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.cure !== undefined) {
            this.cure = data.cure;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.infections !== undefined) {
            this.infections = data.infections;
        }
        if (data.stages === undefined) {
            return;
        }
        this.stages = data.stages.map((t) => {
            const s = new InfectionStage_1.InfectionStage();
            s.load(t);
            return s;
        });
    }
}
exports.Infection = Infection;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Infection/InfectionStage.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Infection/InfectionStage.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InfectionStage = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class InfectionStage {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "#ff0000";
        this.radius = 0;
        this.rate = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        this.duration = data.duration;
        this.infectedStage = data.infectedStage;
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
        if (data.rate !== undefined) {
            this.rate = data.rate;
        }
    }
}
exports.InfectionStage = InfectionStage;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/ClickEvent.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/ClickEvent.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClickEvent = void 0;
class ClickEvent {
    constructor() {
        this.enable = false;
        this.mode = [];
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
    }
}
exports.ClickEvent = ClickEvent;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/DivEvent.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/DivEvent.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DivEvent = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class DivEvent {
    constructor() {
        this.selectors = [];
        this.enable = false;
        this.mode = [];
        this.type = Enums_1.DivType.circle;
    }
    get elementId() {
        return this.ids;
    }
    set elementId(value) {
        this.ids = value;
    }
    get el() {
        return this.elementId;
    }
    set el(value) {
        this.elementId = value;
    }
    get ids() {
        return this.selectors instanceof Array
            ? this.selectors.map((t) => t.replace("#", ""))
            : this.selectors.replace("#", "");
    }
    set ids(value) {
        this.selectors = value instanceof Array ? value.map((t) => `#${t}`) : `#${value}`;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        const ids = (_b = (_a = data.ids) !== null && _a !== void 0 ? _a : data.elementId) !== null && _b !== void 0 ? _b : data.el;
        if (ids !== undefined) {
            this.ids = ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.type !== undefined) {
            this.type = data.type;
        }
    }
}
exports.DivEvent = DivEvent;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Events.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Events.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = void 0;
const ClickEvent_1 = __webpack_require__(/*! ./ClickEvent */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/ClickEvent.js");
const DivEvent_1 = __webpack_require__(/*! ./DivEvent */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/DivEvent.js");
const HoverEvent_1 = __webpack_require__(/*! ./HoverEvent */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/HoverEvent.js");
class Events {
    constructor() {
        this.onClick = new ClickEvent_1.ClickEvent();
        this.onDiv = new DivEvent_1.DivEvent();
        this.onHover = new HoverEvent_1.HoverEvent();
        this.resize = true;
    }
    get onclick() {
        return this.onClick;
    }
    set onclick(value) {
        this.onClick = value;
    }
    get ondiv() {
        return this.onDiv;
    }
    set ondiv(value) {
        this.onDiv = value;
    }
    get onhover() {
        return this.onHover;
    }
    set onhover(value) {
        this.onHover = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        this.onClick.load((_a = data.onClick) !== null && _a !== void 0 ? _a : data.onclick);
        const onDiv = (_b = data.onDiv) !== null && _b !== void 0 ? _b : data.ondiv;
        if (onDiv !== undefined) {
            if (onDiv instanceof Array) {
                this.onDiv = onDiv.map((div) => {
                    const tmp = new DivEvent_1.DivEvent();
                    tmp.load(div);
                    return tmp;
                });
            }
            else {
                this.onDiv = new DivEvent_1.DivEvent();
                this.onDiv.load(onDiv);
            }
        }
        this.onHover.load((_c = data.onHover) !== null && _c !== void 0 ? _c : data.onhover);
        if (data.resize !== undefined) {
            this.resize = data.resize;
        }
    }
}
exports.Events = Events;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/HoverEvent.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/HoverEvent.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverEvent = void 0;
const Parallax_1 = __webpack_require__(/*! ./Parallax */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Parallax.js");
class HoverEvent {
    constructor() {
        this.enable = false;
        this.mode = [];
        this.parallax = new Parallax_1.Parallax();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        this.parallax.load(data.parallax);
    }
}
exports.HoverEvent = HoverEvent;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Parallax.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Parallax.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Parallax = void 0;
class Parallax {
    constructor() {
        this.enable = false;
        this.force = 2;
        this.smooth = 10;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.force !== undefined) {
            this.force = data.force;
        }
        if (data.smooth !== undefined) {
            this.smooth = data.smooth;
        }
    }
}
exports.Parallax = Parallax;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Interactivity.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Interactivity.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Interactivity = void 0;
const Enums_1 = __webpack_require__(/*! ../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Events_1 = __webpack_require__(/*! ./Events/Events */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Events/Events.js");
const Modes_1 = __webpack_require__(/*! ./Modes/Modes */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Modes.js");
class Interactivity {
    constructor() {
        this.detectsOn = Enums_1.InteractivityDetect.canvas;
        this.events = new Events_1.Events();
        this.modes = new Modes_1.Modes();
    }
    get detect_on() {
        return this.detectsOn;
    }
    set detect_on(value) {
        this.detectsOn = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        const detectsOn = (_a = data.detectsOn) !== null && _a !== void 0 ? _a : data.detect_on;
        if (detectsOn !== undefined) {
            this.detectsOn = detectsOn;
        }
        this.events.load(data.events);
        this.modes.load(data.modes);
        if (((_c = (_b = data.modes) === null || _b === void 0 ? void 0 : _b.slow) === null || _c === void 0 ? void 0 : _c.active) === true) {
            if (this.events.onHover.mode instanceof Array) {
                if (this.events.onHover.mode.indexOf(Enums_1.HoverMode.slow) < 0) {
                    this.events.onHover.mode.push(Enums_1.HoverMode.slow);
                }
            }
            else if (this.events.onHover.mode !== Enums_1.HoverMode.slow) {
                this.events.onHover.mode = [this.events.onHover.mode, Enums_1.HoverMode.slow];
            }
        }
    }
}
exports.Interactivity = Interactivity;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Attract.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Attract.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attract = void 0;
class Attract {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.speed = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
    }
}
exports.Attract = Attract;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bounce.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bounce.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bounce = void 0;
class Bounce {
    constructor() {
        this.distance = 200;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
    }
}
exports.Bounce = Bounce;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bubble.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bubble.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bubble = void 0;
const BubbleDiv_1 = __webpack_require__(/*! ./BubbleDiv */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleDiv.js");
const BubbleBase_1 = __webpack_require__(/*! ./BubbleBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js");
class Bubble extends BubbleBase_1.BubbleBase {
    load(data) {
        super.load(data);
        if (!(data !== undefined && data.divs !== undefined)) {
            return;
        }
        if (data.divs instanceof Array) {
            this.divs = data.divs.map((s) => {
                const tmp = new BubbleDiv_1.BubbleDiv();
                tmp.load(s);
                return tmp;
            });
        }
        else {
            if (this.divs instanceof Array || !this.divs) {
                this.divs = new BubbleDiv_1.BubbleDiv();
            }
            this.divs.load(data.divs);
        }
    }
}
exports.Bubble = Bubble;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BubbleBase = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class BubbleBase {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        if (data.color !== undefined) {
            if (data.color instanceof Array) {
                this.color = data.color.map((s) => OptionsColor_1.OptionsColor.create(undefined, s));
            }
            else {
                if (this.color instanceof Array) {
                    this.color = new OptionsColor_1.OptionsColor();
                }
                this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
            }
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
    }
}
exports.BubbleBase = BubbleBase;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleDiv.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleDiv.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BubbleDiv = void 0;
const BubbleBase_1 = __webpack_require__(/*! ./BubbleBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/BubbleBase.js");
class BubbleDiv extends BubbleBase_1.BubbleBase {
    constructor() {
        super();
        this.selectors = [];
    }
    get ids() {
        return this.selectors instanceof Array
            ? this.selectors.map((t) => t.replace("#", ""))
            : this.selectors.replace("#", "");
    }
    set ids(value) {
        this.selectors = value instanceof Array ? value.map((t) => `#${t}`) : `#${value}`;
    }
    load(data) {
        super.load(data);
        if (data === undefined) {
            return;
        }
        if (data.ids !== undefined) {
            this.ids = data.ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
    }
}
exports.BubbleDiv = BubbleDiv;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Connect.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Connect.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Connect = void 0;
const ConnectLinks_1 = __webpack_require__(/*! ./ConnectLinks */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/ConnectLinks.js");
class Connect {
    constructor() {
        this.distance = 80;
        this.links = new ConnectLinks_1.ConnectLinks();
        this.radius = 60;
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        this.links.load((_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked);
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}
exports.Connect = Connect;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/ConnectLinks.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/ConnectLinks.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectLinks = void 0;
class ConnectLinks {
    constructor() {
        this.opacity = 0.5;
    }
    load(data) {
        if (!(data !== undefined && data.opacity !== undefined)) {
            return;
        }
        this.opacity = data.opacity;
    }
}
exports.ConnectLinks = ConnectLinks;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Grab.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Grab.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Grab = void 0;
const GrabLinks_1 = __webpack_require__(/*! ./GrabLinks */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/GrabLinks.js");
class Grab {
    constructor() {
        this.distance = 100;
        this.links = new GrabLinks_1.GrabLinks();
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b;
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        this.links.load((_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked);
    }
}
exports.Grab = Grab;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/GrabLinks.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/GrabLinks.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GrabLinks = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class GrabLinks {
    constructor() {
        this.blink = false;
        this.consent = false;
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.blink !== undefined) {
            this.blink = data.blink;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.consent !== undefined) {
            this.consent = data.consent;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.GrabLinks = GrabLinks;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Light.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Light.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Light = void 0;
const LightArea_1 = __webpack_require__(/*! ./LightArea */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightArea.js");
const LightShadow_1 = __webpack_require__(/*! ./LightShadow */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightShadow.js");
class Light {
    constructor() {
        this.area = new LightArea_1.LightArea();
        this.shadow = new LightShadow_1.LightShadow();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.area.load(data.area);
        this.shadow.load(data.shadow);
    }
}
exports.Light = Light;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightArea.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightArea.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightArea = void 0;
const LightGradient_1 = __webpack_require__(/*! ./LightGradient */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightGradient.js");
class LightArea {
    constructor() {
        this.gradient = new LightGradient_1.LightGradient();
        this.radius = 1000;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.gradient.load(data.gradient);
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}
exports.LightArea = LightArea;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightGradient.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightGradient.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightGradient = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LightGradient {
    constructor() {
        this.start = new OptionsColor_1.OptionsColor();
        this.stop = new OptionsColor_1.OptionsColor();
        this.start.value = "#ffffff";
        this.stop.value = "#000000";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.start = OptionsColor_1.OptionsColor.create(this.start, data.start);
        this.stop = OptionsColor_1.OptionsColor.create(this.stop, data.stop);
    }
}
exports.LightGradient = LightGradient;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightShadow.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/LightShadow.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LightShadow = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LightShadow {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "#000000";
        this.length = 2000;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.length !== undefined) {
            this.length = data.length;
        }
    }
}
exports.LightShadow = LightShadow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Modes.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Modes.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Modes = void 0;
const Bubble_1 = __webpack_require__(/*! ./Bubble */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bubble.js");
const Connect_1 = __webpack_require__(/*! ./Connect */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Connect.js");
const Grab_1 = __webpack_require__(/*! ./Grab */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Grab.js");
const Remove_1 = __webpack_require__(/*! ./Remove */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Remove.js");
const Push_1 = __webpack_require__(/*! ./Push */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Push.js");
const Repulse_1 = __webpack_require__(/*! ./Repulse */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Repulse.js");
const Slow_1 = __webpack_require__(/*! ./Slow */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Slow.js");
const Trail_1 = __webpack_require__(/*! ./Trail */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Trail.js");
const Attract_1 = __webpack_require__(/*! ./Attract */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Attract.js");
const Light_1 = __webpack_require__(/*! ./Light */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Light.js");
const Bounce_1 = __webpack_require__(/*! ./Bounce */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Bounce.js");
class Modes {
    constructor() {
        this.attract = new Attract_1.Attract();
        this.bounce = new Bounce_1.Bounce();
        this.bubble = new Bubble_1.Bubble();
        this.connect = new Connect_1.Connect();
        this.grab = new Grab_1.Grab();
        this.light = new Light_1.Light();
        this.push = new Push_1.Push();
        this.remove = new Remove_1.Remove();
        this.repulse = new Repulse_1.Repulse();
        this.slow = new Slow_1.Slow();
        this.trail = new Trail_1.Trail();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.attract.load(data.attract);
        this.bubble.load(data.bubble);
        this.connect.load(data.connect);
        this.grab.load(data.grab);
        this.light.load(data.light);
        this.push.load(data.push);
        this.remove.load(data.remove);
        this.repulse.load(data.repulse);
        this.slow.load(data.slow);
        this.trail.load(data.trail);
    }
}
exports.Modes = Modes;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Push.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Push.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Push = void 0;
class Push {
    constructor() {
        this.quantity = 4;
    }
    get particles_nb() {
        return this.quantity;
    }
    set particles_nb(value) {
        this.quantity = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        const quantity = (_a = data.quantity) !== null && _a !== void 0 ? _a : data.particles_nb;
        if (quantity !== undefined) {
            this.quantity = quantity;
        }
    }
}
exports.Push = Push;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Remove.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Remove.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Remove = void 0;
class Remove {
    constructor() {
        this.quantity = 2;
    }
    get particles_nb() {
        return this.quantity;
    }
    set particles_nb(value) {
        this.quantity = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        const quantity = (_a = data.quantity) !== null && _a !== void 0 ? _a : data.particles_nb;
        if (quantity !== undefined) {
            this.quantity = quantity;
        }
    }
}
exports.Remove = Remove;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Repulse.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Repulse.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Repulse = void 0;
const RepulseDiv_1 = __webpack_require__(/*! ./RepulseDiv */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseDiv.js");
const RepulseBase_1 = __webpack_require__(/*! ./RepulseBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js");
class Repulse extends RepulseBase_1.RepulseBase {
    load(data) {
        super.load(data);
        if ((data === null || data === void 0 ? void 0 : data.divs) === undefined) {
            return;
        }
        if (data.divs instanceof Array) {
            this.divs = data.divs.map((s) => {
                const tmp = new RepulseDiv_1.RepulseDiv();
                tmp.load(s);
                return tmp;
            });
        }
        else {
            if (this.divs instanceof Array || !this.divs) {
                this.divs = new RepulseDiv_1.RepulseDiv();
            }
            this.divs.load(data.divs);
        }
    }
}
exports.Repulse = Repulse;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RepulseBase = void 0;
class RepulseBase {
    constructor() {
        this.distance = 200;
        this.duration = 0.4;
        this.speed = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
    }
}
exports.RepulseBase = RepulseBase;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseDiv.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseDiv.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RepulseDiv = void 0;
const RepulseBase_1 = __webpack_require__(/*! ./RepulseBase */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/RepulseBase.js");
class RepulseDiv extends RepulseBase_1.RepulseBase {
    constructor() {
        super();
        this.selectors = [];
    }
    get ids() {
        if (this.selectors instanceof Array) {
            return this.selectors.map((t) => t.replace("#", ""));
        }
        else {
            return this.selectors.replace("#", "");
        }
    }
    set ids(value) {
        if (value instanceof Array) {
            this.selectors = value.map(() => `#${value}`);
        }
        else {
            this.selectors = `#${value}`;
        }
    }
    load(data) {
        super.load(data);
        if (data === undefined) {
            return;
        }
        if (data.ids !== undefined) {
            this.ids = data.ids;
        }
        if (data.selectors !== undefined) {
            this.selectors = data.selectors;
        }
    }
}
exports.RepulseDiv = RepulseDiv;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Slow.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Slow.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Slow = void 0;
class Slow {
    constructor() {
        this.factor = 3;
        this.radius = 200;
    }
    get active() {
        return false;
    }
    set active(_value) {
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.radius !== undefined) {
            this.radius = data.radius;
        }
    }
}
exports.Slow = Slow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Trail.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Interactivity/Modes/Trail.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Trail = void 0;
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Trail {
    constructor() {
        this.delay = 1;
        this.quantity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.quantity !== undefined) {
            this.quantity = data.quantity;
        }
        if (data.particles !== undefined) {
            this.particles = Utils_1.Utils.deepExtend({}, data.particles);
        }
    }
}
exports.Trail = Trail;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/ManualParticle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/ManualParticle.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ManualParticle = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class ManualParticle {
    load(data) {
        var _a, _b;
        if (!data) {
            return;
        }
        if (data.position !== undefined) {
            this.position = {
                x: (_a = data.position.x) !== null && _a !== void 0 ? _a : 50,
                y: (_b = data.position.y) !== null && _b !== void 0 ? _b : 50,
            };
        }
        if (data.options !== undefined) {
            this.options = Utils_1.Utils.deepExtend({}, data.options);
        }
    }
}
exports.ManualParticle = ManualParticle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Motion/Motion.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Motion/Motion.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Motion = void 0;
const MotionReduce_1 = __webpack_require__(/*! ./MotionReduce */ "./node_modules/tsparticles/dist/Options/Classes/Motion/MotionReduce.js");
class Motion {
    constructor() {
        this.disable = false;
        this.reduce = new MotionReduce_1.MotionReduce();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.disable !== undefined) {
            this.disable = data.disable;
        }
        this.reduce.load(data.reduce);
    }
}
exports.Motion = Motion;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Motion/MotionReduce.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Motion/MotionReduce.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MotionReduce = void 0;
class MotionReduce {
    constructor() {
        this.factor = 4;
        this.value = true;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.MotionReduce = MotionReduce;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Options.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Options.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Options = void 0;
const Interactivity_1 = __webpack_require__(/*! ./Interactivity/Interactivity */ "./node_modules/tsparticles/dist/Options/Classes/Interactivity/Interactivity.js");
const ParticlesOptions_1 = __webpack_require__(/*! ./Particles/ParticlesOptions */ "./node_modules/tsparticles/dist/Options/Classes/Particles/ParticlesOptions.js");
const BackgroundMask_1 = __webpack_require__(/*! ./BackgroundMask/BackgroundMask */ "./node_modules/tsparticles/dist/Options/Classes/BackgroundMask/BackgroundMask.js");
const Background_1 = __webpack_require__(/*! ./Background/Background */ "./node_modules/tsparticles/dist/Options/Classes/Background/Background.js");
const Infection_1 = __webpack_require__(/*! ./Infection/Infection */ "./node_modules/tsparticles/dist/Options/Classes/Infection/Infection.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Theme_1 = __webpack_require__(/*! ./Theme/Theme */ "./node_modules/tsparticles/dist/Options/Classes/Theme/Theme.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const FullScreen_1 = __webpack_require__(/*! ./FullScreen/FullScreen */ "./node_modules/tsparticles/dist/Options/Classes/FullScreen/FullScreen.js");
const Motion_1 = __webpack_require__(/*! ./Motion/Motion */ "./node_modules/tsparticles/dist/Options/Classes/Motion/Motion.js");
const ManualParticle_1 = __webpack_require__(/*! ./ManualParticle */ "./node_modules/tsparticles/dist/Options/Classes/ManualParticle.js");
const Responsive_1 = __webpack_require__(/*! ./Responsive */ "./node_modules/tsparticles/dist/Options/Classes/Responsive.js");
class Options {
    constructor() {
        this.autoPlay = true;
        this.background = new Background_1.Background();
        this.backgroundMask = new BackgroundMask_1.BackgroundMask();
        this.fullScreen = new FullScreen_1.FullScreen();
        this.detectRetina = true;
        this.fpsLimit = 60;
        this.infection = new Infection_1.Infection();
        this.interactivity = new Interactivity_1.Interactivity();
        this.manualParticles = [];
        this.motion = new Motion_1.Motion();
        this.particles = new ParticlesOptions_1.ParticlesOptions();
        this.pauseOnBlur = true;
        this.pauseOnOutsideViewport = true;
        this.responsive = [];
        this.themes = [];
    }
    get fps_limit() {
        return this.fpsLimit;
    }
    set fps_limit(value) {
        this.fpsLimit = value;
    }
    get retina_detect() {
        return this.detectRetina;
    }
    set retina_detect(value) {
        this.detectRetina = value;
    }
    get backgroundMode() {
        return this.fullScreen;
    }
    set backgroundMode(value) {
        this.fullScreen.load(value);
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        if (data.preset !== undefined) {
            if (data.preset instanceof Array) {
                for (const preset of data.preset) {
                    this.importPreset(preset);
                }
            }
            else {
                this.importPreset(data.preset);
            }
        }
        if (data.autoPlay !== undefined) {
            this.autoPlay = data.autoPlay;
        }
        const detectRetina = (_a = data.detectRetina) !== null && _a !== void 0 ? _a : data.retina_detect;
        if (detectRetina !== undefined) {
            this.detectRetina = detectRetina;
        }
        const fpsLimit = (_b = data.fpsLimit) !== null && _b !== void 0 ? _b : data.fps_limit;
        if (fpsLimit !== undefined) {
            this.fpsLimit = fpsLimit;
        }
        if (data.pauseOnBlur !== undefined) {
            this.pauseOnBlur = data.pauseOnBlur;
        }
        if (data.pauseOnOutsideViewport !== undefined) {
            this.pauseOnOutsideViewport = data.pauseOnOutsideViewport;
        }
        this.background.load(data.background);
        this.fullScreen.load((_c = data.fullScreen) !== null && _c !== void 0 ? _c : data.backgroundMode);
        this.backgroundMask.load(data.backgroundMask);
        this.infection.load(data.infection);
        this.interactivity.load(data.interactivity);
        if (data.manualParticles !== undefined) {
            this.manualParticles = data.manualParticles.map((t) => {
                const tmp = new ManualParticle_1.ManualParticle();
                tmp.load(t);
                return tmp;
            });
        }
        this.motion.load(data.motion);
        this.particles.load(data.particles);
        Utils_1.Plugins.loadOptions(this, data);
        if (data.responsive !== undefined) {
            for (const responsive of data.responsive) {
                const optResponsive = new Responsive_1.Responsive();
                optResponsive.load(responsive);
                this.responsive.push(optResponsive);
            }
        }
        this.responsive.sort((a, b) => a.maxWidth - b.maxWidth);
        if (data.themes !== undefined) {
            for (const theme of data.themes) {
                const optTheme = new Theme_1.Theme();
                optTheme.load(theme);
                this.themes.push(optTheme);
            }
        }
    }
    setTheme(name) {
        if (name) {
            const chosenTheme = this.themes.find((theme) => theme.name === name);
            if (chosenTheme) {
                this.load(chosenTheme.options);
            }
        }
        else {
            const clientDarkMode = typeof matchMedia !== "undefined" && matchMedia("(prefers-color-scheme: dark)").matches;
            let defaultTheme = this.themes.find((theme) => theme.default.value &&
                ((theme.default.mode === Enums_1.ThemeMode.dark && clientDarkMode) ||
                    (theme.default.mode === Enums_1.ThemeMode.light && !clientDarkMode)));
            if (!defaultTheme) {
                defaultTheme = this.themes.find((theme) => theme.default.value && theme.default.mode === Enums_1.ThemeMode.any);
            }
            if (defaultTheme) {
                this.load(defaultTheme.options);
            }
        }
    }
    importPreset(preset) {
        this.load(Utils_1.Plugins.getPreset(preset));
    }
    setResponsive(width, pxRatio, defaultOptions) {
        var _a;
        this.load(defaultOptions);
        this.load((_a = this.responsive.find((t) => t.maxWidth * pxRatio > width)) === null || _a === void 0 ? void 0 : _a.options);
    }
}
exports.Options = Options;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionsColor = void 0;
class OptionsColor {
    constructor() {
        this.value = "#fff";
    }
    static create(source, data) {
        const color = source !== null && source !== void 0 ? source : new OptionsColor();
        if (data !== undefined) {
            color.load(typeof data === "string" ? { value: data } : data);
        }
        return color;
    }
    load(data) {
        if ((data === null || data === void 0 ? void 0 : data.value) === undefined) {
            return;
        }
        this.value = data.value;
    }
}
exports.OptionsColor = OptionsColor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimatableColor = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
const HslAnimation_1 = __webpack_require__(/*! ./HslAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/HslAnimation.js");
class AnimatableColor extends OptionsColor_1.OptionsColor {
    constructor() {
        super();
        this.animation = new HslAnimation_1.HslAnimation();
    }
    static create(source, data) {
        const color = source !== null && source !== void 0 ? source : new AnimatableColor();
        if (data !== undefined) {
            color.load(typeof data === "string" ? { value: data } : data);
        }
        return color;
    }
    load(data) {
        super.load(data);
        if (!data) {
            return;
        }
        const colorAnimation = data.animation;
        if (colorAnimation !== undefined) {
            if (colorAnimation.enable !== undefined) {
                this.animation.h.load(colorAnimation);
            }
            else {
                this.animation.load(data.animation);
            }
        }
    }
}
exports.AnimatableColor = AnimatableColor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Bounce = void 0;
const BounceFactor_1 = __webpack_require__(/*! ./BounceFactor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/BounceFactor.js");
class Bounce {
    constructor() {
        this.horizontal = new BounceFactor_1.BounceFactor();
        this.vertical = new BounceFactor_1.BounceFactor();
    }
    load(data) {
        if (!data) {
            return;
        }
        this.horizontal.load(data.horizontal);
        this.vertical.load(data.vertical);
    }
}
exports.Bounce = Bounce;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/BounceFactor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/BounceFactor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BounceFactor = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class BounceFactor extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.random.minimumValue = 0.1;
        this.value = 1;
    }
}
exports.BounceFactor = BounceFactor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions/Collisions.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions/Collisions.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Collisions = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Bounce_1 = __webpack_require__(/*! ../Bounce/Bounce */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js");
const CollisionsOverlap_1 = __webpack_require__(/*! ./CollisionsOverlap */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions/CollisionsOverlap.js");
class Collisions {
    constructor() {
        this.bounce = new Bounce_1.Bounce();
        this.enable = false;
        this.mode = Enums_1.CollisionMode.bounce;
        this.overlap = new CollisionsOverlap_1.CollisionsOverlap();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.bounce.load(data.bounce);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        this.overlap.load(data.overlap);
    }
}
exports.Collisions = Collisions;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions/CollisionsOverlap.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions/CollisionsOverlap.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CollisionsOverlap = void 0;
class CollisionsOverlap {
    constructor() {
        this.enable = true;
        this.retries = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.retries !== undefined) {
            this.retries = data.retries;
        }
    }
}
exports.CollisionsOverlap = CollisionsOverlap;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/Destroy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/Destroy.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Destroy = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Split_1 = __webpack_require__(/*! ./Split */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/Split.js");
class Destroy {
    constructor() {
        this.mode = Enums_1.DestroyMode.none;
        this.split = new Split_1.Split();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        this.split.load(data.split);
    }
}
exports.Destroy = Destroy;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/Split.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/Split.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Split = void 0;
const SplitFactor_1 = __webpack_require__(/*! ./SplitFactor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/SplitFactor.js");
const SplitRate_1 = __webpack_require__(/*! ./SplitRate */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/SplitRate.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Split {
    constructor() {
        this.count = 1;
        this.factor = new SplitFactor_1.SplitFactor();
        this.rate = new SplitRate_1.SplitRate();
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        this.factor.load(data.factor);
        this.rate.load(data.rate);
        if (data.particles !== undefined) {
            this.particles = Utils_1.Utils.deepExtend({}, data.particles);
        }
    }
}
exports.Split = Split;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/SplitFactor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/SplitFactor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitFactor = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class SplitFactor extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.value = 3;
    }
}
exports.SplitFactor = SplitFactor;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/SplitRate.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/SplitRate.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitRate = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class SplitRate extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.value = { min: 4, max: 9 };
    }
}
exports.SplitRate = SplitRate;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/HslAnimation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/HslAnimation.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HslAnimation = void 0;
const ColorAnimation_1 = __webpack_require__(/*! ../ColorAnimation */ "./node_modules/tsparticles/dist/Options/Classes/ColorAnimation.js");
class HslAnimation {
    constructor() {
        this.h = new ColorAnimation_1.ColorAnimation();
        this.s = new ColorAnimation_1.ColorAnimation();
        this.l = new ColorAnimation_1.ColorAnimation();
    }
    load(data) {
        if (!data) {
            return;
        }
        this.h.load(data.h);
        this.s.load(data.s);
        this.l.load(data.l);
    }
}
exports.HslAnimation = HslAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/Life.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Life/Life.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Life = void 0;
const LifeDelay_1 = __webpack_require__(/*! ./LifeDelay */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDelay.js");
const LifeDuration_1 = __webpack_require__(/*! ./LifeDuration */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDuration.js");
class Life {
    constructor() {
        this.count = 0;
        this.delay = new LifeDelay_1.LifeDelay();
        this.duration = new LifeDuration_1.LifeDuration();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        this.delay.load(data.delay);
        this.duration.load(data.duration);
    }
}
exports.Life = Life;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDelay.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDelay.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LifeDelay = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class LifeDelay extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.sync = false;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.LifeDelay = LifeDelay;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDuration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Life/LifeDuration.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LifeDuration = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class LifeDuration extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.random.minimumValue = 0.0001;
        this.sync = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        super.load(data);
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.LifeDuration = LifeDuration;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/Links.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Links/Links.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Links = void 0;
const LinksShadow_1 = __webpack_require__(/*! ./LinksShadow */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksShadow.js");
const LinksTriangle_1 = __webpack_require__(/*! ./LinksTriangle */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksTriangle.js");
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Links {
    constructor() {
        this.blink = false;
        this.color = new OptionsColor_1.OptionsColor();
        this.consent = false;
        this.distance = 100;
        this.enable = false;
        this.frequency = 1;
        this.opacity = 1;
        this.shadow = new LinksShadow_1.LinksShadow();
        this.triangles = new LinksTriangle_1.LinksTriangle();
        this.width = 1;
        this.warp = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.id !== undefined) {
            this.id = data.id;
        }
        if (data.blink !== undefined) {
            this.blink = data.blink;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.consent !== undefined) {
            this.consent = data.consent;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        this.shadow.load(data.shadow);
        this.triangles.load(data.triangles);
        if (data.width !== undefined) {
            this.width = data.width;
        }
        if (data.warp !== undefined) {
            this.warp = data.warp;
        }
    }
}
exports.Links = Links;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksShadow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksShadow.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LinksShadow = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LinksShadow {
    constructor() {
        this.blur = 5;
        this.color = new OptionsColor_1.OptionsColor();
        this.enable = false;
        this.color.value = "#00ff00";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.blur !== undefined) {
            this.blur = data.blur;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
    }
}
exports.LinksShadow = LinksShadow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksTriangle.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Links/LinksTriangle.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LinksTriangle = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class LinksTriangle {
    constructor() {
        this.enable = false;
        this.frequency = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.LinksTriangle = LinksTriangle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Attract.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Attract.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Attract = void 0;
class Attract {
    constructor() {
        this.enable = false;
        this.rotate = {
            x: 3000,
            y: 3000,
        };
    }
    get rotateX() {
        return this.rotate.x;
    }
    set rotateX(value) {
        this.rotate.x = value;
    }
    get rotateY() {
        return this.rotate.y;
    }
    set rotateY(value) {
        this.rotate.y = value;
    }
    load(data) {
        var _a, _b, _c, _d;
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const rotateX = (_b = (_a = data.rotate) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : data.rotateX;
        if (rotateX !== undefined) {
            this.rotate.x = rotateX;
        }
        const rotateY = (_d = (_c = data.rotate) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : data.rotateY;
        if (rotateY !== undefined) {
            this.rotate.y = rotateY;
        }
    }
}
exports.Attract = Attract;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Move.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Move.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Move = void 0;
const Attract_1 = __webpack_require__(/*! ./Attract */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Attract.js");
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Trail_1 = __webpack_require__(/*! ./Trail */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Trail.js");
const Path_1 = __webpack_require__(/*! ./Path/Path */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Path/Path.js");
const MoveAngle_1 = __webpack_require__(/*! ./MoveAngle */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveAngle.js");
const MoveGravity_1 = __webpack_require__(/*! ./MoveGravity */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveGravity.js");
const OutModes_1 = __webpack_require__(/*! ./OutModes */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/OutModes.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Move {
    constructor() {
        this.angle = new MoveAngle_1.MoveAngle();
        this.attract = new Attract_1.Attract();
        this.decay = 0;
        this.distance = 0;
        this.direction = Enums_1.MoveDirection.none;
        this.drift = 0;
        this.enable = false;
        this.gravity = new MoveGravity_1.MoveGravity();
        this.path = new Path_1.Path();
        this.outModes = new OutModes_1.OutModes();
        this.random = false;
        this.size = false;
        this.speed = 2;
        this.straight = false;
        this.trail = new Trail_1.Trail();
        this.vibrate = false;
        this.warp = false;
    }
    get collisions() {
        return false;
    }
    set collisions(value) {
    }
    get bounce() {
        return this.collisions;
    }
    set bounce(value) {
        this.collisions = value;
    }
    get out_mode() {
        return this.outMode;
    }
    set out_mode(value) {
        this.outMode = value;
    }
    get outMode() {
        return this.outModes.default;
    }
    set outMode(value) {
        this.outModes.default = value;
    }
    get noise() {
        return this.path;
    }
    set noise(value) {
        this.path = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        if (data.angle !== undefined) {
            if (typeof data.angle === "number") {
                this.angle.value = data.angle;
            }
            else {
                this.angle.load(data.angle);
            }
        }
        this.attract.load(data.attract);
        if (data.decay !== undefined) {
            this.decay = data.decay;
        }
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        if (data.distance !== undefined) {
            this.distance = data.distance;
        }
        if (data.drift !== undefined) {
            this.drift = Utils_1.NumberUtils.setRangeValue(data.drift);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        this.gravity.load(data.gravity);
        const outMode = (_a = data.outMode) !== null && _a !== void 0 ? _a : data.out_mode;
        if (data.outModes !== undefined || outMode !== undefined) {
            if (typeof data.outModes === "string" || (data.outModes === undefined && outMode !== undefined)) {
                this.outModes.load({
                    default: (_b = data.outModes) !== null && _b !== void 0 ? _b : outMode,
                });
            }
            else {
                this.outModes.load(data.outModes);
            }
        }
        this.path.load((_c = data.path) !== null && _c !== void 0 ? _c : data.noise);
        if (data.random !== undefined) {
            this.random = data.random;
        }
        if (data.size !== undefined) {
            this.size = data.size;
        }
        if (data.speed !== undefined) {
            this.speed = Utils_1.NumberUtils.setRangeValue(data.speed);
        }
        if (data.straight !== undefined) {
            this.straight = data.straight;
        }
        this.trail.load(data.trail);
        if (data.vibrate !== undefined) {
            this.vibrate = data.vibrate;
        }
        if (data.warp !== undefined) {
            this.warp = data.warp;
        }
    }
}
exports.Move = Move;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveAngle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveAngle.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveAngle = void 0;
class MoveAngle {
    constructor() {
        this.offset = 45;
        this.value = 90;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.offset !== undefined) {
            this.offset = data.offset;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.MoveAngle = MoveAngle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveGravity.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/MoveGravity.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveGravity = void 0;
class MoveGravity {
    constructor() {
        this.acceleration = 9.81;
        this.enable = false;
        this.maxSpeed = 50;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.acceleration !== undefined) {
            this.acceleration = data.acceleration;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.maxSpeed !== undefined) {
            this.maxSpeed = data.maxSpeed;
        }
    }
}
exports.MoveGravity = MoveGravity;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/OutModes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/OutModes.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OutModes = void 0;
const Modes_1 = __webpack_require__(/*! ../../../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class OutModes {
    constructor() {
        this.default = Modes_1.OutMode.out;
    }
    load(data) {
        var _a, _b, _c, _d;
        if (!data) {
            return;
        }
        if (data.default !== undefined) {
            this.default = data.default;
        }
        this.bottom = (_a = data.bottom) !== null && _a !== void 0 ? _a : data.default;
        this.left = (_b = data.left) !== null && _b !== void 0 ? _b : data.default;
        this.right = (_c = data.right) !== null && _c !== void 0 ? _c : data.default;
        this.top = (_d = data.top) !== null && _d !== void 0 ? _d : data.default;
    }
}
exports.OutModes = OutModes;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Path/Path.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Path/Path.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
const PathDelay_1 = __webpack_require__(/*! ./PathDelay */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Path/PathDelay.js");
class Path {
    constructor() {
        this.clamp = true;
        this.delay = new PathDelay_1.PathDelay();
        this.enable = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.clamp !== undefined) {
            this.clamp = data.clamp;
        }
        this.delay.load(data.delay);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        this.generator = data.generator;
    }
}
exports.Path = Path;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Path/PathDelay.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Path/PathDelay.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PathDelay = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class PathDelay extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
    }
}
exports.PathDelay = PathDelay;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Trail.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Trail.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Trail = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Trail {
    constructor() {
        this.enable = false;
        this.length = 10;
        this.fillColor = new OptionsColor_1.OptionsColor();
        this.fillColor.value = "#000000";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        this.fillColor = OptionsColor_1.OptionsColor.create(this.fillColor, data.fillColor);
        if (data.length !== undefined) {
            this.length = data.length;
        }
    }
}
exports.Trail = Trail;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/Density.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Number/Density.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Density = void 0;
class Density {
    constructor() {
        this.enable = false;
        this.area = 800;
        this.factor = 1000;
    }
    get value_area() {
        return this.area;
    }
    set value_area(value) {
        this.area = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const area = (_a = data.area) !== null && _a !== void 0 ? _a : data.value_area;
        if (area !== undefined) {
            this.area = area;
        }
        if (data.factor !== undefined) {
            this.factor = data.factor;
        }
    }
}
exports.Density = Density;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/ParticlesNumber.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Number/ParticlesNumber.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticlesNumber = void 0;
const Density_1 = __webpack_require__(/*! ./Density */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/Density.js");
class ParticlesNumber {
    constructor() {
        this.density = new Density_1.Density();
        this.limit = 0;
        this.value = 100;
    }
    get max() {
        return this.limit;
    }
    set max(value) {
        this.limit = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        this.density.load(data.density);
        const limit = (_a = data.limit) !== null && _a !== void 0 ? _a : data.max;
        if (limit !== undefined) {
            this.limit = limit;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.ParticlesNumber = ParticlesNumber;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/Opacity.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/Opacity.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Opacity = void 0;
const OpacityAnimation_1 = __webpack_require__(/*! ./OpacityAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/OpacityAnimation.js");
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Opacity extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.animation = new OpacityAnimation_1.OpacityAnimation();
        this.random.minimumValue = 0.1;
        this.value = 1;
    }
    get anim() {
        return this.animation;
    }
    set anim(value) {
        this.animation = value;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        super.load(data);
        const animation = (_a = data.animation) !== null && _a !== void 0 ? _a : data.anim;
        if (animation !== undefined) {
            this.animation.load(animation);
            this.value = Utils_1.NumberUtils.setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : undefined);
        }
    }
}
exports.Opacity = Opacity;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/OpacityAnimation.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/OpacityAnimation.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OpacityAnimation = void 0;
const Types_1 = __webpack_require__(/*! ../../../../Enums/Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js");
const AnimationOptions_1 = __webpack_require__(/*! ../../AnimationOptions */ "./node_modules/tsparticles/dist/Options/Classes/AnimationOptions.js");
class OpacityAnimation extends AnimationOptions_1.AnimationOptions {
    constructor() {
        super();
        this.destroy = Types_1.DestroyType.none;
        this.enable = false;
        this.minimumValue = 0;
        this.speed = 2;
        this.startValue = Types_1.StartValueType.random;
        this.sync = false;
    }
    get opacity_min() {
        return this.minimumValue;
    }
    set opacity_min(value) {
        this.minimumValue = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        super.load(data);
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const minimumValue = (_a = data.minimumValue) !== null && _a !== void 0 ? _a : data.opacity_min;
        if (minimumValue !== undefined) {
            this.minimumValue = minimumValue;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.startValue !== undefined) {
            this.startValue = data.startValue;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.OpacityAnimation = OpacityAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/ParticlesOptions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/ParticlesOptions.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticlesOptions = void 0;
const Links_1 = __webpack_require__(/*! ./Links/Links */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Links/Links.js");
const Move_1 = __webpack_require__(/*! ./Move/Move */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Move/Move.js");
const ParticlesNumber_1 = __webpack_require__(/*! ./Number/ParticlesNumber */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Number/ParticlesNumber.js");
const Opacity_1 = __webpack_require__(/*! ./Opacity/Opacity */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Opacity/Opacity.js");
const Shape_1 = __webpack_require__(/*! ./Shape/Shape */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js");
const Size_1 = __webpack_require__(/*! ./Size/Size */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/Size.js");
const Rotate_1 = __webpack_require__(/*! ./Rotate/Rotate */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/Rotate.js");
const Shadow_1 = __webpack_require__(/*! ./Shadow */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shadow.js");
const Stroke_1 = __webpack_require__(/*! ./Stroke */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Stroke.js");
const Collisions_1 = __webpack_require__(/*! ./Collisions/Collisions */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Collisions/Collisions.js");
const Twinkle_1 = __webpack_require__(/*! ./Twinkle/Twinkle */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/Twinkle.js");
const AnimatableColor_1 = __webpack_require__(/*! ./AnimatableColor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js");
const Life_1 = __webpack_require__(/*! ./Life/Life */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Life/Life.js");
const Bounce_1 = __webpack_require__(/*! ./Bounce/Bounce */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Bounce/Bounce.js");
const Destroy_1 = __webpack_require__(/*! ./Destroy/Destroy */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Destroy/Destroy.js");
class ParticlesOptions {
    constructor() {
        this.bounce = new Bounce_1.Bounce();
        this.collisions = new Collisions_1.Collisions();
        this.color = new AnimatableColor_1.AnimatableColor();
        this.destroy = new Destroy_1.Destroy();
        this.life = new Life_1.Life();
        this.links = new Links_1.Links();
        this.move = new Move_1.Move();
        this.number = new ParticlesNumber_1.ParticlesNumber();
        this.opacity = new Opacity_1.Opacity();
        this.reduceDuplicates = false;
        this.rotate = new Rotate_1.Rotate();
        this.shadow = new Shadow_1.Shadow();
        this.shape = new Shape_1.Shape();
        this.size = new Size_1.Size();
        this.stroke = new Stroke_1.Stroke();
        this.twinkle = new Twinkle_1.Twinkle();
    }
    get line_linked() {
        return this.links;
    }
    set line_linked(value) {
        this.links = value;
    }
    get lineLinked() {
        return this.links;
    }
    set lineLinked(value) {
        this.links = value;
    }
    load(data) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (data === undefined) {
            return;
        }
        this.bounce.load(data.bounce);
        this.color = AnimatableColor_1.AnimatableColor.create(this.color, data.color);
        this.destroy.load(data.destroy);
        this.life.load(data.life);
        const links = (_b = (_a = data.links) !== null && _a !== void 0 ? _a : data.lineLinked) !== null && _b !== void 0 ? _b : data.line_linked;
        if (links !== undefined) {
            this.links.load(links);
        }
        this.move.load(data.move);
        this.number.load(data.number);
        this.opacity.load(data.opacity);
        if (data.reduceDuplicates !== undefined) {
            this.reduceDuplicates = data.reduceDuplicates;
        }
        this.rotate.load(data.rotate);
        this.shape.load(data.shape);
        this.size.load(data.size);
        this.shadow.load(data.shadow);
        this.twinkle.load(data.twinkle);
        const collisions = (_d = (_c = data.move) === null || _c === void 0 ? void 0 : _c.collisions) !== null && _d !== void 0 ? _d : (_e = data.move) === null || _e === void 0 ? void 0 : _e.bounce;
        if (collisions !== undefined) {
            this.collisions.enable = collisions;
        }
        this.collisions.load(data.collisions);
        const strokeToLoad = (_f = data.stroke) !== null && _f !== void 0 ? _f : (_g = data.shape) === null || _g === void 0 ? void 0 : _g.stroke;
        if (strokeToLoad === undefined) {
            return;
        }
        if (strokeToLoad instanceof Array) {
            this.stroke = strokeToLoad.map((s) => {
                const tmp = new Stroke_1.Stroke();
                tmp.load(s);
                return tmp;
            });
        }
        else {
            if (this.stroke instanceof Array) {
                this.stroke = new Stroke_1.Stroke();
            }
            this.stroke.load(strokeToLoad);
        }
    }
}
exports.ParticlesOptions = ParticlesOptions;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/Rotate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/Rotate.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rotate = void 0;
const RotateAnimation_1 = __webpack_require__(/*! ./RotateAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/RotateAnimation.js");
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class Rotate extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.animation = new RotateAnimation_1.RotateAnimation();
        this.direction = Enums_1.RotateDirection.clockwise;
        this.path = false;
        this.value = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        this.animation.load(data.animation);
        if (data.path !== undefined) {
            this.path = data.path;
        }
    }
}
exports.Rotate = Rotate;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/RotateAnimation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Rotate/RotateAnimation.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateAnimation = void 0;
class RotateAnimation {
    constructor() {
        this.enable = false;
        this.speed = 0;
        this.sync = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.RotateAnimation = RotateAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shadow.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Shadow.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Shadow = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Shadow {
    constructor() {
        this.blur = 0;
        this.color = new OptionsColor_1.OptionsColor();
        this.enable = false;
        this.offset = {
            x: 0,
            y: 0,
        };
        this.color.value = "#000000";
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.blur !== undefined) {
            this.blur = data.blur;
        }
        this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.offset === undefined) {
            return;
        }
        if (data.offset.x !== undefined) {
            this.offset.x = data.offset.x;
        }
        if (data.offset.y !== undefined) {
            this.offset.y = data.offset.y;
        }
    }
}
exports.Shadow = Shadow;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Shape/Shape.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Shape = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Shape {
    constructor() {
        this.options = {};
        this.type = Enums_1.ShapeType.circle;
    }
    get image() {
        var _a;
        return ((_a = this.options[Enums_1.ShapeType.image]) !== null && _a !== void 0 ? _a : this.options[Enums_1.ShapeType.images]);
    }
    set image(value) {
        this.options[Enums_1.ShapeType.image] = value;
        this.options[Enums_1.ShapeType.images] = value;
    }
    get custom() {
        return this.options;
    }
    set custom(value) {
        this.options = value;
    }
    get images() {
        return this.image instanceof Array ? this.image : [this.image];
    }
    set images(value) {
        this.image = value;
    }
    get stroke() {
        return [];
    }
    set stroke(_value) {
    }
    get character() {
        var _a;
        return ((_a = this.options[Enums_1.ShapeType.character]) !== null && _a !== void 0 ? _a : this.options[Enums_1.ShapeType.char]);
    }
    set character(value) {
        this.options[Enums_1.ShapeType.character] = value;
        this.options[Enums_1.ShapeType.char] = value;
    }
    get polygon() {
        var _a;
        return ((_a = this.options[Enums_1.ShapeType.polygon]) !== null && _a !== void 0 ? _a : this.options[Enums_1.ShapeType.star]);
    }
    set polygon(value) {
        this.options[Enums_1.ShapeType.polygon] = value;
        this.options[Enums_1.ShapeType.star] = value;
    }
    load(data) {
        var _a, _b, _c;
        if (data === undefined) {
            return;
        }
        const options = (_a = data.options) !== null && _a !== void 0 ? _a : data.custom;
        if (options !== undefined) {
            for (const shape in options) {
                const item = options[shape];
                if (item !== undefined) {
                    this.options[shape] = Utils_1.Utils.deepExtend((_b = this.options[shape]) !== null && _b !== void 0 ? _b : {}, item);
                }
            }
        }
        this.loadShape(data.character, Enums_1.ShapeType.character, Enums_1.ShapeType.char, true);
        this.loadShape(data.polygon, Enums_1.ShapeType.polygon, Enums_1.ShapeType.star, false);
        this.loadShape((_c = data.image) !== null && _c !== void 0 ? _c : data.images, Enums_1.ShapeType.image, Enums_1.ShapeType.images, true);
        if (data.type !== undefined) {
            this.type = data.type;
        }
    }
    loadShape(item, mainKey, altKey, altOverride) {
        var _a, _b, _c, _d;
        if (item === undefined) {
            return;
        }
        if (item instanceof Array) {
            if (!(this.options[mainKey] instanceof Array)) {
                this.options[mainKey] = [];
                if (!this.options[altKey] || altOverride) {
                    this.options[altKey] = [];
                }
            }
            this.options[mainKey] = Utils_1.Utils.deepExtend((_a = this.options[mainKey]) !== null && _a !== void 0 ? _a : [], item);
            if (!this.options[altKey] || altOverride) {
                this.options[altKey] = Utils_1.Utils.deepExtend((_b = this.options[altKey]) !== null && _b !== void 0 ? _b : [], item);
            }
        }
        else {
            if (this.options[mainKey] instanceof Array) {
                this.options[mainKey] = {};
                if (!this.options[altKey] || altOverride) {
                    this.options[altKey] = {};
                }
            }
            this.options[mainKey] = Utils_1.Utils.deepExtend((_c = this.options[mainKey]) !== null && _c !== void 0 ? _c : {}, item);
            if (!this.options[altKey] || altOverride) {
                this.options[altKey] = Utils_1.Utils.deepExtend((_d = this.options[altKey]) !== null && _d !== void 0 ? _d : {}, item);
            }
        }
    }
}
exports.Shape = Shape;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/Size.js":
/*!******************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Size/Size.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Size = void 0;
const SizeAnimation_1 = __webpack_require__(/*! ./SizeAnimation */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/SizeAnimation.js");
const ValueWithRandom_1 = __webpack_require__(/*! ../../ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Size extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.animation = new SizeAnimation_1.SizeAnimation();
        this.random.minimumValue = 1;
        this.value = 3;
    }
    get anim() {
        return this.animation;
    }
    set anim(value) {
        this.animation = value;
    }
    load(data) {
        var _a;
        if (!data) {
            return;
        }
        super.load(data);
        const animation = (_a = data.animation) !== null && _a !== void 0 ? _a : data.anim;
        if (animation !== undefined) {
            this.animation.load(animation);
            this.value = Utils_1.NumberUtils.setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : undefined);
        }
    }
}
exports.Size = Size;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Size/SizeAnimation.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Size/SizeAnimation.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SizeAnimation = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const AnimationOptions_1 = __webpack_require__(/*! ../../AnimationOptions */ "./node_modules/tsparticles/dist/Options/Classes/AnimationOptions.js");
class SizeAnimation extends AnimationOptions_1.AnimationOptions {
    constructor() {
        super();
        this.destroy = Enums_1.DestroyType.none;
        this.enable = false;
        this.minimumValue = 0;
        this.speed = 5;
        this.startValue = Enums_1.StartValueType.random;
        this.sync = false;
    }
    get size_min() {
        return this.minimumValue;
    }
    set size_min(value) {
        this.minimumValue = value;
    }
    load(data) {
        var _a;
        if (data === undefined) {
            return;
        }
        super.load(data);
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        const minimumValue = (_a = data.minimumValue) !== null && _a !== void 0 ? _a : data.size_min;
        if (minimumValue !== undefined) {
            this.minimumValue = minimumValue;
        }
        if (data.speed !== undefined) {
            this.speed = data.speed;
        }
        if (data.startValue !== undefined) {
            this.startValue = data.startValue;
        }
        if (data.sync !== undefined) {
            this.sync = data.sync;
        }
    }
}
exports.SizeAnimation = SizeAnimation;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Stroke.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Stroke.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stroke = void 0;
const AnimatableColor_1 = __webpack_require__(/*! ./AnimatableColor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js");
class Stroke {
    constructor() {
        this.width = 0;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = AnimatableColor_1.AnimatableColor.create(this.color, data.color);
        }
        if (data.width !== undefined) {
            this.width = data.width;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.Stroke = Stroke;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/Twinkle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/Twinkle.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Twinkle = void 0;
const TwinkleValues_1 = __webpack_require__(/*! ./TwinkleValues */ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/TwinkleValues.js");
class Twinkle {
    constructor() {
        this.lines = new TwinkleValues_1.TwinkleValues();
        this.particles = new TwinkleValues_1.TwinkleValues();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        this.lines.load(data.lines);
        this.particles.load(data.particles);
    }
}
exports.Twinkle = Twinkle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/TwinkleValues.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Particles/Twinkle/TwinkleValues.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TwinkleValues = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class TwinkleValues {
    constructor() {
        this.enable = false;
        this.frequency = 0.05;
        this.opacity = 1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.frequency !== undefined) {
            this.frequency = data.frequency;
        }
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
    }
}
exports.TwinkleValues = TwinkleValues;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Random.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Random.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Random = void 0;
class Random {
    constructor() {
        this.enable = false;
        this.minimumValue = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.enable !== undefined) {
            this.enable = data.enable;
        }
        if (data.minimumValue !== undefined) {
            this.minimumValue = data.minimumValue;
        }
    }
}
exports.Random = Random;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Responsive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Responsive.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Responsive = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class Responsive {
    constructor() {
        this.maxWidth = Infinity;
        this.options = {};
    }
    load(data) {
        if (!data) {
            return;
        }
        if (data.maxWidth !== undefined) {
            this.maxWidth = data.maxWidth;
        }
        if (data.options !== undefined) {
            this.options = Utils_1.Utils.deepExtend({}, data.options);
        }
    }
}
exports.Responsive = Responsive;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Theme/Theme.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Theme/Theme.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Theme = void 0;
const Utils_1 = __webpack_require__(/*! ../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const ThemeDefault_1 = __webpack_require__(/*! ./ThemeDefault */ "./node_modules/tsparticles/dist/Options/Classes/Theme/ThemeDefault.js");
class Theme {
    constructor() {
        this.name = "";
        this.default = new ThemeDefault_1.ThemeDefault();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.name !== undefined) {
            this.name = data.name;
        }
        this.default.load(data.default);
        if (data.options !== undefined) {
            this.options = Utils_1.Utils.deepExtend({}, data.options);
        }
    }
}
exports.Theme = Theme;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/Theme/ThemeDefault.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/Theme/ThemeDefault.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ThemeDefault = void 0;
const Modes_1 = __webpack_require__(/*! ../../../Enums/Modes */ "./node_modules/tsparticles/dist/Enums/Modes/index.js");
class ThemeDefault {
    constructor() {
        this.mode = Modes_1.ThemeMode.any;
        this.value = false;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.value !== undefined) {
            this.value = data.value;
        }
    }
}
exports.ThemeDefault = ThemeDefault;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueWithRandom = void 0;
const Random_1 = __webpack_require__(/*! ./Random */ "./node_modules/tsparticles/dist/Options/Classes/Random.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class ValueWithRandom {
    constructor() {
        this.random = new Random_1.Random();
        this.value = 0;
    }
    load(data) {
        if (!data) {
            return;
        }
        if (typeof data.random === "boolean") {
            this.random.enable = data.random;
        }
        else {
            this.random.load(data.random);
        }
        if (data.value !== undefined) {
            this.value = Utils_1.NumberUtils.setRangeValue(data.value, this.random.enable ? this.random.minimumValue : undefined);
        }
    }
}
exports.ValueWithRandom = ValueWithRandom;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorberInstance.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorberInstance.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorberInstance = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Vector_1 = __webpack_require__(/*! ../../Core/Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js");
class AbsorberInstance {
    constructor(absorbers, container, options, position) {
        var _a, _b, _c;
        this.absorbers = absorbers;
        this.container = container;
        this.initialPosition = position ? Vector_1.Vector.create(position.x, position.y) : undefined;
        this.options = options;
        this.dragging = false;
        this.name = this.options.name;
        this.opacity = this.options.opacity;
        this.size = Utils_1.NumberUtils.getValue(options.size) * container.retina.pixelRatio;
        this.mass = this.size * options.size.density * container.retina.reduceFactor;
        const limit = options.size.limit;
        this.limit = limit !== undefined ? limit * container.retina.pixelRatio * container.retina.reduceFactor : limit;
        const color = typeof options.color === "string" ? { value: options.color } : options.color;
        this.color = (_a = Utils_1.ColorUtils.colorToRgb(color)) !== null && _a !== void 0 ? _a : {
            b: 0,
            g: 0,
            r: 0,
        };
        this.position = (_c = (_b = this.initialPosition) === null || _b === void 0 ? void 0 : _b.copy()) !== null && _c !== void 0 ? _c : this.calcPosition();
    }
    attract(particle) {
        const options = this.options;
        if (options.draggable) {
            const mouse = this.container.interactivity.mouse;
            if (mouse.clicking && mouse.downPosition) {
                const mouseDist = Utils_1.NumberUtils.getDistance(this.position, mouse.downPosition);
                if (mouseDist <= this.size) {
                    this.dragging = true;
                }
            }
            else {
                this.dragging = false;
            }
            if (this.dragging && mouse.position) {
                this.position.x = mouse.position.x;
                this.position.y = mouse.position.y;
            }
        }
        const pos = particle.getPosition();
        const { dx, dy, distance } = Utils_1.NumberUtils.getDistances(this.position, pos);
        const v = Vector_1.Vector.create(dx, dy);
        v.length = (this.mass / Math.pow(distance, 2)) * this.container.retina.reduceFactor;
        if (distance < this.size + particle.getRadius()) {
            const sizeFactor = particle.getRadius() * 0.033 * this.container.retina.pixelRatio;
            if (this.size > particle.getRadius() && distance < this.size - particle.getRadius()) {
                if (options.destroy) {
                    particle.destroy();
                }
                else {
                    particle.needsNewPosition = true;
                    this.updateParticlePosition(particle, v);
                }
            }
            else {
                if (options.destroy) {
                    particle.size.value -= sizeFactor;
                }
                this.updateParticlePosition(particle, v);
            }
            if (this.limit === undefined || this.size < this.limit) {
                this.size += sizeFactor;
            }
            this.mass += sizeFactor * this.options.size.density * this.container.retina.reduceFactor;
        }
        else {
            this.updateParticlePosition(particle, v);
        }
    }
    resize() {
        const initialPosition = this.initialPosition;
        this.position =
            initialPosition && Utils_1.Utils.isPointInside(initialPosition, this.container.canvas.size)
                ? initialPosition
                : this.calcPosition();
    }
    draw(context) {
        context.translate(this.position.x, this.position.y);
        context.beginPath();
        context.arc(0, 0, this.size, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStyle = Utils_1.ColorUtils.getStyleFromRgb(this.color, this.opacity);
        context.fill();
    }
    calcPosition() {
        var _a, _b;
        const container = this.container;
        const percentPosition = this.options.position;
        return Vector_1.Vector.create((((_a = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.x) !== null && _a !== void 0 ? _a : Math.random() * 100) / 100) * container.canvas.size.width, (((_b = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.y) !== null && _b !== void 0 ? _b : Math.random() * 100) / 100) * container.canvas.size.height);
    }
    updateParticlePosition(particle, v) {
        var _a;
        if (particle.destroyed) {
            return;
        }
        const canvasSize = this.container.canvas.size;
        if (particle.needsNewPosition) {
            const pSize = particle.getRadius();
            particle.position.x = Math.random() * (canvasSize.width - pSize * 2) + pSize;
            particle.position.y = Math.random() * (canvasSize.height - pSize * 2) + pSize;
            particle.needsNewPosition = false;
        }
        if (this.options.orbits) {
            if (particle.orbit === undefined) {
                particle.orbit = Vector_1.Vector.create(0, 0);
                particle.orbit.length = Utils_1.NumberUtils.getDistance(particle.getPosition(), this.position);
                particle.orbit.angle = Math.random() * Math.PI * 2;
            }
            if (particle.orbit.length <= this.size && !this.options.destroy) {
                particle.orbit.length = Math.random() * Math.max(canvasSize.width, canvasSize.height);
            }
            particle.velocity.x = 0;
            particle.velocity.y = 0;
            particle.position.setTo(particle.orbit.add(this.position));
            particle.orbit.length -= v.length;
            particle.orbit.angle +=
                (((_a = particle.moveSpeed) !== null && _a !== void 0 ? _a : Utils_1.NumberUtils.getRangeValue(particle.options.move.speed) * this.container.retina.pixelRatio) /
                    100) *
                    this.container.retina.reduceFactor;
        }
        else {
            particle.velocity.addTo(v);
        }
    }
}
exports.AbsorberInstance = AbsorberInstance;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Absorbers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Absorbers.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Absorbers = void 0;
const AbsorberInstance_1 = __webpack_require__(/*! ./AbsorberInstance */ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorberInstance.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Absorber_1 = __webpack_require__(/*! ./Options/Classes/Absorber */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js");
class Absorbers {
    constructor(container) {
        this.container = container;
        this.array = [];
        this.absorbers = [];
        this.interactivityAbsorbers = [];
        const overridableContainer = container;
        overridableContainer.addAbsorber = (options, position) => this.addAbsorber(options, position);
    }
    init(options) {
        var _a, _b;
        if (!options) {
            return;
        }
        if (options.absorbers) {
            if (options.absorbers instanceof Array) {
                this.absorbers = options.absorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.absorbers instanceof Array) {
                    this.absorbers = new Absorber_1.Absorber();
                }
                this.absorbers.load(options.absorbers);
            }
        }
        const interactivityAbsorbers = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.absorbers;
        if (interactivityAbsorbers) {
            if (interactivityAbsorbers instanceof Array) {
                this.interactivityAbsorbers = interactivityAbsorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.interactivityAbsorbers instanceof Array) {
                    this.interactivityAbsorbers = new Absorber_1.Absorber();
                }
                this.interactivityAbsorbers.load(interactivityAbsorbers);
            }
        }
        if (this.absorbers instanceof Array) {
            for (const absorberOptions of this.absorbers) {
                this.addAbsorber(absorberOptions);
            }
        }
        else {
            this.addAbsorber(this.absorbers);
        }
    }
    particleUpdate(particle) {
        for (const absorber of this.array) {
            absorber.attract(particle);
            if (particle.destroyed) {
                break;
            }
        }
    }
    draw(context) {
        for (const absorber of this.array) {
            context.save();
            absorber.draw(context);
            context.restore();
        }
    }
    stop() {
        this.array = [];
    }
    resize() {
        for (const absorber of this.array) {
            absorber.resize();
        }
    }
    handleClickMode(mode) {
        const container = this.container;
        const absorberOptions = this.absorbers;
        const modeAbsorbers = this.interactivityAbsorbers;
        if (mode === Enums_1.AbsorberClickMode.absorber) {
            let absorbersModeOptions;
            if (modeAbsorbers instanceof Array) {
                if (modeAbsorbers.length > 0) {
                    absorbersModeOptions = Utils_1.Utils.itemFromArray(modeAbsorbers);
                }
            }
            else {
                absorbersModeOptions = modeAbsorbers;
            }
            const absorbersOptions = absorbersModeOptions !== null && absorbersModeOptions !== void 0 ? absorbersModeOptions : (absorberOptions instanceof Array ? Utils_1.Utils.itemFromArray(absorberOptions) : absorberOptions);
            const aPosition = container.interactivity.mouse.clickPosition;
            this.addAbsorber(absorbersOptions, aPosition);
        }
    }
    addAbsorber(options, position) {
        const absorber = new AbsorberInstance_1.AbsorberInstance(this, this.container, options, position);
        this.array.push(absorber);
        return absorber;
    }
    removeAbsorber(absorber) {
        const index = this.array.indexOf(absorber);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
}
exports.Absorbers = Absorbers;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorbersPlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorbersPlugin.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorbersPlugin = void 0;
const Absorbers_1 = __webpack_require__(/*! ./Absorbers */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Absorbers.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js");
const Absorber_1 = __webpack_require__(/*! ./Options/Classes/Absorber */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js");
class AbsorbersPlugin {
    constructor() {
        this.id = "absorbers";
    }
    getPlugin(container) {
        return new Absorbers_1.Absorbers(container);
    }
    needsPlugin(options) {
        var _a, _b, _c;
        if (options === undefined) {
            return false;
        }
        const absorbers = options.absorbers;
        let loadAbsorbers = false;
        if (absorbers instanceof Array) {
            if (absorbers.length) {
                loadAbsorbers = true;
            }
        }
        else if (absorbers !== undefined) {
            loadAbsorbers = true;
        }
        else if (((_c = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onClick) === null || _c === void 0 ? void 0 : _c.mode) &&
            Utils_1.Utils.isInArray(Enums_1.AbsorberClickMode.absorber, options.interactivity.events.onClick.mode)) {
            loadAbsorbers = true;
        }
        return loadAbsorbers;
    }
    loadOptions(options, source) {
        var _a, _b;
        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
            return;
        }
        const optionsCast = options;
        if (source === null || source === void 0 ? void 0 : source.absorbers) {
            if ((source === null || source === void 0 ? void 0 : source.absorbers) instanceof Array) {
                optionsCast.absorbers = source === null || source === void 0 ? void 0 : source.absorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let absorberOptions = optionsCast.absorbers;
                if ((absorberOptions === null || absorberOptions === void 0 ? void 0 : absorberOptions.load) === undefined) {
                    optionsCast.absorbers = absorberOptions = new Absorber_1.Absorber();
                }
                absorberOptions.load(source === null || source === void 0 ? void 0 : source.absorbers);
            }
        }
        const interactivityAbsorbers = (_b = (_a = source === null || source === void 0 ? void 0 : source.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.absorbers;
        if (interactivityAbsorbers) {
            if (interactivityAbsorbers instanceof Array) {
                optionsCast.interactivity.modes.absorbers = interactivityAbsorbers.map((s) => {
                    const tmp = new Absorber_1.Absorber();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let absorberOptions = optionsCast.interactivity.modes.absorbers;
                if ((absorberOptions === null || absorberOptions === void 0 ? void 0 : absorberOptions.load) === undefined) {
                    optionsCast.interactivity.modes.absorbers = absorberOptions = new Absorber_1.Absorber();
                }
                absorberOptions.load(interactivityAbsorbers);
            }
        }
    }
}
const plugin = new AbsorbersPlugin();
exports.AbsorbersPlugin = plugin;
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/AbsorberClickMode.js":
/*!************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/AbsorberClickMode.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorberClickMode = void 0;
var AbsorberClickMode;
(function (AbsorberClickMode) {
    AbsorberClickMode["absorber"] = "absorber";
})(AbsorberClickMode = exports.AbsorberClickMode || (exports.AbsorberClickMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./AbsorberClickMode */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/AbsorberClickMode.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/Absorber.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Absorber = void 0;
const AbsorberSize_1 = __webpack_require__(/*! ./AbsorberSize */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/AbsorberSize.js");
const OptionsColor_1 = __webpack_require__(/*! ../../../../Options/Classes/OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Absorber {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.color.value = "#000000";
        this.draggable = false;
        this.opacity = 1;
        this.destroy = true;
        this.orbits = false;
        this.size = new AbsorberSize_1.AbsorberSize();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.color !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
        }
        if (data.draggable !== undefined) {
            this.draggable = data.draggable;
        }
        this.name = data.name;
        if (data.opacity !== undefined) {
            this.opacity = data.opacity;
        }
        if (data.position !== undefined) {
            this.position = {
                x: data.position.x,
                y: data.position.y,
            };
        }
        if (data.size !== undefined) {
            this.size.load(data.size);
        }
        if (data.destroy !== undefined) {
            this.destroy = data.destroy;
        }
        if (data.orbits !== undefined) {
            this.orbits = data.orbits;
        }
    }
}
exports.Absorber = Absorber;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/AbsorberSize.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Absorbers/Options/Classes/AbsorberSize.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsorberSize = void 0;
const ValueWithRandom_1 = __webpack_require__(/*! ../../../../Options/Classes/ValueWithRandom */ "./node_modules/tsparticles/dist/Options/Classes/ValueWithRandom.js");
class AbsorberSize extends ValueWithRandom_1.ValueWithRandom {
    constructor() {
        super();
        this.density = 5;
        this.random.minimumValue = 1;
        this.value = 50;
    }
    load(data) {
        if (!data) {
            return;
        }
        super.load(data);
        if (data.density !== undefined) {
            this.density = data.density;
        }
        if (data.limit !== undefined) {
            this.limit = data.limit;
        }
        if (data.limit !== undefined) {
            this.limit = data.limit;
        }
    }
}
exports.AbsorberSize = AbsorberSize;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/EmitterInstance.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/EmitterInstance.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterInstance = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const EmitterSize_1 = __webpack_require__(/*! ./Options/Classes/EmitterSize */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js");
function randomCoordinate(position, offset) {
    return position + offset * (Math.random() - 0.5);
}
function randomPosition(position, offset) {
    return {
        x: randomCoordinate(position.x, offset.x),
        y: randomCoordinate(position.y, offset.y),
    };
}
class EmitterInstance {
    constructor(emitters, container, emitterOptions, position) {
        var _a, _b, _c, _d;
        this.emitters = emitters;
        this.container = container;
        this.firstSpawn = true;
        this.currentDuration = 0;
        this.currentEmitDelay = 0;
        this.currentSpawnDelay = 0;
        this.initialPosition = position;
        this.emitterOptions = Utils_1.Utils.deepExtend({}, emitterOptions);
        this.spawnDelay = (((_a = this.emitterOptions.life.delay) !== null && _a !== void 0 ? _a : 0) * 1000) / this.container.retina.reduceFactor;
        this.position = (_b = this.initialPosition) !== null && _b !== void 0 ? _b : this.calcPosition();
        this.name = emitterOptions.name;
        let particlesOptions = Utils_1.Utils.deepExtend({}, this.emitterOptions.particles);
        if (particlesOptions === undefined) {
            particlesOptions = {};
        }
        if (particlesOptions.move === undefined) {
            particlesOptions.move = {};
        }
        if (particlesOptions.move.direction === undefined) {
            particlesOptions.move.direction = this.emitterOptions.direction;
        }
        if (this.emitterOptions.spawnColor !== undefined) {
            this.spawnColor = Utils_1.ColorUtils.colorToHsl(this.emitterOptions.spawnColor);
        }
        this.paused = !this.emitterOptions.autoPlay;
        this.particlesOptions = particlesOptions;
        this.size =
            (_c = this.emitterOptions.size) !== null && _c !== void 0 ? _c : (() => {
                const size = new EmitterSize_1.EmitterSize();
                size.load({
                    height: 0,
                    mode: Enums_1.SizeMode.percent,
                    width: 0,
                });
                return size;
            })();
        this.lifeCount = (_d = this.emitterOptions.life.count) !== null && _d !== void 0 ? _d : -1;
        this.immortal = this.lifeCount <= 0;
        this.play();
    }
    externalPlay() {
        this.paused = false;
        this.play();
    }
    externalPause() {
        this.paused = true;
        this.pause();
    }
    play() {
        if (this.paused) {
            return;
        }
        if (this.container.retina.reduceFactor &&
            (this.lifeCount > 0 || this.immortal || !this.emitterOptions.life.count)) {
            if (this.emitDelay === undefined) {
                this.emitDelay = (1000 * this.emitterOptions.rate.delay) / this.container.retina.reduceFactor;
            }
            if (this.lifeCount > 0 || this.immortal) {
                this.prepareToDie();
            }
        }
    }
    pause() {
        if (this.paused) {
            return;
        }
        delete this.emitDelay;
    }
    resize() {
        const initialPosition = this.initialPosition;
        this.position =
            initialPosition && Utils_1.Utils.isPointInside(initialPosition, this.container.canvas.size)
                ? initialPosition
                : this.calcPosition();
    }
    update(delta) {
        var _a, _b, _c;
        if (this.paused) {
            return;
        }
        if (this.firstSpawn) {
            this.firstSpawn = false;
            this.currentSpawnDelay = (_a = this.spawnDelay) !== null && _a !== void 0 ? _a : 0;
            this.currentEmitDelay = (_b = this.emitDelay) !== null && _b !== void 0 ? _b : 0;
            delta.value = 0;
        }
        if (this.duration !== undefined) {
            this.currentDuration += delta.value;
            if (this.currentDuration >= this.duration) {
                this.pause();
                if (this.spawnDelay !== undefined) {
                    delete this.spawnDelay;
                }
                if (!this.immortal) {
                    this.lifeCount--;
                }
                if (this.lifeCount > 0 || this.immortal) {
                    this.position = this.calcPosition();
                    this.spawnDelay =
                        (((_c = this.emitterOptions.life.delay) !== null && _c !== void 0 ? _c : 0) * 1000) / this.container.retina.reduceFactor;
                }
                else {
                    this.destroy();
                }
                this.currentDuration -= this.duration;
                delete this.duration;
            }
        }
        if (this.spawnDelay !== undefined) {
            this.currentSpawnDelay += delta.value;
            if (this.currentSpawnDelay >= this.spawnDelay) {
                this.play();
                this.currentSpawnDelay -= this.currentSpawnDelay;
                delete this.spawnDelay;
            }
        }
        if (this.emitDelay !== undefined) {
            this.currentEmitDelay += delta.value;
            if (this.currentEmitDelay >= this.emitDelay) {
                this.emit();
                this.currentEmitDelay -= this.emitDelay;
            }
        }
    }
    prepareToDie() {
        var _a;
        if (this.paused) {
            return;
        }
        const duration = (_a = this.emitterOptions.life) === null || _a === void 0 ? void 0 : _a.duration;
        if (this.container.retina.reduceFactor &&
            (this.lifeCount > 0 || this.immortal) &&
            duration !== undefined &&
            duration > 0) {
            this.duration = duration * 1000;
        }
    }
    destroy() {
        this.emitters.removeEmitter(this);
    }
    calcPosition() {
        var _a, _b;
        const container = this.container;
        const percentPosition = this.emitterOptions.position;
        return {
            x: (((_a = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.x) !== null && _a !== void 0 ? _a : Math.random() * 100) / 100) * container.canvas.size.width,
            y: (((_b = percentPosition === null || percentPosition === void 0 ? void 0 : percentPosition.y) !== null && _b !== void 0 ? _b : Math.random() * 100) / 100) * container.canvas.size.height,
        };
    }
    emit() {
        var _a;
        if (this.paused) {
            return;
        }
        const container = this.container;
        const position = this.position;
        const offset = {
            x: this.size.mode === Enums_1.SizeMode.percent
                ? (container.canvas.size.width * this.size.width) / 100
                : this.size.width,
            y: this.size.mode === Enums_1.SizeMode.percent
                ? (container.canvas.size.height * this.size.height) / 100
                : this.size.height,
        };
        for (let i = 0; i < this.emitterOptions.rate.quantity; i++) {
            const particlesOptions = Utils_1.Utils.deepExtend({}, this.particlesOptions);
            if (this.spawnColor !== undefined) {
                const colorAnimation = (_a = this.emitterOptions.spawnColor) === null || _a === void 0 ? void 0 : _a.animation;
                if (colorAnimation) {
                    const hueAnimation = colorAnimation;
                    if (hueAnimation.enable) {
                        this.spawnColor.h = this.setColorAnimation(hueAnimation, this.spawnColor.h, 360);
                    }
                    else {
                        const hslAnimation = colorAnimation;
                        this.spawnColor.h = this.setColorAnimation(hslAnimation.h, this.spawnColor.h, 360);
                        this.spawnColor.s = this.setColorAnimation(hslAnimation.s, this.spawnColor.s, 100);
                        this.spawnColor.l = this.setColorAnimation(hslAnimation.l, this.spawnColor.l, 100);
                    }
                }
                if (!particlesOptions.color) {
                    particlesOptions.color = {
                        value: this.spawnColor,
                    };
                }
                else {
                    particlesOptions.color.value = this.spawnColor;
                }
            }
            container.particles.addParticle(randomPosition(position, offset), particlesOptions);
        }
    }
    setColorAnimation(animation, initValue, maxValue) {
        var _a;
        const container = this.container;
        if (!animation.enable) {
            return initValue;
        }
        const colorOffset = Utils_1.NumberUtils.randomInRange(animation.offset);
        const emitFactor = (1000 * this.emitterOptions.rate.delay) / container.retina.reduceFactor;
        const colorSpeed = (_a = animation.speed) !== null && _a !== void 0 ? _a : 0;
        return (initValue + (colorSpeed * container.fpsLimit) / emitFactor + colorOffset * 3.6) % maxValue;
    }
}
exports.EmitterInstance = EmitterInstance;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Emitters.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Emitters.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitters = void 0;
const EmitterInstance_1 = __webpack_require__(/*! ./EmitterInstance */ "./node_modules/tsparticles/dist/Plugins/Emitters/EmitterInstance.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Emitter_1 = __webpack_require__(/*! ./Options/Classes/Emitter */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js");
class Emitters {
    constructor(container) {
        this.container = container;
        this.array = [];
        this.emitters = [];
        this.interactivityEmitters = [];
        const overridableContainer = container;
        overridableContainer.addEmitter = (options, position) => this.addEmitter(options, position);
        overridableContainer.playEmitter = (idxOrName) => {
            const emitter = idxOrName === undefined || typeof idxOrName === "number"
                ? this.array[idxOrName || 0]
                : this.array.find((t) => t.name === idxOrName);
            if (emitter) {
                emitter.externalPlay();
            }
        };
        overridableContainer.pauseEmitter = (idxOrName) => {
            const emitter = idxOrName === undefined || typeof idxOrName === "number"
                ? this.array[idxOrName || 0]
                : this.array.find((t) => t.name === idxOrName);
            if (emitter) {
                emitter.externalPause();
            }
        };
    }
    init(options) {
        var _a, _b;
        if (!options) {
            return;
        }
        if (options.emitters) {
            if (options.emitters instanceof Array) {
                this.emitters = options.emitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.emitters instanceof Array) {
                    this.emitters = new Emitter_1.Emitter();
                }
                this.emitters.load(options.emitters);
            }
        }
        const interactivityEmitters = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.emitters;
        if (interactivityEmitters) {
            if (interactivityEmitters instanceof Array) {
                this.interactivityEmitters = interactivityEmitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                if (this.interactivityEmitters instanceof Array) {
                    this.interactivityEmitters = new Emitter_1.Emitter();
                }
                this.interactivityEmitters.load(interactivityEmitters);
            }
        }
        if (this.emitters instanceof Array) {
            for (const emitterOptions of this.emitters) {
                this.addEmitter(emitterOptions);
            }
        }
        else {
            this.addEmitter(this.emitters);
        }
    }
    play() {
        for (const emitter of this.array) {
            emitter.play();
        }
    }
    pause() {
        for (const emitter of this.array) {
            emitter.pause();
        }
    }
    stop() {
        this.array = [];
    }
    update(delta) {
        for (const emitter of this.array) {
            emitter.update(delta);
        }
    }
    handleClickMode(mode) {
        const container = this.container;
        const emitterOptions = this.emitters;
        const modeEmitters = this.interactivityEmitters;
        if (mode === Enums_1.EmitterClickMode.emitter) {
            let emitterModeOptions;
            if (modeEmitters instanceof Array) {
                if (modeEmitters.length > 0) {
                    emitterModeOptions = Utils_1.Utils.itemFromArray(modeEmitters);
                }
            }
            else {
                emitterModeOptions = modeEmitters;
            }
            const emittersOptions = emitterModeOptions !== null && emitterModeOptions !== void 0 ? emitterModeOptions : (emitterOptions instanceof Array ? Utils_1.Utils.itemFromArray(emitterOptions) : emitterOptions);
            const ePosition = container.interactivity.mouse.clickPosition;
            this.addEmitter(Utils_1.Utils.deepExtend({}, emittersOptions), ePosition);
        }
    }
    resize() {
        for (const emitter of this.array) {
            emitter.resize();
        }
    }
    addEmitter(options, position) {
        const emitter = new EmitterInstance_1.EmitterInstance(this, this.container, options, position);
        this.array.push(emitter);
        return emitter;
    }
    removeEmitter(emitter) {
        const index = this.array.indexOf(emitter);
        if (index >= 0) {
            this.array.splice(index, 1);
        }
    }
}
exports.Emitters = Emitters;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/EmittersPlugin.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/EmittersPlugin.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmittersPlugin = void 0;
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Emitters_1 = __webpack_require__(/*! ./Emitters */ "./node_modules/tsparticles/dist/Plugins/Emitters/Emitters.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js");
const Emitter_1 = __webpack_require__(/*! ./Options/Classes/Emitter */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js");
class EmittersPlugin {
    constructor() {
        this.id = "emitters";
    }
    getPlugin(container) {
        return new Emitters_1.Emitters(container);
    }
    needsPlugin(options) {
        var _a, _b, _c;
        if (options === undefined) {
            return false;
        }
        const emitters = options.emitters;
        let loadEmitters = false;
        if (emitters instanceof Array) {
            if (emitters.length) {
                loadEmitters = true;
            }
        }
        else if (emitters !== undefined) {
            loadEmitters = true;
        }
        else if (((_c = (_b = (_a = options.interactivity) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.onClick) === null || _c === void 0 ? void 0 : _c.mode) &&
            Utils_1.Utils.isInArray(Enums_1.EmitterClickMode.emitter, options.interactivity.events.onClick.mode)) {
            loadEmitters = true;
        }
        return loadEmitters;
    }
    loadOptions(options, source) {
        var _a, _b;
        if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
            return;
        }
        const optionsCast = options;
        if (source === null || source === void 0 ? void 0 : source.emitters) {
            if ((source === null || source === void 0 ? void 0 : source.emitters) instanceof Array) {
                optionsCast.emitters = source === null || source === void 0 ? void 0 : source.emitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let emitterOptions = optionsCast.emitters;
                if ((emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions.load) === undefined) {
                    optionsCast.emitters = emitterOptions = new Emitter_1.Emitter();
                }
                emitterOptions.load(source === null || source === void 0 ? void 0 : source.emitters);
            }
        }
        const interactivityEmitters = (_b = (_a = source === null || source === void 0 ? void 0 : source.interactivity) === null || _a === void 0 ? void 0 : _a.modes) === null || _b === void 0 ? void 0 : _b.emitters;
        if (interactivityEmitters) {
            if (interactivityEmitters instanceof Array) {
                optionsCast.interactivity.modes.emitters = interactivityEmitters.map((s) => {
                    const tmp = new Emitter_1.Emitter();
                    tmp.load(s);
                    return tmp;
                });
            }
            else {
                let emitterOptions = optionsCast.interactivity.modes.emitters;
                if ((emitterOptions === null || emitterOptions === void 0 ? void 0 : emitterOptions.load) === undefined) {
                    optionsCast.interactivity.modes.emitters = emitterOptions = new Emitter_1.Emitter();
                }
                emitterOptions.load(interactivityEmitters);
            }
        }
    }
}
const plugin = new EmittersPlugin();
exports.EmittersPlugin = plugin;
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/EmitterClickMode.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Enums/EmitterClickMode.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterClickMode = void 0;
var EmitterClickMode;
(function (EmitterClickMode) {
    EmitterClickMode["emitter"] = "emitter";
})(EmitterClickMode = exports.EmitterClickMode || (exports.EmitterClickMode = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./EmitterClickMode */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/EmitterClickMode.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/Emitter.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Emitter = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const EmitterRate_1 = __webpack_require__(/*! ./EmitterRate */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterRate.js");
const EmitterLife_1 = __webpack_require__(/*! ./EmitterLife */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterLife.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const EmitterSize_1 = __webpack_require__(/*! ./EmitterSize */ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js");
const AnimatableColor_1 = __webpack_require__(/*! ../../../../Options/Classes/Particles/AnimatableColor */ "./node_modules/tsparticles/dist/Options/Classes/Particles/AnimatableColor.js");
class Emitter {
    constructor() {
        this.autoPlay = true;
        this.direction = Enums_1.MoveDirection.none;
        this.life = new EmitterLife_1.EmitterLife();
        this.rate = new EmitterRate_1.EmitterRate();
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.autoPlay !== undefined) {
            this.autoPlay = data.autoPlay;
        }
        if (data.size !== undefined) {
            if (this.size === undefined) {
                this.size = new EmitterSize_1.EmitterSize();
            }
            this.size.load(data.size);
        }
        if (data.direction !== undefined) {
            this.direction = data.direction;
        }
        this.life.load(data.life);
        this.name = data.name;
        if (data.particles !== undefined) {
            this.particles = Utils_1.Utils.deepExtend({}, data.particles);
        }
        this.rate.load(data.rate);
        if (data.position !== undefined) {
            this.position = {
                x: data.position.x,
                y: data.position.y,
            };
        }
        if (data.spawnColor !== undefined) {
            if (this.spawnColor === undefined) {
                this.spawnColor = new AnimatableColor_1.AnimatableColor();
            }
            this.spawnColor.load(data.spawnColor);
        }
    }
}
exports.Emitter = Emitter;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterLife.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterLife.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterLife = void 0;
class EmitterLife {
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.count !== undefined) {
            this.count = data.count;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
        if (data.duration !== undefined) {
            this.duration = data.duration;
        }
    }
}
exports.EmitterLife = EmitterLife;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterRate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterRate.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterRate = void 0;
class EmitterRate {
    constructor() {
        this.quantity = 1;
        this.delay = 0.1;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.quantity !== undefined) {
            this.quantity = data.quantity;
        }
        if (data.delay !== undefined) {
            this.delay = data.delay;
        }
    }
}
exports.EmitterRate = EmitterRate;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/Emitters/Options/Classes/EmitterSize.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EmitterSize = void 0;
const Enums_1 = __webpack_require__(/*! ../../../../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class EmitterSize {
    constructor() {
        this.mode = Enums_1.SizeMode.percent;
        this.height = 0;
        this.width = 0;
    }
    load(data) {
        if (data === undefined) {
            return;
        }
        if (data.mode !== undefined) {
            this.mode = data.mode;
        }
        if (data.height !== undefined) {
            this.height = data.height;
        }
        if (data.width !== undefined) {
            this.width = data.width;
        }
    }
}
exports.EmitterSize = EmitterSize;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/InlineArrangement.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/InlineArrangement.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineArrangement = void 0;
var InlineArrangement;
(function (InlineArrangement) {
    InlineArrangement["equidistant"] = "equidistant";
    InlineArrangement["onePerPoint"] = "one-per-point";
    InlineArrangement["perPoint"] = "per-point";
    InlineArrangement["randomLength"] = "random-length";
    InlineArrangement["randomPoint"] = "random-point";
})(InlineArrangement = exports.InlineArrangement || (exports.InlineArrangement = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/MoveType.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/MoveType.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveType = void 0;
var MoveType;
(function (MoveType) {
    MoveType["path"] = "path";
    MoveType["radius"] = "radius";
})(MoveType = exports.MoveType || (exports.MoveType = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/Type.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/Type.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
var Type;
(function (Type) {
    Type["inline"] = "inline";
    Type["inside"] = "inside";
    Type["outside"] = "outside";
    Type["none"] = "none";
})(Type = exports.Type || (exports.Type = {}));


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./InlineArrangement */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/InlineArrangement.js"), exports);
__exportStar(__webpack_require__(/*! ./MoveType */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/MoveType.js"), exports);
__exportStar(__webpack_require__(/*! ./Type */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/Type.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Draw.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Draw.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Draw = void 0;
const DrawStroke_1 = __webpack_require__(/*! ./DrawStroke */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/DrawStroke.js");
const OptionsColor_1 = __webpack_require__(/*! ../../../../Options/Classes/OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
class Draw {
    constructor() {
        this.enable = false;
        this.stroke = new DrawStroke_1.DrawStroke();
    }
    get lineWidth() {
        return this.stroke.width;
    }
    set lineWidth(value) {
        this.stroke.width = value;
    }
    get lineColor() {
        return this.stroke.color;
    }
    set lineColor(value) {
        this.stroke.color = OptionsColor_1.OptionsColor.create(this.stroke.color, value);
    }
    load(data) {
        var _a;
        if (data !== undefined) {
            if (data.enable !== undefined) {
                this.enable = data.enable;
            }
            const stroke = (_a = data.stroke) !== null && _a !== void 0 ? _a : {
                color: data.lineColor,
                width: data.lineWidth,
            };
            this.stroke.load(stroke);
        }
    }
}
exports.Draw = Draw;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/DrawStroke.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/DrawStroke.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DrawStroke = void 0;
const OptionsColor_1 = __webpack_require__(/*! ../../../../Options/Classes/OptionsColor */ "./node_modules/tsparticles/dist/Options/Classes/OptionsColor.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class DrawStroke {
    constructor() {
        this.color = new OptionsColor_1.OptionsColor();
        this.width = 0.5;
        this.opacity = 1;
    }
    load(data) {
        var _a;
        if (data !== undefined) {
            this.color = OptionsColor_1.OptionsColor.create(this.color, data.color);
            if (typeof this.color.value === "string") {
                this.opacity = (_a = Utils_1.ColorUtils.stringToAlpha(this.color.value)) !== null && _a !== void 0 ? _a : this.opacity;
            }
            if (data.opacity !== undefined) {
                this.opacity = data.opacity;
            }
            if (data.width !== undefined) {
                this.width = data.width;
            }
        }
    }
}
exports.DrawStroke = DrawStroke;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Inline.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Inline.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Inline = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
class Inline {
    constructor() {
        this.arrangement = Enums_1.InlineArrangement.onePerPoint;
    }
    load(data) {
        if (data !== undefined) {
            if (data.arrangement !== undefined) {
                this.arrangement = data.arrangement;
            }
        }
    }
}
exports.Inline = Inline;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/LocalSvg.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/LocalSvg.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSvg = void 0;
class LocalSvg {
    constructor() {
        this.path = [];
        this.size = {
            height: 0,
            width: 0,
        };
    }
    load(data) {
        if (data !== undefined) {
            if (data.path !== undefined) {
                this.path = data.path;
            }
            if (data.size !== undefined) {
                if (data.size.width !== undefined) {
                    this.size.width = data.size.width;
                }
                if (data.size.height !== undefined) {
                    this.size.height = data.size.height;
                }
            }
        }
    }
}
exports.LocalSvg = LocalSvg;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Move.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Move.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Move = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
class Move {
    constructor() {
        this.radius = 10;
        this.type = Enums_1.MoveType.path;
    }
    load(data) {
        if (data !== undefined) {
            if (data.radius !== undefined) {
                this.radius = data.radius;
            }
            if (data.type !== undefined) {
                this.type = data.type;
            }
        }
    }
}
exports.Move = Move;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMask = void 0;
const Enums_1 = __webpack_require__(/*! ../../Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
const Draw_1 = __webpack_require__(/*! ./Draw */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Draw.js");
const Move_1 = __webpack_require__(/*! ./Move */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Move.js");
const Inline_1 = __webpack_require__(/*! ./Inline */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/Inline.js");
const LocalSvg_1 = __webpack_require__(/*! ./LocalSvg */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/LocalSvg.js");
const Utils_1 = __webpack_require__(/*! ../../../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
class PolygonMask {
    constructor() {
        this.draw = new Draw_1.Draw();
        this.enable = false;
        this.inline = new Inline_1.Inline();
        this.move = new Move_1.Move();
        this.scale = 1;
        this.type = Enums_1.Type.none;
    }
    get inlineArrangement() {
        return this.inline.arrangement;
    }
    set inlineArrangement(value) {
        this.inline.arrangement = value;
    }
    load(data) {
        var _a;
        if (data !== undefined) {
            this.draw.load(data.draw);
            const inline = (_a = data.inline) !== null && _a !== void 0 ? _a : {
                arrangement: data.inlineArrangement,
            };
            if (inline !== undefined) {
                this.inline.load(inline);
            }
            this.move.load(data.move);
            if (data.scale !== undefined) {
                this.scale = data.scale;
            }
            if (data.type !== undefined) {
                this.type = data.type;
            }
            if (data.enable !== undefined) {
                this.enable = data.enable;
            }
            else {
                this.enable = this.type !== Enums_1.Type.none;
            }
            if (data.url !== undefined) {
                this.url = data.url;
            }
            if (data.data !== undefined) {
                if (typeof data.data === "string") {
                    this.data = data.data;
                }
                else {
                    this.data = new LocalSvg_1.LocalSvg();
                    this.data.load(data.data);
                }
            }
            if (data.position !== undefined) {
                this.position = Utils_1.Utils.deepExtend({}, data.position);
            }
        }
    }
}
exports.PolygonMask = PolygonMask;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskInstance.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskInstance.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskInstance = void 0;
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
const Utils_1 = __webpack_require__(/*! ../../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const PolygonMask_1 = __webpack_require__(/*! ./Options/Classes/PolygonMask */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js");
function polygonBounce(particle) {
    particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;
    particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;
}
function drawPolygonMask(context, rawData, stroke) {
    const color = Utils_1.ColorUtils.colorToRgb(stroke.color);
    if (!color) {
        return;
    }
    context.beginPath();
    context.moveTo(rawData[0].x, rawData[0].y);
    for (const item of rawData) {
        context.lineTo(item.x, item.y);
    }
    context.closePath();
    context.strokeStyle = Utils_1.ColorUtils.getStyleFromRgb(color);
    context.lineWidth = stroke.width;
    context.stroke();
}
function drawPolygonMaskPath(context, path, stroke, position) {
    context.translate(position.x, position.y);
    const color = Utils_1.ColorUtils.colorToRgb(stroke.color);
    if (!color) {
        return;
    }
    context.strokeStyle = Utils_1.ColorUtils.getStyleFromRgb(color, stroke.opacity);
    context.lineWidth = stroke.width;
    context.stroke(path);
}
function parsePaths(paths, scale, offset) {
    const res = [];
    for (const path of paths) {
        const segments = path.element.pathSegList;
        const len = segments.numberOfItems;
        const p = {
            x: 0,
            y: 0,
        };
        for (let i = 0; i < len; i++) {
            const segment = segments.getItem(i);
            const svgPathSeg = window.SVGPathSeg;
            switch (segment.pathSegType) {
                case svgPathSeg.PATHSEG_MOVETO_ABS:
                case svgPathSeg.PATHSEG_LINETO_ABS:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                case svgPathSeg.PATHSEG_ARC_ABS:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {
                    const absSeg = segment;
                    p.x = absSeg.x;
                    p.y = absSeg.y;
                    break;
                }
                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                    p.x = segment.x;
                    break;
                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                    p.y = segment.y;
                    break;
                case svgPathSeg.PATHSEG_LINETO_REL:
                case svgPathSeg.PATHSEG_MOVETO_REL:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                case svgPathSeg.PATHSEG_ARC_REL:
                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {
                    const relSeg = segment;
                    p.x += relSeg.x;
                    p.y += relSeg.y;
                    break;
                }
                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                    p.x += segment.x;
                    break;
                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                    p.y += segment.y;
                    break;
                case svgPathSeg.PATHSEG_UNKNOWN:
                case svgPathSeg.PATHSEG_CLOSEPATH:
                    continue;
            }
            res.push({
                x: p.x * scale + offset.x,
                y: p.y * scale + offset.y,
            });
        }
    }
    return res;
}
class PolygonMaskInstance {
    constructor(container) {
        this.container = container;
        this.dimension = {
            height: 0,
            width: 0,
        };
        this.path2DSupported = !!window.Path2D;
        this.options = new PolygonMask_1.PolygonMask();
        this.polygonMaskMoveRadius = this.options.move.radius * container.retina.pixelRatio;
    }
    initAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.load(options === null || options === void 0 ? void 0 : options.polygon);
            const polygonMaskOptions = this.options;
            this.polygonMaskMoveRadius = polygonMaskOptions.move.radius * this.container.retina.pixelRatio;
            if (polygonMaskOptions.enable) {
                yield this.initRawData();
            }
        });
    }
    resize() {
        const container = this.container;
        const options = this.options;
        if (!(options.enable && options.type !== Enums_1.Type.none)) {
            return;
        }
        if (this.redrawTimeout) {
            clearTimeout(this.redrawTimeout);
        }
        this.redrawTimeout = window.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            yield this.initRawData(true);
            container.particles.redraw();
        }), 250);
    }
    stop() {
        delete this.raw;
        delete this.paths;
    }
    particlesInitialization() {
        const options = this.options;
        if (options.enable &&
            options.type === Enums_1.Type.inline &&
            (options.inline.arrangement === Enums_1.InlineArrangement.onePerPoint ||
                options.inline.arrangement === Enums_1.InlineArrangement.perPoint)) {
            this.drawPoints();
            return true;
        }
        return false;
    }
    particlePosition(position) {
        var _a, _b;
        const options = this.options;
        if (!(options.enable && ((_b = (_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0)) {
            return;
        }
        return Utils_1.Utils.deepExtend({}, position ? position : this.randomPoint());
    }
    particleBounce(particle) {
        const options = this.options;
        if (options.enable && options.type !== Enums_1.Type.none && options.type !== Enums_1.Type.inline) {
            if (!this.checkInsidePolygon(particle.getPosition())) {
                polygonBounce(particle);
                return true;
            }
        }
        else if (options.enable && options.type === Enums_1.Type.inline && particle.initialPosition) {
            const dist = Utils_1.NumberUtils.getDistance(particle.initialPosition, particle.getPosition());
            if (dist > this.polygonMaskMoveRadius) {
                polygonBounce(particle);
                return true;
            }
        }
        return false;
    }
    clickPositionValid(position) {
        const options = this.options;
        return (options.enable &&
            options.type !== Enums_1.Type.none &&
            options.type !== Enums_1.Type.inline &&
            this.checkInsidePolygon(position));
    }
    draw(context) {
        var _a;
        if (!((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
            return;
        }
        const options = this.options;
        const polygonDraw = options.draw;
        if (!(options.enable && polygonDraw.enable)) {
            return;
        }
        const rawData = this.raw;
        for (const path of this.paths) {
            const path2d = path.path2d;
            const path2dSupported = this.path2DSupported;
            if (!context) {
                continue;
            }
            if (path2dSupported && path2d && this.offset) {
                drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);
            }
            else if (rawData) {
                drawPolygonMask(context, rawData, polygonDraw.stroke);
            }
        }
    }
    checkInsidePolygon(position) {
        var _a, _b;
        const container = this.container;
        const options = this.options;
        if (!options.enable || options.type === Enums_1.Type.none || options.type === Enums_1.Type.inline) {
            return true;
        }
        if (!this.raw) {
            throw new Error(Utils_1.Constants.noPolygonFound);
        }
        const canvasSize = container.canvas.size;
        const x = (_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * canvasSize.width;
        const y = (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * canvasSize.height;
        let inside = false;
        for (let i = 0, j = this.raw.length - 1; i < this.raw.length; j = i++) {
            const pi = this.raw[i];
            const pj = this.raw[j];
            const intersect = pi.y > y !== pj.y > y && x < ((pj.x - pi.x) * (y - pi.y)) / (pj.y - pi.y) + pi.x;
            if (intersect) {
                inside = !inside;
            }
        }
        return options.type === Enums_1.Type.inside ? inside : options.type === Enums_1.Type.outside ? !inside : false;
    }
    parseSvgPath(xml, force) {
        var _a, _b, _c;
        const forceDownload = force !== null && force !== void 0 ? force : false;
        if (this.paths !== undefined && !forceDownload) {
            return this.raw;
        }
        const container = this.container;
        const options = this.options;
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, "image/svg+xml");
        const svg = doc.getElementsByTagName("svg")[0];
        let svgPaths = svg.getElementsByTagName("path");
        if (!svgPaths.length) {
            svgPaths = doc.getElementsByTagName("path");
        }
        this.paths = [];
        for (let i = 0; i < svgPaths.length; i++) {
            const path = svgPaths.item(i);
            if (path) {
                this.paths.push({
                    element: path,
                    length: path.getTotalLength(),
                });
            }
        }
        const pxRatio = container.retina.pixelRatio;
        const scale = options.scale / pxRatio;
        this.dimension.width = parseFloat((_a = svg.getAttribute("width")) !== null && _a !== void 0 ? _a : "0") * scale;
        this.dimension.height = parseFloat((_b = svg.getAttribute("height")) !== null && _b !== void 0 ? _b : "0") * scale;
        const position = (_c = options.position) !== null && _c !== void 0 ? _c : {
            x: 50,
            y: 50,
        };
        this.offset = {
            x: (container.canvas.size.width * position.x) / (100 * pxRatio) - this.dimension.width / 2,
            y: (container.canvas.size.height * position.y) / (100 * pxRatio) - this.dimension.height / 2,
        };
        return parsePaths(this.paths, scale, this.offset);
    }
    downloadSvgPath(svgUrl, force) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.options;
            const url = svgUrl || options.url;
            const forceDownload = force !== null && force !== void 0 ? force : false;
            if (!url || (this.paths !== undefined && !forceDownload)) {
                return this.raw;
            }
            const req = yield fetch(url);
            if (!req.ok) {
                throw new Error("tsParticles Error - Error occurred during polygon mask download");
            }
            return this.parseSvgPath(yield req.text(), force);
        });
    }
    drawPoints() {
        if (!this.raw) {
            return;
        }
        for (const item of this.raw) {
            this.container.particles.addParticle({
                x: item.x,
                y: item.y,
            });
        }
    }
    randomPoint() {
        const container = this.container;
        const options = this.options;
        let position;
        if (options.type === Enums_1.Type.inline) {
            switch (options.inline.arrangement) {
                case Enums_1.InlineArrangement.randomPoint:
                    position = this.getRandomPoint();
                    break;
                case Enums_1.InlineArrangement.randomLength:
                    position = this.getRandomPointByLength();
                    break;
                case Enums_1.InlineArrangement.equidistant:
                    position = this.getEquidistantPointByIndex(container.particles.count);
                    break;
                case Enums_1.InlineArrangement.onePerPoint:
                case Enums_1.InlineArrangement.perPoint:
                default:
                    position = this.getPointByIndex(container.particles.count);
            }
        }
        else {
            position = {
                x: Math.random() * container.canvas.size.width,
                y: Math.random() * container.canvas.size.height,
            };
        }
        if (this.checkInsidePolygon(position)) {
            return position;
        }
        else {
            return this.randomPoint();
        }
    }
    getRandomPoint() {
        if (!this.raw || !this.raw.length) {
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        }
        const coords = Utils_1.Utils.itemFromArray(this.raw);
        return {
            x: coords.x,
            y: coords.y,
        };
    }
    getRandomPointByLength() {
        var _a, _b, _c;
        const options = this.options;
        if (!this.raw || !this.raw.length || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        }
        const path = Utils_1.Utils.itemFromArray(this.paths);
        const distance = Math.floor(Math.random() * path.length) + 1;
        const point = path.element.getPointAtLength(distance);
        return {
            x: point.x * options.scale + (((_b = this.offset) === null || _b === void 0 ? void 0 : _b.x) || 0),
            y: point.y * options.scale + (((_c = this.offset) === null || _c === void 0 ? void 0 : _c.y) || 0),
        };
    }
    getEquidistantPointByIndex(index) {
        var _a, _b, _c, _d, _e, _f, _g;
        const options = this.container.actualOptions;
        const polygonMaskOptions = this.options;
        if (!this.raw || !this.raw.length || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length))
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        let offset = 0;
        let point;
        const totalLength = this.paths.reduce((tot, path) => tot + path.length, 0);
        const distance = totalLength / options.particles.number.value;
        for (const path of this.paths) {
            const pathDistance = distance * index - offset;
            if (pathDistance <= path.length) {
                point = path.element.getPointAtLength(pathDistance);
                break;
            }
            else {
                offset += path.length;
            }
        }
        return {
            x: ((_b = point === null || point === void 0 ? void 0 : point.x) !== null && _b !== void 0 ? _b : 0) * polygonMaskOptions.scale + ((_d = (_c = this.offset) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : 0),
            y: ((_e = point === null || point === void 0 ? void 0 : point.y) !== null && _e !== void 0 ? _e : 0) * polygonMaskOptions.scale + ((_g = (_f = this.offset) === null || _f === void 0 ? void 0 : _f.y) !== null && _g !== void 0 ? _g : 0),
        };
    }
    getPointByIndex(index) {
        if (!this.raw || !this.raw.length) {
            throw new Error(Utils_1.Constants.noPolygonDataLoaded);
        }
        const coords = this.raw[index % this.raw.length];
        return {
            x: coords.x,
            y: coords.y,
        };
    }
    createPath2D() {
        var _a, _b;
        const options = this.options;
        if (!this.path2DSupported || !((_a = this.paths) === null || _a === void 0 ? void 0 : _a.length)) {
            return;
        }
        for (const path of this.paths) {
            const pathData = (_b = path.element) === null || _b === void 0 ? void 0 : _b.getAttribute("d");
            if (pathData) {
                const path2d = new Path2D(pathData);
                const matrix = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
                const finalPath = new Path2D();
                const transform = matrix.scale(options.scale);
                if (finalPath.addPath) {
                    finalPath.addPath(path2d, transform);
                    path.path2d = finalPath;
                }
                else {
                    delete path.path2d;
                }
            }
            else {
                delete path.path2d;
            }
            if (path.path2d || !this.raw) {
                continue;
            }
            path.path2d = new Path2D();
            path.path2d.moveTo(this.raw[0].x, this.raw[0].y);
            this.raw.forEach((pos, i) => {
                var _a;
                if (i > 0) {
                    (_a = path.path2d) === null || _a === void 0 ? void 0 : _a.lineTo(pos.x, pos.y);
                }
            });
            path.path2d.closePath();
        }
    }
    initRawData(force) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.options;
            if (options.url) {
                this.raw = yield this.downloadSvgPath(options.url, force);
            }
            else if (options.data) {
                const data = options.data;
                let svg;
                if (typeof data !== "string") {
                    const path = data.path instanceof Array
                        ? data.path.map((t) => `<path d="${t}" />`).join("")
                        : `<path d="${data.path}" />`;
                    const namespaces = 'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"';
                    svg = `<svg ${namespaces} width="${data.size.width}" height="${data.size.height}">${path}</svg>`;
                }
                else {
                    svg = data;
                }
                this.raw = this.parseSvgPath(svg, force);
            }
            this.createPath2D();
        });
    }
}
exports.PolygonMaskInstance = PolygonMaskInstance;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js":
/*!********************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonMaskPlugin = void 0;
const PolygonMaskInstance_1 = __webpack_require__(/*! ./PolygonMaskInstance */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskInstance.js");
const PolygonMask_1 = __webpack_require__(/*! ./Options/Classes/PolygonMask */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Options/Classes/PolygonMask.js");
const Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js");
class PolygonMaskPlugin {
    constructor() {
        this.id = "polygonMask";
    }
    getPlugin(container) {
        return new PolygonMaskInstance_1.PolygonMaskInstance(container);
    }
    needsPlugin(options) {
        var _a, _b, _c;
        return (_b = (_a = options === null || options === void 0 ? void 0 : options.polygon) === null || _a === void 0 ? void 0 : _a.enable) !== null && _b !== void 0 ? _b : (((_c = options === null || options === void 0 ? void 0 : options.polygon) === null || _c === void 0 ? void 0 : _c.type) !== undefined && options.polygon.type !== Enums_1.Type.none);
    }
    loadOptions(options, source) {
        if (!this.needsPlugin(source)) {
            return;
        }
        const optionsCast = options;
        let polygonOptions = optionsCast.polygon;
        if ((polygonOptions === null || polygonOptions === void 0 ? void 0 : polygonOptions.load) === undefined) {
            optionsCast.polygon = polygonOptions = new PolygonMask_1.PolygonMask();
        }
        polygonOptions.load(source === null || source === void 0 ? void 0 : source.polygon);
    }
}
const plugin = new PolygonMaskPlugin();
exports.PolygonMaskPlugin = plugin;
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/CircleDrawer.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/CircleDrawer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CircleDrawer = void 0;
class CircleDrawer {
    getSidesCount() {
        return 12;
    }
    draw(context, particle, radius) {
        context.arc(0, 0, radius, 0, Math.PI * 2, false);
    }
}
exports.CircleDrawer = CircleDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/ImageDrawer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/ImageDrawer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageDrawer = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class ImageDrawer {
    constructor() {
        this.images = [];
    }
    getSidesCount() {
        return 12;
    }
    getImages(container) {
        const containerImages = this.images.filter((t) => t.id === container.id);
        if (!containerImages.length) {
            this.images.push({
                id: container.id,
                images: [],
            });
            return this.getImages(container);
        }
        return containerImages[0];
    }
    addImage(container, image) {
        const containerImages = this.getImages(container);
        containerImages === null || containerImages === void 0 ? void 0 : containerImages.images.push(image);
    }
    init(container) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const options = container.actualOptions;
            const shapeOptions = options.particles.shape;
            if (!Utils_1.Utils.isInArray(Enums_1.ShapeType.image, shapeOptions.type) &&
                !Utils_1.Utils.isInArray(Enums_1.ShapeType.images, shapeOptions.type)) {
                return;
            }
            const imageOptions = (_a = shapeOptions.options[Enums_1.ShapeType.images]) !== null && _a !== void 0 ? _a : shapeOptions.options[Enums_1.ShapeType.image];
            if (imageOptions instanceof Array) {
                for (const optionsImage of imageOptions) {
                    yield this.loadImageShape(container, optionsImage);
                }
            }
            else {
                yield this.loadImageShape(container, imageOptions);
            }
        });
    }
    destroy() {
        this.images = [];
    }
    loadImageShape(container, imageShape) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const image = imageShape.replaceColor
                    ? yield Utils_1.Utils.downloadSvgImage(imageShape.src)
                    : yield Utils_1.Utils.loadImage(imageShape.src);
                if (image) {
                    this.addImage(container, image);
                }
            }
            catch (_a) {
                console.warn(`tsParticles error - ${imageShape.src} not found`);
            }
        });
    }
    draw(context, particle, radius, opacity) {
        var _a, _b;
        if (!context) {
            return;
        }
        const image = particle.image;
        const element = (_a = image === null || image === void 0 ? void 0 : image.data) === null || _a === void 0 ? void 0 : _a.element;
        if (!element) {
            return;
        }
        const ratio = (_b = image === null || image === void 0 ? void 0 : image.ratio) !== null && _b !== void 0 ? _b : 1;
        const pos = {
            x: -radius,
            y: -radius,
        };
        if (!(image === null || image === void 0 ? void 0 : image.data.svgData) || !(image === null || image === void 0 ? void 0 : image.replaceColor)) {
            context.globalAlpha = opacity;
        }
        context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);
        if (!(image === null || image === void 0 ? void 0 : image.data.svgData) || !(image === null || image === void 0 ? void 0 : image.replaceColor)) {
            context.globalAlpha = 1;
        }
    }
}
exports.ImageDrawer = ImageDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/LineDrawer.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/LineDrawer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LineDrawer = void 0;
class LineDrawer {
    getSidesCount() {
        return 1;
    }
    draw(context, particle, radius) {
        context.moveTo(0, -radius / 2);
        context.lineTo(0, radius / 2);
    }
}
exports.LineDrawer = LineDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonDrawer = void 0;
const PolygonDrawerBase_1 = __webpack_require__(/*! ./PolygonDrawerBase */ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js");
class PolygonDrawer extends PolygonDrawerBase_1.PolygonDrawerBase {
    getSidesData(particle, radius) {
        var _a, _b;
        const polygon = particle.shapeData;
        const sides = (_b = (_a = polygon === null || polygon === void 0 ? void 0 : polygon.sides) !== null && _a !== void 0 ? _a : polygon === null || polygon === void 0 ? void 0 : polygon.nb_sides) !== null && _b !== void 0 ? _b : 5;
        return {
            count: {
                denominator: 1,
                numerator: sides,
            },
            length: (radius * 2.66) / (sides / 3),
        };
    }
    getCenter(particle, radius) {
        const sides = this.getSidesCount(particle);
        return {
            x: -radius / (sides / 3.5),
            y: -radius / (2.66 / 3.5),
        };
    }
}
exports.PolygonDrawer = PolygonDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonDrawerBase = void 0;
class PolygonDrawerBase {
    getSidesCount(particle) {
        var _a, _b;
        const polygon = particle.shapeData;
        return (_b = (_a = polygon === null || polygon === void 0 ? void 0 : polygon.sides) !== null && _a !== void 0 ? _a : polygon === null || polygon === void 0 ? void 0 : polygon.nb_sides) !== null && _b !== void 0 ? _b : 5;
    }
    draw(context, particle, radius) {
        const start = this.getCenter(particle, radius);
        const side = this.getSidesData(particle, radius);
        const sideCount = side.count.numerator * side.count.denominator;
        const decimalSides = side.count.numerator / side.count.denominator;
        const interiorAngleDegrees = (180 * (decimalSides - 2)) / decimalSides;
        const interiorAngle = Math.PI - (Math.PI * interiorAngleDegrees) / 180;
        if (!context) {
            return;
        }
        context.beginPath();
        context.translate(start.x, start.y);
        context.moveTo(0, 0);
        for (let i = 0; i < sideCount; i++) {
            context.lineTo(side.length, 0);
            context.translate(side.length, 0);
            context.rotate(interiorAngle);
        }
    }
}
exports.PolygonDrawerBase = PolygonDrawerBase;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/SquareDrawer.js":
/*!********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/SquareDrawer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SquareDrawer = void 0;
class SquareDrawer {
    getSidesCount() {
        return 4;
    }
    draw(context, particle, radius) {
        context.rect(-radius, -radius, radius * 2, radius * 2);
    }
}
exports.SquareDrawer = SquareDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/StarDrawer.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/StarDrawer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StarDrawer = void 0;
class StarDrawer {
    getSidesCount(particle) {
        var _a, _b;
        const star = particle.shapeData;
        return (_b = (_a = star === null || star === void 0 ? void 0 : star.sides) !== null && _a !== void 0 ? _a : star === null || star === void 0 ? void 0 : star.nb_sides) !== null && _b !== void 0 ? _b : 5;
    }
    draw(context, particle, radius) {
        var _a;
        const star = particle.shapeData;
        const sides = this.getSidesCount(particle);
        const inset = (_a = star === null || star === void 0 ? void 0 : star.inset) !== null && _a !== void 0 ? _a : 2;
        context.moveTo(0, 0 - radius);
        for (let i = 0; i < sides; i++) {
            context.rotate(Math.PI / sides);
            context.lineTo(0, 0 - radius * inset);
            context.rotate(Math.PI / sides);
            context.lineTo(0, 0 - radius);
        }
    }
}
exports.StarDrawer = StarDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/TextDrawer.js":
/*!******************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/TextDrawer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextDrawer = void 0;
const Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
class TextDrawer {
    getSidesCount() {
        return 12;
    }
    init(container) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const options = container.actualOptions;
            if (Utils_1.Utils.isInArray(Enums_1.ShapeType.char, options.particles.shape.type) ||
                Utils_1.Utils.isInArray(Enums_1.ShapeType.character, options.particles.shape.type)) {
                const shapeOptions = ((_a = options.particles.shape.options[Enums_1.ShapeType.character]) !== null && _a !== void 0 ? _a : options.particles.shape.options[Enums_1.ShapeType.char]);
                if (shapeOptions instanceof Array) {
                    for (const character of shapeOptions) {
                        yield Utils_1.Utils.loadFont(character);
                    }
                }
                else {
                    if (shapeOptions !== undefined) {
                        yield Utils_1.Utils.loadFont(shapeOptions);
                    }
                }
            }
        });
    }
    draw(context, particle, radius) {
        const character = particle.shapeData;
        if (character === undefined) {
            return;
        }
        const textData = character.value;
        if (textData === undefined) {
            return;
        }
        const textParticle = particle;
        if (textParticle.text === undefined) {
            textParticle.text =
                textData instanceof Array ? Utils_1.Utils.itemFromArray(textData, particle.randomIndexData) : textData;
        }
        const text = textParticle.text;
        const style = character.style;
        const weight = character.weight;
        const size = Math.round(radius) * 2;
        const font = character.font;
        const fill = particle.fill;
        const offsetX = (text.length * radius) / 2;
        context.font = `${style} ${weight} ${size}px "${font}"`;
        const pos = {
            x: -offsetX,
            y: radius / 2,
        };
        if (fill) {
            context.fillText(text, pos.x, pos.y);
        }
        else {
            context.strokeText(text, pos.x, pos.y);
        }
    }
}
exports.TextDrawer = TextDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/ShapeDrawers/TriangleDrawer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/ShapeDrawers/TriangleDrawer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TriangleDrawer = void 0;
const PolygonDrawerBase_1 = __webpack_require__(/*! ./PolygonDrawerBase */ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawerBase.js");
class TriangleDrawer extends PolygonDrawerBase_1.PolygonDrawerBase {
    getSidesCount() {
        return 3;
    }
    getSidesData(particle, radius) {
        return {
            count: {
                denominator: 2,
                numerator: 3,
            },
            length: radius * 2,
        };
    }
    getCenter(particle, radius) {
        return {
            x: -radius,
            y: radius / 1.66,
        };
    }
}
exports.TriangleDrawer = TriangleDrawer;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/RangeValue.js":
/*!***********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/RangeValue.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/RecursivePartial.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/RecursivePartial.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/ShapeData.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/ShapeData.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/ShapeDrawerFunctions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/ShapeDrawerFunctions.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/SingleOrMultiple.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/SingleOrMultiple.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/tsparticles/dist/Types/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Types/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./RangeValue */ "./node_modules/tsparticles/dist/Types/RangeValue.js"), exports);
__exportStar(__webpack_require__(/*! ./RecursivePartial */ "./node_modules/tsparticles/dist/Types/RecursivePartial.js"), exports);
__exportStar(__webpack_require__(/*! ./ShapeData */ "./node_modules/tsparticles/dist/Types/ShapeData.js"), exports);
__exportStar(__webpack_require__(/*! ./ShapeDrawerFunctions */ "./node_modules/tsparticles/dist/Types/ShapeDrawerFunctions.js"), exports);
__exportStar(__webpack_require__(/*! ./SingleOrMultiple */ "./node_modules/tsparticles/dist/Types/SingleOrMultiple.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/CanvasUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/CanvasUtils.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasUtils = void 0;
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "./node_modules/tsparticles/dist/Utils/ColorUtils.js");
const NumberUtils_1 = __webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js");
function drawLine(context, begin, end) {
    context.beginPath();
    context.moveTo(begin.x, begin.y);
    context.lineTo(end.x, end.y);
    context.closePath();
}
function drawTriangle(context, p1, p2, p3) {
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    context.lineTo(p3.x, p3.y);
    context.closePath();
}
class CanvasUtils {
    static paintBase(context, dimension, baseColor) {
        context.save();
        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : "rgba(0,0,0,0)";
        context.fillRect(0, 0, dimension.width, dimension.height);
        context.restore();
    }
    static clear(context, dimension) {
        context.clearRect(0, 0, dimension.width, dimension.height);
    }
    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {
        let drawn = false;
        if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {
            drawLine(context, begin, end);
            drawn = true;
        }
        else if (warp) {
            let pi1;
            let pi2;
            const endNE = {
                x: end.x - canvasSize.width,
                y: end.y,
            };
            const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);
            if (d1.distance <= maxDistance) {
                const yi = begin.y - (d1.dy / d1.dx) * begin.x;
                pi1 = { x: 0, y: yi };
                pi2 = { x: canvasSize.width, y: yi };
            }
            else {
                const endSW = {
                    x: end.x,
                    y: end.y - canvasSize.height,
                };
                const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);
                if (d2.distance <= maxDistance) {
                    const yi = begin.y - (d2.dy / d2.dx) * begin.x;
                    const xi = -yi / (d2.dy / d2.dx);
                    pi1 = { x: xi, y: 0 };
                    pi2 = { x: xi, y: canvasSize.height };
                }
                else {
                    const endSE = {
                        x: end.x - canvasSize.width,
                        y: end.y - canvasSize.height,
                    };
                    const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);
                    if (d3.distance <= maxDistance) {
                        const yi = begin.y - (d3.dy / d3.dx) * begin.x;
                        const xi = -yi / (d3.dy / d3.dx);
                        pi1 = { x: xi, y: yi };
                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };
                    }
                }
            }
            if (pi1 && pi2) {
                drawLine(context, begin, pi1);
                drawLine(context, end, pi2);
                drawn = true;
            }
        }
        if (!drawn) {
            return;
        }
        context.lineWidth = width;
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);
        if (shadow.enable) {
            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);
            if (shadowColor) {
                context.shadowBlur = shadow.blur;
                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);
            }
        }
        context.stroke();
    }
    static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {
        drawTriangle(context, pos1, pos2, pos3);
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);
        context.fill();
    }
    static drawConnectLine(context, width, lineStyle, begin, end) {
        context.save();
        drawLine(context, begin, end);
        context.lineWidth = width;
        context.strokeStyle = lineStyle;
        context.stroke();
        context.restore();
    }
    static gradient(context, p1, p2, opacity) {
        const gradStop = Math.floor(p2.getRadius() / p1.getRadius());
        const color1 = p1.getFillColor();
        const color2 = p2.getFillColor();
        if (!color1 || !color2) {
            return;
        }
        const sourcePos = p1.getPosition();
        const destPos = p2.getPosition();
        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());
        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);
        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));
        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));
        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));
        return grad;
    }
    static drawGrabLine(context, width, begin, end, colorLine, opacity) {
        context.save();
        drawLine(context, begin, end);
        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);
        context.lineWidth = width;
        context.stroke();
        context.restore();
    }
    static drawLight(container, context, mousePos) {
        const lightOptions = container.actualOptions.interactivity.modes.light.area;
        context.beginPath();
        context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);
        const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);
        const gradient = lightOptions.gradient;
        const gradientRgb = {
            start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),
            stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop),
        };
        if (!gradientRgb.start || !gradientRgb.stop) {
            return;
        }
        gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));
        gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));
        context.fillStyle = gradientAmbientLight;
        context.fill();
    }
    static drawParticleShadow(container, context, particle, mousePos) {
        const pos = particle.getPosition();
        const shadowOptions = container.actualOptions.interactivity.modes.light.shadow;
        context.save();
        const radius = particle.getRadius();
        const sides = particle.sides;
        const full = (Math.PI * 2) / sides;
        const angle = -particle.rotate.value + Math.PI / 4;
        const factor = 1;
        const dots = [];
        for (let i = 0; i < sides; i++) {
            dots.push({
                x: pos.x + radius * Math.sin(angle + full * i) * factor,
                y: pos.y + radius * Math.cos(angle + full * i) * factor,
            });
        }
        const points = [];
        const shadowLength = shadowOptions.length;
        for (const dot of dots) {
            const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);
            const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);
            const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);
            points.push({
                endX: endX,
                endY: endY,
                startX: dot.x,
                startY: dot.y,
            });
        }
        const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);
        if (!shadowRgb) {
            return;
        }
        const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);
        for (let i = points.length - 1; i >= 0; i--) {
            const n = i == points.length - 1 ? 0 : i + 1;
            context.beginPath();
            context.moveTo(points[i].startX, points[i].startY);
            context.lineTo(points[n].startX, points[n].startY);
            context.lineTo(points[n].endX, points[n].endY);
            context.lineTo(points[i].endX, points[i].endY);
            context.fillStyle = shadowColor;
            context.fill();
        }
        context.restore();
    }
    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {
        const pos = particle.getPosition();
        context.save();
        context.translate(pos.x, pos.y);
        context.beginPath();
        const angle = particle.rotate.value + (particle.options.rotate.path ? particle.velocity.angle : 0);
        if (angle !== 0) {
            context.rotate(angle);
        }
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        const shadowColor = particle.shadowColor;
        if (shadow.enable && shadowColor) {
            context.shadowBlur = shadow.blur;
            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);
            context.shadowOffsetX = shadow.offset.x;
            context.shadowOffsetY = shadow.offset.y;
        }
        if (fillColorValue) {
            context.fillStyle = fillColorValue;
        }
        const stroke = particle.stroke;
        context.lineWidth = particle.strokeWidth;
        if (strokeColorValue) {
            context.strokeStyle = strokeColorValue;
        }
        CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);
        if (stroke.width > 0) {
            context.stroke();
        }
        if (particle.close) {
            context.closePath();
        }
        if (particle.fill) {
            context.fill();
        }
        context.restore();
        context.save();
        context.translate(pos.x, pos.y);
        if (angle !== 0) {
            context.rotate(angle);
        }
        if (backgroundMask) {
            context.globalCompositeOperation = composite;
        }
        CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);
        context.restore();
    }
    static drawShape(container, context, particle, radius, opacity, delta) {
        if (!particle.shape) {
            return;
        }
        const drawer = container.drawers.get(particle.shape);
        if (!drawer) {
            return;
        }
        drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);
    }
    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {
        if (!particle.shape) {
            return;
        }
        const drawer = container.drawers.get(particle.shape);
        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {
            return;
        }
        drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);
    }
    static drawPlugin(context, plugin, delta) {
        if (plugin.draw !== undefined) {
            context.save();
            plugin.draw(context, delta);
            context.restore();
        }
    }
}
exports.CanvasUtils = CanvasUtils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Circle.js":
/*!*******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Circle.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Circle = void 0;
const Range_1 = __webpack_require__(/*! ./Range */ "./node_modules/tsparticles/dist/Utils/Range.js");
class Circle extends Range_1.Range {
    constructor(x, y, radius) {
        super(x, y);
        this.radius = radius;
    }
    contains(point) {
        const d = Math.pow(point.x - this.position.x, 2) + Math.pow(point.y - this.position.y, 2);
        return d <= this.radius * this.radius;
    }
    intersects(range) {
        const rect = range;
        const circle = range;
        const pos1 = this.position;
        const pos2 = range.position;
        const xDist = Math.abs(pos2.x - pos1.x);
        const yDist = Math.abs(pos2.y - pos1.y);
        const r = this.radius;
        if (circle.radius !== undefined) {
            const rSum = r + circle.radius;
            const dist = Math.sqrt(xDist * xDist + yDist + yDist);
            return rSum > dist;
        }
        else if (rect.size !== undefined) {
            const w = rect.size.width;
            const h = rect.size.height;
            const edges = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2);
            if (xDist > r + w || yDist > r + h) {
                return false;
            }
            if (xDist <= w || yDist <= h) {
                return true;
            }
            return edges <= r * r;
        }
        return false;
    }
}
exports.Circle = Circle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/CircleWarp.js":
/*!***********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/CircleWarp.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CircleWarp = void 0;
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./node_modules/tsparticles/dist/Utils/Rectangle.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./node_modules/tsparticles/dist/Utils/Circle.js");
class CircleWarp extends Circle_1.Circle {
    constructor(x, y, radius, canvasSize) {
        super(x, y, radius);
        this.canvasSize = canvasSize;
        this.canvasSize = {
            height: canvasSize.height,
            width: canvasSize.width,
        };
    }
    contains(point) {
        if (super.contains(point)) {
            return true;
        }
        const posNE = {
            x: point.x - this.canvasSize.width,
            y: point.y,
        };
        if (super.contains(posNE)) {
            return true;
        }
        const posSE = {
            x: point.x - this.canvasSize.width,
            y: point.y - this.canvasSize.height,
        };
        if (super.contains(posSE)) {
            return true;
        }
        const posSW = {
            x: point.x,
            y: point.y - this.canvasSize.height,
        };
        return super.contains(posSW);
    }
    intersects(range) {
        if (super.intersects(range)) {
            return true;
        }
        const rect = range;
        const circle = range;
        const newPos = {
            x: range.position.x - this.canvasSize.width,
            y: range.position.y - this.canvasSize.height,
        };
        if (circle.radius !== undefined) {
            const biggerCircle = new Circle_1.Circle(newPos.x, newPos.y, circle.radius * 2);
            return super.intersects(biggerCircle);
        }
        else if (rect.size !== undefined) {
            const rectSW = new Rectangle_1.Rectangle(newPos.x, newPos.y, rect.size.width * 2, rect.size.height * 2);
            return super.intersects(rectSW);
        }
        return false;
    }
}
exports.CircleWarp = CircleWarp;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/ColorUtils.js":
/*!***********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/ColorUtils.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorUtils = void 0;
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/Utils.js");
const Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/tsparticles/dist/Utils/Constants.js");
const NumberUtils_1 = __webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js");
function hue2rgb(p, q, t) {
    let tCalc = t;
    if (tCalc < 0) {
        tCalc += 1;
    }
    if (tCalc > 1) {
        tCalc -= 1;
    }
    if (tCalc < 1 / 6) {
        return p + (q - p) * 6 * tCalc;
    }
    if (tCalc < 1 / 2) {
        return q;
    }
    if (tCalc < 2 / 3) {
        return p + (q - p) * (2 / 3 - tCalc) * 6;
    }
    return p;
}
function stringToRgba(input) {
    if (input.startsWith("rgb")) {
        const regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.]+)\s*)?\)/i;
        const result = regex.exec(input);
        return result
            ? {
                a: result.length > 4 ? parseFloat(result[5]) : 1,
                b: parseInt(result[3], 10),
                g: parseInt(result[2], 10),
                r: parseInt(result[1], 10),
            }
            : undefined;
    }
    else if (input.startsWith("hsl")) {
        const regex = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i;
        const result = regex.exec(input);
        return result
            ? ColorUtils.hslaToRgba({
                a: result.length > 4 ? parseFloat(result[5]) : 1,
                h: parseInt(result[1], 10),
                l: parseInt(result[3], 10),
                s: parseInt(result[2], 10),
            })
            : undefined;
    }
    else if (input.startsWith("hsv")) {
        const regex = /hsva?\(\s*(\d+)°\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i;
        const result = regex.exec(input);
        return result
            ? ColorUtils.hsvaToRgba({
                a: result.length > 4 ? parseFloat(result[5]) : 1,
                h: parseInt(result[1], 10),
                s: parseInt(result[2], 10),
                v: parseInt(result[3], 10),
            })
            : undefined;
    }
    else {
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
        const hexFixed = input.replace(shorthandRegex, (_m, r, g, b, a) => {
            return r + r + g + g + b + b + (a !== undefined ? a + a : "");
        });
        const regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
        const result = regex.exec(hexFixed);
        return result
            ? {
                a: result[4] !== undefined ? parseInt(result[4], 16) / 0xff : 1,
                b: parseInt(result[3], 16),
                g: parseInt(result[2], 16),
                r: parseInt(result[1], 16),
            }
            : undefined;
    }
}
class ColorUtils {
    static colorToRgb(input, index, useIndex = true) {
        var _a, _b, _c;
        if (input === undefined) {
            return;
        }
        const color = typeof input === "string" ? { value: input } : input;
        let res;
        if (typeof color.value === "string") {
            if (color.value === Constants_1.Constants.randomColorValue) {
                res = ColorUtils.getRandomRgbColor();
            }
            else {
                res = ColorUtils.stringToRgb(color.value);
            }
        }
        else {
            if (color.value instanceof Array) {
                const colorSelected = Utils_1.Utils.itemFromArray(color.value, index, useIndex);
                res = ColorUtils.colorToRgb({ value: colorSelected });
            }
            else {
                const colorValue = color.value;
                const rgbColor = (_a = colorValue.rgb) !== null && _a !== void 0 ? _a : color.value;
                if (rgbColor.r !== undefined) {
                    res = rgbColor;
                }
                else {
                    const hslColor = (_b = colorValue.hsl) !== null && _b !== void 0 ? _b : color.value;
                    if (hslColor.h !== undefined && hslColor.l !== undefined) {
                        res = ColorUtils.hslToRgb(hslColor);
                    }
                    else {
                        const hsvColor = (_c = colorValue.hsv) !== null && _c !== void 0 ? _c : color.value;
                        if (hsvColor.h !== undefined && hsvColor.v !== undefined) {
                            res = ColorUtils.hsvToRgb(hsvColor);
                        }
                    }
                }
            }
        }
        return res;
    }
    static colorToHsl(color, index, useIndex = true) {
        const rgb = ColorUtils.colorToRgb(color, index, useIndex);
        return rgb !== undefined ? ColorUtils.rgbToHsl(rgb) : undefined;
    }
    static rgbToHsl(color) {
        const r1 = color.r / 255;
        const g1 = color.g / 255;
        const b1 = color.b / 255;
        const max = Math.max(r1, g1, b1);
        const min = Math.min(r1, g1, b1);
        const res = {
            h: 0,
            l: (max + min) / 2,
            s: 0,
        };
        if (max != min) {
            res.s = res.l < 0.5 ? (max - min) / (max + min) : (max - min) / (2.0 - max - min);
            res.h =
                r1 === max
                    ? (g1 - b1) / (max - min)
                    : (res.h = g1 === max ? 2.0 + (b1 - r1) / (max - min) : 4.0 + (r1 - g1) / (max - min));
        }
        res.l *= 100;
        res.s *= 100;
        res.h *= 60;
        if (res.h < 0) {
            res.h += 360;
        }
        return res;
    }
    static stringToAlpha(input) {
        var _a;
        return (_a = stringToRgba(input)) === null || _a === void 0 ? void 0 : _a.a;
    }
    static stringToRgb(input) {
        return stringToRgba(input);
    }
    static hslToRgb(hsl) {
        const result = { b: 0, g: 0, r: 0 };
        const hslPercent = {
            h: hsl.h / 360,
            l: hsl.l / 100,
            s: hsl.s / 100,
        };
        if (hslPercent.s === 0) {
            result.b = hslPercent.l;
            result.g = hslPercent.l;
            result.r = hslPercent.l;
        }
        else {
            const q = hslPercent.l < 0.5
                ? hslPercent.l * (1 + hslPercent.s)
                : hslPercent.l + hslPercent.s - hslPercent.l * hslPercent.s;
            const p = 2 * hslPercent.l - q;
            result.r = hue2rgb(p, q, hslPercent.h + 1 / 3);
            result.g = hue2rgb(p, q, hslPercent.h);
            result.b = hue2rgb(p, q, hslPercent.h - 1 / 3);
        }
        result.r = Math.floor(result.r * 255);
        result.g = Math.floor(result.g * 255);
        result.b = Math.floor(result.b * 255);
        return result;
    }
    static hslaToRgba(hsla) {
        const rgbResult = ColorUtils.hslToRgb(hsla);
        return {
            a: hsla.a,
            b: rgbResult.b,
            g: rgbResult.g,
            r: rgbResult.r,
        };
    }
    static hslToHsv(hsl) {
        const l = hsl.l / 100, sl = hsl.s / 100;
        const v = l + sl * Math.min(l, 1 - l), sv = !v ? 0 : 2 * (1 - l / v);
        return {
            h: hsl.h,
            s: sv * 100,
            v: v * 100,
        };
    }
    static hslaToHsva(hsla) {
        const hsvResult = ColorUtils.hslToHsv(hsla);
        return {
            a: hsla.a,
            h: hsvResult.h,
            s: hsvResult.s,
            v: hsvResult.v,
        };
    }
    static hsvToHsl(hsv) {
        const v = hsv.v / 100, sv = hsv.s / 100;
        const l = v * (1 - sv / 2), sl = l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l);
        return {
            h: hsv.h,
            l: l * 100,
            s: sl * 100,
        };
    }
    static hsvaToHsla(hsva) {
        const hslResult = ColorUtils.hsvToHsl(hsva);
        return {
            a: hsva.a,
            h: hslResult.h,
            l: hslResult.l,
            s: hslResult.s,
        };
    }
    static hsvToRgb(hsv) {
        const result = { b: 0, g: 0, r: 0 };
        const hsvPercent = {
            h: hsv.h / 60,
            s: hsv.s / 100,
            v: hsv.v / 100,
        };
        const c = hsvPercent.v * hsvPercent.s, x = c * (1 - Math.abs((hsvPercent.h % 2) - 1));
        let tempRgb;
        if (hsvPercent.h >= 0 && hsvPercent.h <= 1) {
            tempRgb = {
                r: c,
                g: x,
                b: 0,
            };
        }
        else if (hsvPercent.h > 1 && hsvPercent.h <= 2) {
            tempRgb = {
                r: x,
                g: c,
                b: 0,
            };
        }
        else if (hsvPercent.h > 2 && hsvPercent.h <= 3) {
            tempRgb = {
                r: 0,
                g: c,
                b: x,
            };
        }
        else if (hsvPercent.h > 3 && hsvPercent.h <= 4) {
            tempRgb = {
                r: 0,
                g: x,
                b: c,
            };
        }
        else if (hsvPercent.h > 4 && hsvPercent.h <= 5) {
            tempRgb = {
                r: x,
                g: 0,
                b: c,
            };
        }
        else if (hsvPercent.h > 5 && hsvPercent.h <= 6) {
            tempRgb = {
                r: c,
                g: 0,
                b: x,
            };
        }
        if (tempRgb) {
            const m = hsvPercent.v - c;
            result.r = Math.floor((tempRgb.r + m) * 255);
            result.g = Math.floor((tempRgb.g + m) * 255);
            result.b = Math.floor((tempRgb.b + m) * 255);
        }
        return result;
    }
    static hsvaToRgba(hsva) {
        const rgbResult = ColorUtils.hsvToRgb(hsva);
        return {
            a: hsva.a,
            b: rgbResult.b,
            g: rgbResult.g,
            r: rgbResult.r,
        };
    }
    static rgbToHsv(rgb) {
        const rgbPercent = {
            r: rgb.r / 255,
            g: rgb.g / 255,
            b: rgb.b / 255,
        }, xMax = Math.max(rgbPercent.r, rgbPercent.g, rgbPercent.b), xMin = Math.min(rgbPercent.r, rgbPercent.g, rgbPercent.b), v = xMax, c = xMax - xMin;
        let h = 0;
        if (v === rgbPercent.r) {
            h = 60 * ((rgbPercent.g - rgbPercent.b) / c);
        }
        else if (v === rgbPercent.g) {
            h = 60 * (2 + (rgbPercent.b - rgbPercent.r) / c);
        }
        else if (v === rgbPercent.b) {
            h = 60 * (4 + (rgbPercent.r - rgbPercent.g) / c);
        }
        const s = !v ? 0 : c / v;
        return {
            h,
            s: s * 100,
            v: v * 100,
        };
    }
    static rgbaToHsva(rgba) {
        const hsvResult = ColorUtils.rgbToHsv(rgba);
        return {
            a: rgba.a,
            h: hsvResult.h,
            s: hsvResult.s,
            v: hsvResult.v,
        };
    }
    static getRandomRgbColor(min) {
        const fixedMin = min !== null && min !== void 0 ? min : 0;
        return {
            b: Math.floor(NumberUtils_1.NumberUtils.randomInRange(NumberUtils_1.NumberUtils.setRangeValue(fixedMin, 256))),
            g: Math.floor(NumberUtils_1.NumberUtils.randomInRange(NumberUtils_1.NumberUtils.setRangeValue(fixedMin, 256))),
            r: Math.floor(NumberUtils_1.NumberUtils.randomInRange(NumberUtils_1.NumberUtils.setRangeValue(fixedMin, 256))),
        };
    }
    static getStyleFromRgb(color, opacity) {
        return `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity !== null && opacity !== void 0 ? opacity : 1})`;
    }
    static getStyleFromHsl(color, opacity) {
        return `hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity !== null && opacity !== void 0 ? opacity : 1})`;
    }
    static getStyleFromHsv(color, opacity) {
        return ColorUtils.getStyleFromHsl(ColorUtils.hsvToHsl(color), opacity);
    }
    static mix(color1, color2, size1, size2) {
        let rgb1 = color1;
        let rgb2 = color2;
        if (rgb1.r === undefined) {
            rgb1 = ColorUtils.hslToRgb(color1);
        }
        if (rgb2.r === undefined) {
            rgb2 = ColorUtils.hslToRgb(color2);
        }
        return {
            b: NumberUtils_1.NumberUtils.mix(rgb1.b, rgb2.b, size1, size2),
            g: NumberUtils_1.NumberUtils.mix(rgb1.g, rgb2.g, size1, size2),
            r: NumberUtils_1.NumberUtils.mix(rgb1.r, rgb2.r, size1, size2),
        };
    }
    static replaceColorSvg(image, color, opacity) {
        if (!image.svgData) {
            return "";
        }
        const svgXml = image.svgData;
        const rgbHex = /#([0-9A-F]{3,6})/gi;
        return svgXml.replace(rgbHex, () => ColorUtils.getStyleFromHsl(color, opacity));
    }
    static getLinkColor(p1, p2, linkColor) {
        var _a, _b;
        if (linkColor === Constants_1.Constants.randomColorValue) {
            return ColorUtils.getRandomRgbColor();
        }
        else if (linkColor === "mid") {
            const sourceColor = (_a = p1.getFillColor()) !== null && _a !== void 0 ? _a : p1.getStrokeColor();
            const destColor = (_b = p2 === null || p2 === void 0 ? void 0 : p2.getFillColor()) !== null && _b !== void 0 ? _b : p2 === null || p2 === void 0 ? void 0 : p2.getStrokeColor();
            if (sourceColor && destColor && p2) {
                return ColorUtils.mix(sourceColor, destColor, p1.getRadius(), p2.getRadius());
            }
            else {
                const hslColor = sourceColor !== null && sourceColor !== void 0 ? sourceColor : destColor;
                if (hslColor) {
                    return ColorUtils.hslToRgb(hslColor);
                }
            }
        }
        else {
            return linkColor;
        }
    }
    static getLinkRandomColor(optColor, blink, consent) {
        const color = typeof optColor === "string" ? optColor : optColor.value;
        if (color === Constants_1.Constants.randomColorValue) {
            if (consent) {
                return ColorUtils.colorToRgb({
                    value: color,
                });
            }
            else if (blink) {
                return Constants_1.Constants.randomColorValue;
            }
            else {
                return Constants_1.Constants.midColorValue;
            }
        }
        else {
            return ColorUtils.colorToRgb({
                value: color,
            });
        }
    }
    static getHslFromAnimation(animation) {
        return animation !== undefined
            ? {
                h: animation.h.value,
                s: animation.s.value,
                l: animation.l.value,
            }
            : undefined;
    }
}
exports.ColorUtils = ColorUtils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Constants.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Constants = void 0;
class Constants {
}
exports.Constants = Constants;
Constants.canvasClass = "tsparticles-canvas-el";
Constants.randomColorValue = "random";
Constants.midColorValue = "mid";
Constants.touchEndEvent = "touchend";
Constants.mouseDownEvent = "mousedown";
Constants.mouseUpEvent = "mouseup";
Constants.mouseMoveEvent = "mousemove";
Constants.touchStartEvent = "touchstart";
Constants.touchMoveEvent = "touchmove";
Constants.mouseLeaveEvent = "mouseleave";
Constants.mouseOutEvent = "mouseout";
Constants.touchCancelEvent = "touchcancel";
Constants.resizeEvent = "resize";
Constants.visibilityChangeEvent = "visibilitychange";
Constants.noPolygonDataLoaded = "No polygon data loaded.";
Constants.noPolygonFound = "No polygon found, you need to specify SVG url in config.";


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/EventListeners.js":
/*!***************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/EventListeners.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventListeners = void 0;
const Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/tsparticles/dist/Enums/index.js");
const Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/tsparticles/dist/Utils/Constants.js");
function manageListener(element, event, handler, add, options) {
    if (add) {
        let addOptions = { passive: true };
        if (typeof options === "boolean") {
            addOptions.capture = options;
        }
        else if (options !== undefined) {
            addOptions = options;
        }
        element.addEventListener(event, handler, addOptions);
    }
    else {
        const removeOptions = options;
        element.removeEventListener(event, handler, removeOptions);
    }
}
class EventListeners {
    constructor(container) {
        this.container = container;
        this.canPush = true;
        this.mouseMoveHandler = (e) => this.mouseTouchMove(e);
        this.touchStartHandler = (e) => this.mouseTouchMove(e);
        this.touchMoveHandler = (e) => this.mouseTouchMove(e);
        this.touchEndHandler = () => this.mouseTouchFinish();
        this.mouseLeaveHandler = () => this.mouseTouchFinish();
        this.touchCancelHandler = () => this.mouseTouchFinish();
        this.touchEndClickHandler = (e) => this.mouseTouchClick(e);
        this.mouseUpHandler = (e) => this.mouseTouchClick(e);
        this.mouseDownHandler = () => this.mouseDown();
        this.visibilityChangeHandler = () => this.handleVisibilityChange();
        this.resizeHandler = () => this.handleWindowResize();
    }
    addListeners() {
        this.manageListeners(true);
    }
    removeListeners() {
        this.manageListeners(false);
    }
    manageListeners(add) {
        var _a;
        const container = this.container;
        const options = container.actualOptions;
        const detectType = options.interactivity.detectsOn;
        let mouseLeaveEvent = Constants_1.Constants.mouseLeaveEvent;
        if (detectType === Enums_1.InteractivityDetect.window) {
            container.interactivity.element = window;
            mouseLeaveEvent = Constants_1.Constants.mouseOutEvent;
        }
        else if (detectType === Enums_1.InteractivityDetect.parent && container.canvas.element) {
            const canvasEl = container.canvas.element;
            container.interactivity.element = (_a = canvasEl.parentElement) !== null && _a !== void 0 ? _a : canvasEl.parentNode;
        }
        else {
            container.interactivity.element = container.canvas.element;
        }
        const interactivityEl = container.interactivity.element;
        if (!interactivityEl) {
            return;
        }
        const html = interactivityEl;
        if (options.interactivity.events.onHover.enable || options.interactivity.events.onClick.enable) {
            manageListener(interactivityEl, Constants_1.Constants.mouseMoveEvent, this.mouseMoveHandler, add);
            manageListener(interactivityEl, Constants_1.Constants.touchStartEvent, this.touchStartHandler, add);
            manageListener(interactivityEl, Constants_1.Constants.touchMoveEvent, this.touchMoveHandler, add);
            if (!options.interactivity.events.onClick.enable) {
                manageListener(interactivityEl, Constants_1.Constants.touchEndEvent, this.touchEndHandler, add);
            }
            else {
                manageListener(interactivityEl, Constants_1.Constants.touchEndEvent, this.touchEndClickHandler, add);
                manageListener(interactivityEl, Constants_1.Constants.mouseUpEvent, this.mouseUpHandler, add);
                manageListener(interactivityEl, Constants_1.Constants.mouseDownEvent, this.mouseDownHandler, add);
            }
            manageListener(interactivityEl, mouseLeaveEvent, this.mouseLeaveHandler, add);
            manageListener(interactivityEl, Constants_1.Constants.touchCancelEvent, this.touchCancelHandler, add);
        }
        if (container.canvas.element) {
            container.canvas.element.style.pointerEvents = html === container.canvas.element ? "initial" : "none";
        }
        if (options.interactivity.events.resize) {
            manageListener(window, Constants_1.Constants.resizeEvent, this.resizeHandler, add);
        }
        if (document) {
            manageListener(document, Constants_1.Constants.visibilityChangeEvent, this.visibilityChangeHandler, add, false);
        }
    }
    handleWindowResize() {
        var _a;
        (_a = this.container.canvas) === null || _a === void 0 ? void 0 : _a.windowResize();
    }
    handleVisibilityChange() {
        const container = this.container;
        const options = container.actualOptions;
        this.mouseTouchFinish();
        if (!options.pauseOnBlur) {
            return;
        }
        if (document === null || document === void 0 ? void 0 : document.hidden) {
            container.pageHidden = true;
            container.pause();
        }
        else {
            container.pageHidden = false;
            if (container.getAnimationStatus()) {
                container.play(true);
            }
            else {
                container.draw();
            }
        }
    }
    mouseDown() {
        const interactivity = this.container.interactivity;
        if (interactivity) {
            const mouse = interactivity.mouse;
            mouse.clicking = true;
            mouse.downPosition = mouse.position;
        }
    }
    mouseTouchMove(e) {
        var _a, _b, _c, _d, _e, _f, _g;
        const container = this.container;
        const options = container.actualOptions;
        if (((_a = container.interactivity) === null || _a === void 0 ? void 0 : _a.element) === undefined) {
            return;
        }
        container.interactivity.mouse.inside = true;
        let pos;
        const canvas = container.canvas.element;
        if (e.type.startsWith("mouse")) {
            this.canPush = true;
            const mouseEvent = e;
            if (container.interactivity.element === window) {
                if (canvas) {
                    const clientRect = canvas.getBoundingClientRect();
                    pos = {
                        x: mouseEvent.clientX - clientRect.left,
                        y: mouseEvent.clientY - clientRect.top,
                    };
                }
            }
            else if (options.interactivity.detectsOn === Enums_1.InteractivityDetect.parent) {
                const source = mouseEvent.target;
                const target = mouseEvent.currentTarget;
                const canvasEl = container.canvas.element;
                if (source && target && canvasEl) {
                    const sourceRect = source.getBoundingClientRect();
                    const targetRect = target.getBoundingClientRect();
                    const canvasRect = canvasEl.getBoundingClientRect();
                    pos = {
                        x: mouseEvent.offsetX + 2 * sourceRect.left - (targetRect.left + canvasRect.left),
                        y: mouseEvent.offsetY + 2 * sourceRect.top - (targetRect.top + canvasRect.top),
                    };
                }
                else {
                    pos = {
                        x: (_b = mouseEvent.offsetX) !== null && _b !== void 0 ? _b : mouseEvent.clientX,
                        y: (_c = mouseEvent.offsetY) !== null && _c !== void 0 ? _c : mouseEvent.clientY,
                    };
                }
            }
            else {
                if (mouseEvent.target === container.canvas.element) {
                    pos = {
                        x: (_d = mouseEvent.offsetX) !== null && _d !== void 0 ? _d : mouseEvent.clientX,
                        y: (_e = mouseEvent.offsetY) !== null && _e !== void 0 ? _e : mouseEvent.clientY,
                    };
                }
            }
        }
        else {
            this.canPush = e.type !== "touchmove";
            const touchEvent = e;
            const lastTouch = touchEvent.touches[touchEvent.touches.length - 1];
            const canvasRect = canvas === null || canvas === void 0 ? void 0 : canvas.getBoundingClientRect();
            pos = {
                x: lastTouch.clientX - ((_f = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) !== null && _f !== void 0 ? _f : 0),
                y: lastTouch.clientY - ((_g = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) !== null && _g !== void 0 ? _g : 0),
            };
        }
        const pxRatio = container.retina.pixelRatio;
        if (pos) {
            pos.x *= pxRatio;
            pos.y *= pxRatio;
        }
        container.interactivity.mouse.position = pos;
        container.interactivity.status = Constants_1.Constants.mouseMoveEvent;
    }
    mouseTouchFinish() {
        const interactivity = this.container.interactivity;
        if (interactivity === undefined) {
            return;
        }
        const mouse = interactivity.mouse;
        delete mouse.position;
        delete mouse.clickPosition;
        delete mouse.downPosition;
        interactivity.status = Constants_1.Constants.mouseLeaveEvent;
        mouse.inside = false;
        mouse.clicking = false;
    }
    mouseTouchClick(e) {
        const container = this.container;
        const options = container.actualOptions;
        const mouse = container.interactivity.mouse;
        mouse.inside = true;
        let handled = false;
        const mousePosition = mouse.position;
        if (mousePosition === undefined || !options.interactivity.events.onClick.enable) {
            return;
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.clickPositionValid !== undefined) {
                handled = plugin.clickPositionValid(mousePosition);
                if (handled) {
                    break;
                }
            }
        }
        if (!handled) {
            this.doMouseTouchClick(e);
        }
        mouse.clicking = false;
    }
    doMouseTouchClick(e) {
        const container = this.container;
        const options = container.actualOptions;
        if (this.canPush) {
            const mousePos = container.interactivity.mouse.position;
            if (mousePos) {
                container.interactivity.mouse.clickPosition = {
                    x: mousePos.x,
                    y: mousePos.y,
                };
            }
            else {
                return;
            }
            container.interactivity.mouse.clickTime = new Date().getTime();
            const onClick = options.interactivity.events.onClick;
            if (onClick.mode instanceof Array) {
                for (const mode of onClick.mode) {
                    this.handleClickMode(mode);
                }
            }
            else {
                this.handleClickMode(onClick.mode);
            }
        }
        if (e.type === "touchend") {
            setTimeout(() => this.mouseTouchFinish(), 500);
        }
    }
    handleClickMode(mode) {
        const container = this.container;
        const options = container.actualOptions;
        const pushNb = options.interactivity.modes.push.quantity;
        const removeNb = options.interactivity.modes.remove.quantity;
        switch (mode) {
            case Enums_1.ClickMode.push: {
                if (pushNb > 0) {
                    container.particles.push(pushNb, container.interactivity.mouse);
                }
                break;
            }
            case Enums_1.ClickMode.remove:
                container.particles.removeQuantity(removeNb);
                break;
            case Enums_1.ClickMode.bubble:
                container.bubble.clicking = true;
                break;
            case Enums_1.ClickMode.repulse:
                container.repulse.clicking = true;
                container.repulse.count = 0;
                for (const particle of container.repulse.particles) {
                    particle.velocity.setTo(particle.initialVelocity);
                }
                container.repulse.particles = [];
                container.repulse.finish = false;
                setTimeout(() => {
                    if (!container.destroyed) {
                        container.repulse.clicking = false;
                    }
                }, options.interactivity.modes.repulse.duration * 1000);
                break;
            case Enums_1.ClickMode.attract:
                container.attract.clicking = true;
                container.attract.count = 0;
                for (const particle of container.attract.particles) {
                    particle.velocity.setTo(particle.initialVelocity);
                }
                container.attract.particles = [];
                container.attract.finish = false;
                setTimeout(() => {
                    if (!container.destroyed) {
                        container.attract.clicking = false;
                    }
                }, options.interactivity.modes.attract.duration * 1000);
                break;
            case Enums_1.ClickMode.pause:
                if (container.getAnimationStatus()) {
                    container.pause();
                }
                else {
                    container.play();
                }
                break;
        }
        for (const [, plugin] of container.plugins) {
            if (plugin.handleClickMode) {
                plugin.handleClickMode(mode);
            }
        }
    }
}
exports.EventListeners = EventListeners;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/NumberUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/NumberUtils.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberUtils = void 0;
const Directions_1 = __webpack_require__(/*! ../Enums/Directions */ "./node_modules/tsparticles/dist/Enums/Directions/index.js");
const Vector_1 = __webpack_require__(/*! ../Core/Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js");
class NumberUtils {
    static clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }
    static mix(comp1, comp2, weight1, weight2) {
        return Math.floor((comp1 * weight1 + comp2 * weight2) / (weight1 + weight2));
    }
    static randomInRange(r) {
        const max = NumberUtils.getRangeMax(r);
        let min = NumberUtils.getRangeMin(r);
        if (max === min) {
            min = 0;
        }
        return Math.random() * (max - min) + min;
    }
    static getRangeValue(value) {
        return typeof value === "number" ? value : NumberUtils.randomInRange(value);
    }
    static getRangeMin(value) {
        return typeof value === "number" ? value : value.min;
    }
    static getRangeMax(value) {
        return typeof value === "number" ? value : value.max;
    }
    static setRangeValue(source, value) {
        if (source === value || (value === undefined && typeof source === "number")) {
            return source;
        }
        const min = NumberUtils.getRangeMin(source), max = NumberUtils.getRangeMax(source);
        return value !== undefined
            ? {
                min: Math.min(min, value),
                max: Math.max(max, value),
            }
            : NumberUtils.setRangeValue(min, max);
    }
    static getValue(options) {
        const random = options.random;
        const { enable, minimumValue } = typeof random === "boolean" ? { enable: random, minimumValue: 0 } : random;
        return enable
            ? NumberUtils.getRangeValue(NumberUtils.setRangeValue(options.value, minimumValue))
            : NumberUtils.getRangeValue(options.value);
    }
    static getDistances(pointA, pointB) {
        const dx = pointA.x - pointB.x;
        const dy = pointA.y - pointB.y;
        return { dx: dx, dy: dy, distance: Math.sqrt(dx * dx + dy * dy) };
    }
    static getDistance(pointA, pointB) {
        return NumberUtils.getDistances(pointA, pointB).distance;
    }
    static getParticleBaseVelocity(direction) {
        const baseVelocity = Vector_1.Vector.origin;
        baseVelocity.length = 1;
        switch (direction) {
            case Directions_1.MoveDirection.top:
                baseVelocity.angle = -Math.PI / 2;
                break;
            case Directions_1.MoveDirection.topRight:
                baseVelocity.angle = -Math.PI / 4;
                break;
            case Directions_1.MoveDirection.right:
                baseVelocity.angle = 0;
                break;
            case Directions_1.MoveDirection.bottomRight:
                baseVelocity.angle = Math.PI / 4;
                break;
            case Directions_1.MoveDirection.bottom:
                baseVelocity.angle = Math.PI / 2;
                break;
            case Directions_1.MoveDirection.bottomLeft:
                baseVelocity.angle = (3 * Math.PI) / 4;
                break;
            case Directions_1.MoveDirection.left:
                baseVelocity.angle = Math.PI;
                break;
            case Directions_1.MoveDirection.topLeft:
                baseVelocity.angle = (-3 * Math.PI) / 4;
                break;
            case Directions_1.MoveDirection.none:
            default:
                baseVelocity.angle = Math.random() * Math.PI * 2;
                break;
        }
        return baseVelocity;
    }
    static rotateVelocity(velocity, angle) {
        return {
            horizontal: velocity.horizontal * Math.cos(angle) - velocity.vertical * Math.sin(angle),
            vertical: velocity.horizontal * Math.sin(angle) + velocity.vertical * Math.cos(angle),
        };
    }
    static collisionVelocity(v1, v2, m1, m2) {
        return Vector_1.Vector.create((v1.x * (m1 - m2)) / (m1 + m2) + (v2.x * 2 * m2) / (m1 + m2), v1.y);
    }
}
exports.NumberUtils = NumberUtils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Plugins.js":
/*!********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Plugins.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugins = void 0;
const plugins = [];
const presets = new Map();
const drawers = new Map();
const pathGenerators = new Map();
class Plugins {
    static getPlugin(plugin) {
        return plugins.find((t) => t.id === plugin);
    }
    static addPlugin(plugin) {
        if (!Plugins.getPlugin(plugin.id)) {
            plugins.push(plugin);
        }
    }
    static getAvailablePlugins(container) {
        const res = new Map();
        for (const plugin of plugins) {
            if (!plugin.needsPlugin(container.actualOptions)) {
                continue;
            }
            res.set(plugin.id, plugin.getPlugin(container));
        }
        return res;
    }
    static loadOptions(options, sourceOptions) {
        for (const plugin of plugins) {
            plugin.loadOptions(options, sourceOptions);
        }
    }
    static getPreset(preset) {
        return presets.get(preset);
    }
    static addPreset(presetKey, options) {
        if (!Plugins.getPreset(presetKey)) {
            presets.set(presetKey, options);
        }
    }
    static addShapeDrawer(type, drawer) {
        if (!Plugins.getShapeDrawer(type)) {
            drawers.set(type, drawer);
        }
    }
    static getShapeDrawer(type) {
        return drawers.get(type);
    }
    static getSupportedShapes() {
        return drawers.keys();
    }
    static getPathGenerator(type) {
        return pathGenerators.get(type);
    }
    static addPathGenerator(type, pathGenerator) {
        if (!Plugins.getPathGenerator(type)) {
            pathGenerators.set(type, pathGenerator);
        }
    }
}
exports.Plugins = Plugins;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Point.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Point.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Point = void 0;
class Point {
    constructor(position, particle) {
        this.position = position;
        this.particle = particle;
    }
}
exports.Point = Point;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/QuadTree.js":
/*!*********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/QuadTree.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadTree = void 0;
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./node_modules/tsparticles/dist/Utils/Rectangle.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./node_modules/tsparticles/dist/Utils/Circle.js");
const CircleWarp_1 = __webpack_require__(/*! ./CircleWarp */ "./node_modules/tsparticles/dist/Utils/CircleWarp.js");
class QuadTree {
    constructor(rectangle, capacity) {
        this.rectangle = rectangle;
        this.capacity = capacity;
        this.points = [];
        this.divided = false;
    }
    subdivide() {
        const x = this.rectangle.position.x;
        const y = this.rectangle.position.y;
        const w = this.rectangle.size.width;
        const h = this.rectangle.size.height;
        const capacity = this.capacity;
        this.northEast = new QuadTree(new Rectangle_1.Rectangle(x, y, w / 2, h / 2), capacity);
        this.northWest = new QuadTree(new Rectangle_1.Rectangle(x + w / 2, y, w / 2, h / 2), capacity);
        this.southEast = new QuadTree(new Rectangle_1.Rectangle(x, y + h / 2, w / 2, h / 2), capacity);
        this.southWest = new QuadTree(new Rectangle_1.Rectangle(x + w / 2, y + h / 2, w / 2, h / 2), capacity);
        this.divided = true;
    }
    insert(point) {
        var _a, _b, _c, _d, _e;
        if (!this.rectangle.contains(point.position)) {
            return false;
        }
        if (this.points.length < this.capacity) {
            this.points.push(point);
            return true;
        }
        if (!this.divided) {
            this.subdivide();
        }
        return ((_e = (((_a = this.northEast) === null || _a === void 0 ? void 0 : _a.insert(point)) ||
            ((_b = this.northWest) === null || _b === void 0 ? void 0 : _b.insert(point)) ||
            ((_c = this.southEast) === null || _c === void 0 ? void 0 : _c.insert(point)) ||
            ((_d = this.southWest) === null || _d === void 0 ? void 0 : _d.insert(point)))) !== null && _e !== void 0 ? _e : false);
    }
    queryCircle(position, radius) {
        return this.query(new Circle_1.Circle(position.x, position.y, radius));
    }
    queryCircleWarp(position, radius, containerOrSize) {
        const container = containerOrSize;
        const size = containerOrSize;
        return this.query(new CircleWarp_1.CircleWarp(position.x, position.y, radius, container.canvas !== undefined ? container.canvas.size : size));
    }
    queryRectangle(position, size) {
        return this.query(new Rectangle_1.Rectangle(position.x, position.y, size.width, size.height));
    }
    query(range, found) {
        var _a, _b, _c, _d;
        const res = found !== null && found !== void 0 ? found : [];
        if (!range.intersects(this.rectangle)) {
            return [];
        }
        else {
            for (const p of this.points) {
                if (!range.contains(p.position)) {
                    continue;
                }
                res.push(p.particle);
            }
            if (this.divided) {
                (_a = this.northEast) === null || _a === void 0 ? void 0 : _a.query(range, res);
                (_b = this.northWest) === null || _b === void 0 ? void 0 : _b.query(range, res);
                (_c = this.southEast) === null || _c === void 0 ? void 0 : _c.query(range, res);
                (_d = this.southWest) === null || _d === void 0 ? void 0 : _d.query(range, res);
            }
        }
        return res;
    }
}
exports.QuadTree = QuadTree;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Range.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Range.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Range = void 0;
class Range {
    constructor(x, y) {
        this.position = {
            x: x,
            y: y,
        };
    }
}
exports.Range = Range;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Rectangle.js":
/*!**********************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Rectangle.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rectangle = void 0;
const Range_1 = __webpack_require__(/*! ./Range */ "./node_modules/tsparticles/dist/Utils/Range.js");
class Rectangle extends Range_1.Range {
    constructor(x, y, width, height) {
        super(x, y);
        this.size = {
            height: height,
            width: width,
        };
    }
    contains(point) {
        const w = this.size.width;
        const h = this.size.height;
        const pos = this.position;
        return point.x >= pos.x && point.x <= pos.x + w && point.y >= pos.y && point.y <= pos.y + h;
    }
    intersects(range) {
        const rect = range;
        const circle = range;
        const w = this.size.width;
        const h = this.size.height;
        const pos1 = this.position;
        const pos2 = range.position;
        if (circle.radius !== undefined) {
            return circle.intersects(this);
        }
        else if (rect.size !== undefined) {
            const size2 = rect.size;
            const w2 = size2.width;
            const h2 = size2.height;
            return pos2.x < pos1.x + w && pos2.x + w2 > pos1.x && pos2.y < pos1.y + h && pos2.y + h2 > pos1.y;
        }
        return false;
    }
}
exports.Rectangle = Rectangle;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/Utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const OutModeDirection_1 = __webpack_require__(/*! ../Enums/Directions/OutModeDirection */ "./node_modules/tsparticles/dist/Enums/Directions/OutModeDirection.js");
const NumberUtils_1 = __webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js");
function rectSideBounce(pSide, pOtherSide, rectSide, rectOtherSide, velocity, factor) {
    const res = { bounced: false };
    if (pOtherSide.min >= rectOtherSide.min &&
        pOtherSide.min <= rectOtherSide.max &&
        pOtherSide.max >= rectOtherSide.min &&
        pOtherSide.max <= rectOtherSide.max) {
        if ((pSide.max >= rectSide.min && pSide.max <= (rectSide.max + rectSide.min) / 2 && velocity > 0) ||
            (pSide.min <= rectSide.max && pSide.min > (rectSide.max + rectSide.min) / 2 && velocity < 0)) {
            res.velocity = velocity * -factor;
            res.bounced = true;
        }
    }
    return res;
}
function checkSelector(element, selectors) {
    if (selectors instanceof Array) {
        for (const selector of selectors) {
            if (element.matches(selector)) {
                return true;
            }
        }
        return false;
    }
    else {
        return element.matches(selectors);
    }
}
class Utils {
    static isSsr() {
        return typeof window === "undefined" || !window;
    }
    static get animate() {
        return Utils.isSsr()
            ? (callback) => setTimeout(callback)
            : (callback) => (window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                window.setTimeout)(callback);
    }
    static get cancelAnimation() {
        return Utils.isSsr()
            ? (handle) => clearTimeout(handle)
            : (handle) => (window.cancelAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.oCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame ||
                window.clearTimeout)(handle);
    }
    static isInArray(value, array) {
        return value === array || (array instanceof Array && array.indexOf(value) > -1);
    }
    static loadFont(character) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield document.fonts.load(`${character.weight} 36px '${character.font}'`);
            }
            catch (_a) {
            }
        });
    }
    static arrayRandomIndex(array) {
        return Math.floor(Math.random() * array.length);
    }
    static itemFromArray(array, index, useIndex = true) {
        const fixedIndex = index !== undefined && useIndex ? index % array.length : Utils.arrayRandomIndex(array);
        return array[fixedIndex];
    }
    static isPointInside(point, size, radius, direction) {
        return Utils.areBoundsInside(Utils.calculateBounds(point, radius !== null && radius !== void 0 ? radius : 0), size, direction);
    }
    static areBoundsInside(bounds, size, direction) {
        let inside = true;
        if (!direction || direction === OutModeDirection_1.OutModeDirection.bottom) {
            inside = bounds.top < size.height;
        }
        if (inside && (!direction || direction === OutModeDirection_1.OutModeDirection.left)) {
            inside = bounds.right > 0;
        }
        if (inside && (!direction || direction === OutModeDirection_1.OutModeDirection.right)) {
            inside = bounds.left < size.width;
        }
        if (inside && (!direction || direction === OutModeDirection_1.OutModeDirection.top)) {
            inside = bounds.bottom > 0;
        }
        return inside;
    }
    static calculateBounds(point, radius) {
        return {
            bottom: point.y + radius,
            left: point.x - radius,
            right: point.x + radius,
            top: point.y - radius,
        };
    }
    static loadImage(source) {
        return new Promise((resolve, reject) => {
            if (!source) {
                reject("Error tsParticles - No image.src");
                return;
            }
            const image = {
                source: source,
                type: source.substr(source.length - 3),
            };
            const img = new Image();
            img.addEventListener("load", () => {
                image.element = img;
                resolve(image);
            });
            img.addEventListener("error", () => {
                reject(`Error tsParticles - loading image: ${source}`);
            });
            img.src = source;
        });
    }
    static downloadSvgImage(source) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!source) {
                throw new Error("Error tsParticles - No image.src");
            }
            const image = {
                source: source,
                type: source.substr(source.length - 3),
            };
            if (image.type !== "svg") {
                return Utils.loadImage(source);
            }
            const response = yield fetch(image.source);
            if (!response.ok) {
                throw new Error("Error tsParticles - Image not found");
            }
            image.svgData = yield response.text();
            return image;
        });
    }
    static deepExtend(destination, ...sources) {
        for (const source of sources) {
            if (source === undefined || source === null) {
                continue;
            }
            if (typeof source !== "object") {
                destination = source;
                continue;
            }
            const sourceIsArray = Array.isArray(source);
            if (sourceIsArray && (typeof destination !== "object" || !destination || !Array.isArray(destination))) {
                destination = [];
            }
            else if (!sourceIsArray &&
                (typeof destination !== "object" || !destination || Array.isArray(destination))) {
                destination = {};
            }
            for (const key in source) {
                if (key === "__proto__") {
                    continue;
                }
                const sourceDict = source;
                const value = sourceDict[key];
                const isObject = typeof value === "object";
                const destDict = destination;
                destDict[key] =
                    isObject && Array.isArray(value)
                        ? value.map((v) => Utils.deepExtend(destDict[key], v))
                        : Utils.deepExtend(destDict[key], value);
            }
        }
        return destination;
    }
    static isDivModeEnabled(mode, divs) {
        return divs instanceof Array
            ? !!divs.find((t) => t.enable && Utils.isInArray(mode, t.mode))
            : Utils.isInArray(mode, divs.mode);
    }
    static divModeExecute(mode, divs, callback) {
        if (divs instanceof Array) {
            for (const div of divs) {
                const divMode = div.mode;
                const divEnabled = div.enable;
                if (divEnabled && Utils.isInArray(mode, divMode)) {
                    Utils.singleDivModeExecute(div, callback);
                }
            }
        }
        else {
            const divMode = divs.mode;
            const divEnabled = divs.enable;
            if (divEnabled && Utils.isInArray(mode, divMode)) {
                Utils.singleDivModeExecute(divs, callback);
            }
        }
    }
    static singleDivModeExecute(div, callback) {
        const selectors = div.selectors;
        if (selectors instanceof Array) {
            for (const selector of selectors) {
                callback(selector, div);
            }
        }
        else {
            callback(selectors, div);
        }
    }
    static divMode(divs, element) {
        if (!element || !divs) {
            return;
        }
        if (divs instanceof Array) {
            return divs.find((d) => checkSelector(element, d.selectors));
        }
        else if (checkSelector(element, divs.selectors)) {
            return divs;
        }
    }
    static circleBounceDataFromParticle(p) {
        return {
            position: p.getPosition(),
            radius: p.getRadius(),
            mass: p.getMass(),
            velocity: p.velocity,
            factor: {
                horizontal: NumberUtils_1.NumberUtils.getValue(p.options.bounce.horizontal),
                vertical: NumberUtils_1.NumberUtils.getValue(p.options.bounce.vertical),
            },
        };
    }
    static circleBounce(p1, p2) {
        const xVelocityDiff = p1.velocity.x;
        const yVelocityDiff = p1.velocity.y;
        const pos1 = p1.position;
        const pos2 = p2.position;
        const xDist = pos2.x - pos1.x;
        const yDist = pos2.y - pos1.y;
        if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {
            const angle = -Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);
            const m1 = p1.mass;
            const m2 = p2.mass;
            const u1 = p1.velocity.rotate(angle);
            const u2 = p2.velocity.rotate(angle);
            const v1 = NumberUtils_1.NumberUtils.collisionVelocity(u1, u2, m1, m2);
            const v2 = NumberUtils_1.NumberUtils.collisionVelocity(u2, u1, m1, m2);
            const vFinal1 = v1.rotate(-angle);
            const vFinal2 = v2.rotate(-angle);
            p1.velocity.x = vFinal1.x * p1.factor.horizontal;
            p1.velocity.y = vFinal1.y * p1.factor.vertical;
            p2.velocity.x = vFinal2.x * p2.factor.horizontal;
            p2.velocity.y = vFinal2.y * p2.factor.vertical;
        }
    }
    static rectBounce(particle, divBounds) {
        const pPos = particle.getPosition();
        const size = particle.getRadius();
        const bounds = Utils.calculateBounds(pPos, size);
        const resH = rectSideBounce({
            min: bounds.left,
            max: bounds.right,
        }, {
            min: bounds.top,
            max: bounds.bottom,
        }, {
            min: divBounds.left,
            max: divBounds.right,
        }, {
            min: divBounds.top,
            max: divBounds.bottom,
        }, particle.velocity.x, NumberUtils_1.NumberUtils.getValue(particle.options.bounce.horizontal));
        if (resH.bounced) {
            if (resH.velocity !== undefined) {
                particle.velocity.x = resH.velocity;
            }
            if (resH.position !== undefined) {
                particle.position.x = resH.position;
            }
        }
        const resV = rectSideBounce({
            min: bounds.top,
            max: bounds.bottom,
        }, {
            min: bounds.left,
            max: bounds.right,
        }, {
            min: divBounds.top,
            max: divBounds.bottom,
        }, {
            min: divBounds.left,
            max: divBounds.right,
        }, particle.velocity.y, NumberUtils_1.NumberUtils.getValue(particle.options.bounce.vertical));
        if (resV.bounced) {
            if (resV.velocity !== undefined) {
                particle.velocity.y = resV.velocity;
            }
            if (resV.position !== undefined) {
                particle.position.y = resV.position;
            }
        }
    }
}
exports.Utils = Utils;


/***/ }),

/***/ "./node_modules/tsparticles/dist/Utils/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tsparticles/dist/Utils/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(/*! ./CanvasUtils */ "./node_modules/tsparticles/dist/Utils/CanvasUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./Circle */ "./node_modules/tsparticles/dist/Utils/Circle.js"), exports);
__exportStar(__webpack_require__(/*! ./CircleWarp */ "./node_modules/tsparticles/dist/Utils/CircleWarp.js"), exports);
__exportStar(__webpack_require__(/*! ./ColorUtils */ "./node_modules/tsparticles/dist/Utils/ColorUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./Constants */ "./node_modules/tsparticles/dist/Utils/Constants.js"), exports);
__exportStar(__webpack_require__(/*! ./EventListeners */ "./node_modules/tsparticles/dist/Utils/EventListeners.js"), exports);
__exportStar(__webpack_require__(/*! ./NumberUtils */ "./node_modules/tsparticles/dist/Utils/NumberUtils.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins */ "./node_modules/tsparticles/dist/Utils/Plugins.js"), exports);
__exportStar(__webpack_require__(/*! ./Point */ "./node_modules/tsparticles/dist/Utils/Point.js"), exports);
__exportStar(__webpack_require__(/*! ./QuadTree */ "./node_modules/tsparticles/dist/Utils/QuadTree.js"), exports);
__exportStar(__webpack_require__(/*! ./Range */ "./node_modules/tsparticles/dist/Utils/Range.js"), exports);
__exportStar(__webpack_require__(/*! ./Rectangle */ "./node_modules/tsparticles/dist/Utils/Rectangle.js"), exports);
__exportStar(__webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/Utils.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/tsparticles/dist/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsParticles = exports.pJSDom = exports.particlesJS = exports.Main = exports.Utils = exports.Constants = exports.ColorUtils = exports.CanvasUtils = void 0;
const pjs_1 = __webpack_require__(/*! ./pjs */ "./node_modules/tsparticles/dist/pjs.js");
const main_1 = __webpack_require__(/*! ./main */ "./node_modules/tsparticles/dist/main.js");
Object.defineProperty(exports, "Main", { enumerable: true, get: function () { return main_1.Main; } });
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
Object.defineProperty(exports, "CanvasUtils", { enumerable: true, get: function () { return Utils_1.CanvasUtils; } });
Object.defineProperty(exports, "ColorUtils", { enumerable: true, get: function () { return Utils_1.ColorUtils; } });
Object.defineProperty(exports, "Constants", { enumerable: true, get: function () { return Utils_1.Constants; } });
Object.defineProperty(exports, "Utils", { enumerable: true, get: function () { return Utils_1.Utils; } });
const tsParticles = new main_1.Main();
exports.tsParticles = tsParticles;
tsParticles.init();
const { particlesJS, pJSDom } = pjs_1.initPjs(tsParticles);
exports.particlesJS = particlesJS;
exports.pJSDom = pJSDom;
__exportStar(__webpack_require__(/*! ./Core/Particle/Vector */ "./node_modules/tsparticles/dist/Core/Particle/Vector.js"), exports);
__exportStar(__webpack_require__(/*! ./Core/Container */ "./node_modules/tsparticles/dist/Core/Container.js"), exports);
__exportStar(__webpack_require__(/*! ./Enums */ "./node_modules/tsparticles/dist/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins/Absorbers/Enums */ "./node_modules/tsparticles/dist/Plugins/Absorbers/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins/Emitters/Enums */ "./node_modules/tsparticles/dist/Plugins/Emitters/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Plugins/PolygonMask/Enums */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/Enums/index.js"), exports);
__exportStar(__webpack_require__(/*! ./Types */ "./node_modules/tsparticles/dist/Types/index.js"), exports);


/***/ }),

/***/ "./node_modules/tsparticles/dist/main.js":
/*!***********************************************!*\
  !*** ./node_modules/tsparticles/dist/main.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const main_slim_1 = __webpack_require__(/*! ./main.slim */ "./node_modules/tsparticles/dist/main.slim.js");
const AbsorbersPlugin_1 = __webpack_require__(/*! ./Plugins/Absorbers/AbsorbersPlugin */ "./node_modules/tsparticles/dist/Plugins/Absorbers/AbsorbersPlugin.js");
const EmittersPlugin_1 = __webpack_require__(/*! ./Plugins/Emitters/EmittersPlugin */ "./node_modules/tsparticles/dist/Plugins/Emitters/EmittersPlugin.js");
const PolygonMaskPlugin_1 = __webpack_require__(/*! ./Plugins/PolygonMask/PolygonMaskPlugin */ "./node_modules/tsparticles/dist/Plugins/PolygonMask/PolygonMaskPlugin.js");
class Main extends main_slim_1.MainSlim {
    constructor() {
        super();
        this.addPlugin(AbsorbersPlugin_1.AbsorbersPlugin);
        this.addPlugin(EmittersPlugin_1.EmittersPlugin);
        this.addPlugin(PolygonMaskPlugin_1.PolygonMaskPlugin);
    }
}
exports.Main = Main;


/***/ }),

/***/ "./node_modules/tsparticles/dist/main.slim.js":
/*!****************************************************!*\
  !*** ./node_modules/tsparticles/dist/main.slim.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _initialized;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainSlim = void 0;
const SquareDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/SquareDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/SquareDrawer.js");
const TextDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/TextDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/TextDrawer.js");
const ImageDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/ImageDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/ImageDrawer.js");
const Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/tsparticles/dist/Utils/index.js");
const Types_1 = __webpack_require__(/*! ./Enums/Types */ "./node_modules/tsparticles/dist/Enums/Types/index.js");
const LineDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/LineDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/LineDrawer.js");
const CircleDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/CircleDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/CircleDrawer.js");
const TriangleDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/TriangleDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/TriangleDrawer.js");
const StarDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/StarDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/StarDrawer.js");
const PolygonDrawer_1 = __webpack_require__(/*! ./ShapeDrawers/PolygonDrawer */ "./node_modules/tsparticles/dist/ShapeDrawers/PolygonDrawer.js");
const Loader_1 = __webpack_require__(/*! ./Core/Loader */ "./node_modules/tsparticles/dist/Core/Loader.js");
class MainSlim {
    constructor() {
        _initialized.set(this, void 0);
        __classPrivateFieldSet(this, _initialized, false);
        const squareDrawer = new SquareDrawer_1.SquareDrawer();
        const textDrawer = new TextDrawer_1.TextDrawer();
        const imageDrawer = new ImageDrawer_1.ImageDrawer();
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.line, new LineDrawer_1.LineDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.circle, new CircleDrawer_1.CircleDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.edge, squareDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.square, squareDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.triangle, new TriangleDrawer_1.TriangleDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.star, new StarDrawer_1.StarDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.polygon, new PolygonDrawer_1.PolygonDrawer());
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.char, textDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.character, textDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.image, imageDrawer);
        Utils_1.Plugins.addShapeDrawer(Types_1.ShapeType.images, imageDrawer);
    }
    init() {
        if (!__classPrivateFieldGet(this, _initialized)) {
            __classPrivateFieldSet(this, _initialized, true);
        }
    }
    loadFromArray(tagId, options, index) {
        return __awaiter(this, void 0, void 0, function* () {
            return Loader_1.Loader.load(tagId, options, index);
        });
    }
    load(tagId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Loader_1.Loader.load(tagId, options);
        });
    }
    set(id, element, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Loader_1.Loader.set(id, element, options);
        });
    }
    loadJSON(tagId, pathConfigJson, index) {
        return Loader_1.Loader.loadJSON(tagId, pathConfigJson, index);
    }
    setOnClickHandler(callback) {
        Loader_1.Loader.setOnClickHandler(callback);
    }
    dom() {
        return Loader_1.Loader.dom();
    }
    domItem(index) {
        return Loader_1.Loader.domItem(index);
    }
    addShape(shape, drawer, init, afterEffect, destroy) {
        let customDrawer;
        if (typeof drawer === "function") {
            customDrawer = {
                afterEffect: afterEffect,
                destroy: destroy,
                draw: drawer,
                init: init,
            };
        }
        else {
            customDrawer = drawer;
        }
        Utils_1.Plugins.addShapeDrawer(shape, customDrawer);
    }
    addPreset(preset, options) {
        Utils_1.Plugins.addPreset(preset, options);
    }
    addPlugin(plugin) {
        Utils_1.Plugins.addPlugin(plugin);
    }
    addPathGenerator(name, generator) {
        Utils_1.Plugins.addPathGenerator(name, generator);
    }
}
exports.MainSlim = MainSlim;
_initialized = new WeakMap();


/***/ }),

/***/ "./node_modules/tsparticles/dist/pjs.js":
/*!**********************************************!*\
  !*** ./node_modules/tsparticles/dist/pjs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.initPjs = void 0;
const initPjs = (main) => {
    const particlesJS = (tagId, options) => {
        return main.load(tagId, options);
    };
    particlesJS.load = (tagId, pathConfigJson, callback) => {
        main.loadJSON(tagId, pathConfigJson).then((container) => {
            if (container) {
                callback(container);
            }
        });
    };
    particlesJS.setOnClickHandler = (callback) => {
        main.setOnClickHandler(callback);
    };
    const pJSDom = main.dom();
    return { particlesJS, pJSDom };
};
exports.initPjs = initPjs;


/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Home; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ "./node_modules/next/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_particles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-particles-js */ "./node_modules/react-particles-js/index.js");
/* harmony import */ var react_particles_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_particles_js__WEBPACK_IMPORTED_MODULE_3__);



var _jsxFileName = "C:\\Users\\Andrew Yang\\Projects\\Tutorials\\SpaceX Launch Stats\\client\\pages\\index.js",
    _s = $RefreshSig$();




function Home() {
  _s();

  var router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"])();
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "d-flex flex-column",
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_particles_js__WEBPACK_IMPORTED_MODULE_3___default.a, {
        width: '100vw',
        height: '96vh',
        params: {
          polygon: {
            scale: 2,
            move: {
              radius: 3
            },
            draw: {
              stroke: {
                color: 'rgb(51, 168, 143)'
              }
            }
          }
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 11,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "container d-flex align-items-center justify-content-center align-self-center",
        style: {
          position: "absolute",
          top: 0,
          height: "90vh"
        },
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
          className: "d-flex flex-column align-items-center justify-content-around",
          style: {
            height: "40vh"
          },
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("img", {
            src: "/assets/images/SpaceXLogoFull.png",
            alt: "SpaceX Logo",
            className: "img-fluid d-block",
            onClick: function onClick() {
              window.open("https://www.spacex.com/", "_ blank");
            },
            style: {
              width: 700,
              cursor: "pointer"
            }
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 33,
            columnNumber: 13
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
            className: "d-flex w-50 justify-content-around flex-wrap",
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("button", {
              type: "button",
              "class": "btn btn-primary mb-4",
              onClick: function onClick() {
                return router.push("launch_generator");
              },
              children: "Launch Generator"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 43,
              columnNumber: 15
            }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("button", {
              type: "button",
              "class": "btn btn-primary mb-4",
              children: "Launch Search"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 50,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 42,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 29,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 9
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("footer", {
        className: "text-center",
        style: {
          position: 'absolute',
          bottom: 40,
          width: '100%'
        },
        children: ["Developed by ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          href: "https://www.github.com/andytubeee",
          children: "Andrew Yang"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 57,
          columnNumber: 24
        }, this), " \xA9 ", new Date().getFullYear()]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 56,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }, this)
  }, void 0, false);
}

_s(Home, "fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=", false, function () {
  return [next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"]];
});

_c = Home;

var _c;

$RefreshReg$(_c, "Home");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VxdWFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wYXJ0aWNsZXMtanMvY2pzL3BhcnRpY2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBhcnRpY2xlcy1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvQ29yZS9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvQ29udGFpbmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL0ZyYW1lTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvQ29yZS9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUvSW5mZWN0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUvSW50ZXJhY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL1BhcnRpY2xlL01vdmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL1BhcnRpY2xlL1VwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0NvcmUvUGFydGljbGUvVmVjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9Db3JlL1BhcnRpY2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvQ29yZS9SZXRpbmEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL0FuaW1hdGlvblN0YXR1cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvRGlyZWN0aW9ucy9Nb3ZlRGlyZWN0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9EaXJlY3Rpb25zL091dE1vZGVEaXJlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL0RpcmVjdGlvbnMvUm90YXRlRGlyZWN0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9EaXJlY3Rpb25zL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9JbnRlcmFjdGl2aXR5RGV0ZWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9DbGlja01vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL0NvbGxpc2lvbk1vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL0Rlc3Ryb3lNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9EaXZNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9Ib3Zlck1vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL091dE1vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL1NpemVNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb2Rlcy9UaGVtZU1vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Nb3ZlRGlyZWN0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9PdXRNb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qb2x5Z29uTWFza0lubGluZUFycmFuZ2VtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qb2x5Z29uTWFza01vdmVUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qb2x5Z29uTWFza1R5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL1Byb2Nlc3NCdWJibGVUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Sb3RhdGVEaXJlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL1NoYXBlVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvVHlwZXMvRGVzdHJveVR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL1R5cGVzL0RpdlR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL1R5cGVzL1Byb2Nlc3NCdWJibGVUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9UeXBlcy9TaGFwZVR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0VudW1zL1R5cGVzL1N0YXJ0VmFsdWVUeXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9UeXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvRW51bXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9FeHRlcm5hbC9BdHRyYWN0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9FeHRlcm5hbC9Cb3VuY2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvQnViYmxlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL0V4dGVybmFsL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL0V4dGVybmFsL0dyYWJiZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9FeHRlcm5hbC9MaWdodGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvUmVwdWxzZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L0ludGVyYWN0aW9ucy9FeHRlcm5hbC9UcmFpbE1ha2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvUGFydGljbGVzL0F0dHJhY3Rvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL1BhcnRpY2xlcy9Db2xsaWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL1BhcnRpY2xlcy9JbmZlY3Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvSW50ZXJhY3Rpb25zL1BhcnRpY2xlcy9MaWdodGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9JbnRlcmFjdGlvbnMvUGFydGljbGVzL0xpbmtlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0FuaW1hdGlvbk9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9CYWNrZ3JvdW5kL0JhY2tncm91bmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9CYWNrZ3JvdW5kTWFzay9CYWNrZ3JvdW5kTWFzay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0JhY2tncm91bmRNYXNrL0JhY2tncm91bmRNYXNrQ292ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9Db2xvckFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0Z1bGxTY3JlZW4vRnVsbFNjcmVlbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0luZmVjdGlvbi9JbmZlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbmZlY3Rpb24vSW5mZWN0aW9uU3RhZ2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0V2ZW50cy9DbGlja0V2ZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9FdmVudHMvRGl2RXZlbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0V2ZW50cy9FdmVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0V2ZW50cy9Ib3ZlckV2ZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9FdmVudHMvUGFyYWxsYXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L0ludGVyYWN0aXZpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0F0dHJhY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0JvdW5jZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvQnViYmxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9CdWJibGVCYXNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9CdWJibGVEaXYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL0Nvbm5lY3RMaW5rcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvR3JhYi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvR3JhYkxpbmtzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9MaWdodC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvTGlnaHRBcmVhLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9MaWdodEdyYWRpZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvSW50ZXJhY3Rpdml0eS9Nb2Rlcy9MaWdodFNoYWRvdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvTW9kZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1B1c2guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1JlbW92ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvUmVwdWxzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL0ludGVyYWN0aXZpdHkvTW9kZXMvUmVwdWxzZUJhc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1JlcHVsc2VEaXYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1Nsb3cuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9JbnRlcmFjdGl2aXR5L01vZGVzL1RyYWlsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvTWFudWFsUGFydGljbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9Nb3Rpb24vTW90aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvTW90aW9uL01vdGlvblJlZHVjZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL09wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9PcHRpb25zQ29sb3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvQW5pbWF0YWJsZUNvbG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL0JvdW5jZS9Cb3VuY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvQm91bmNlL0JvdW5jZUZhY3Rvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Db2xsaXNpb25zL0NvbGxpc2lvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvQ29sbGlzaW9ucy9Db2xsaXNpb25zT3ZlcmxhcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9EZXN0cm95L0Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvRGVzdHJveS9TcGxpdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9EZXN0cm95L1NwbGl0RmFjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL0Rlc3Ryb3kvU3BsaXRSYXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL0hzbEFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9MaWZlL0xpZmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTGlmZS9MaWZlRGVsYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTGlmZS9MaWZlRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTGlua3MvTGlua3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTGlua3MvTGlua3NTaGFkb3cuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTGlua3MvTGlua3NUcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Nb3ZlL0F0dHJhY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTW92ZS9Nb3ZlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL01vdmUvTW92ZUFuZ2xlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL01vdmUvTW92ZUdyYXZpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTW92ZS9PdXRNb2Rlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Nb3ZlL1BhdGgvUGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Nb3ZlL1BhdGgvUGF0aERlbGF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL01vdmUvVHJhaWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTnVtYmVyL0RlbnNpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvTnVtYmVyL1BhcnRpY2xlc051bWJlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9PcGFjaXR5L09wYWNpdHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvT3BhY2l0eS9PcGFjaXR5QW5pbWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1BhcnRpY2xlc09wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvUm90YXRlL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Sb3RhdGUvUm90YXRlQW5pbWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1NoYWRvdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9TaGFwZS9TaGFwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9TaXplL1NpemUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvU2l6ZS9TaXplQW5pbWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUGFydGljbGVzL1N0cm9rZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9Ud2lua2xlL1R3aW5rbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvVHdpbmtsZS9Ud2lua2xlVmFsdWVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUmFuZG9tLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvUmVzcG9uc2l2ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvT3B0aW9ucy9DbGFzc2VzL1RoZW1lL1RoZW1lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvVGhlbWUvVGhlbWVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9PcHRpb25zL0NsYXNzZXMvVmFsdWVXaXRoUmFuZG9tLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0Fic29yYmVycy9BYnNvcmJlckluc3RhbmNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0Fic29yYmVycy9BYnNvcmJlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvQWJzb3JiZXJzL0Fic29yYmVyc1BsdWdpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9BYnNvcmJlcnMvRW51bXMvQWJzb3JiZXJDbGlja01vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvQWJzb3JiZXJzL0VudW1zL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0Fic29yYmVycy9PcHRpb25zL0NsYXNzZXMvQWJzb3JiZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvQWJzb3JiZXJzL09wdGlvbnMvQ2xhc3Nlcy9BYnNvcmJlclNpemUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvRW1pdHRlcnMvRW1pdHRlckluc3RhbmNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL0VtaXR0ZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL0VtaXR0ZXJzUGx1Z2luLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL0VudW1zL0VtaXR0ZXJDbGlja01vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvRW1pdHRlcnMvRW51bXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvRW1pdHRlcnMvT3B0aW9ucy9DbGFzc2VzL0VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvRW1pdHRlcnMvT3B0aW9ucy9DbGFzc2VzL0VtaXR0ZXJMaWZlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL0VtaXR0ZXJzL09wdGlvbnMvQ2xhc3Nlcy9FbWl0dGVyUmF0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9FbWl0dGVycy9PcHRpb25zL0NsYXNzZXMvRW1pdHRlclNpemUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svRW51bXMvSW5saW5lQXJyYW5nZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svRW51bXMvTW92ZVR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svRW51bXMvVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9FbnVtcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9PcHRpb25zL0NsYXNzZXMvRHJhdy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9PcHRpb25zL0NsYXNzZXMvRHJhd1N0cm9rZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9PcHRpb25zL0NsYXNzZXMvSW5saW5lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9QbHVnaW5zL1BvbHlnb25NYXNrL09wdGlvbnMvQ2xhc3Nlcy9Mb2NhbFN2Zy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9PcHRpb25zL0NsYXNzZXMvTW92ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9PcHRpb25zL0NsYXNzZXMvUG9seWdvbk1hc2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svUG9seWdvbk1hc2tJbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvUGx1Z2lucy9Qb2x5Z29uTWFzay9Qb2x5Z29uTWFza1BsdWdpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL0NpcmNsZURyYXdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL0ltYWdlRHJhd2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9TaGFwZURyYXdlcnMvTGluZURyYXdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL1BvbHlnb25EcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9Qb2x5Z29uRHJhd2VyQmFzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL1NxdWFyZURyYXdlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvU2hhcGVEcmF3ZXJzL1N0YXJEcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1NoYXBlRHJhd2Vycy9UZXh0RHJhd2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9TaGFwZURyYXdlcnMvVHJpYW5nbGVEcmF3ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1R5cGVzL1JhbmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1R5cGVzL1JlY3Vyc2l2ZVBhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1R5cGVzL1NoYXBlRGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVHlwZXMvU2hhcGVEcmF3ZXJGdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1R5cGVzL1NpbmdsZU9yTXVsdGlwbGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1R5cGVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9DYW52YXNVdGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvQ2lyY2xlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9DaXJjbGVXYXJwLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9Db2xvclV0aWxzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL0V2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9OdW1iZXJVdGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvUGx1Z2lucy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L1V0aWxzL1F1YWRUcmVlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9SYW5nZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9VdGlscy9VdGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RzcGFydGljbGVzL2Rpc3QvVXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9tYWluLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHNwYXJ0aWNsZXMvZGlzdC9tYWluLnNsaW0uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c3BhcnRpY2xlcy9kaXN0L3Bqcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanMiXSwibmFtZXMiOlsiSG9tZSIsInJvdXRlciIsInVzZVJvdXRlciIsInBvbHlnb24iLCJzY2FsZSIsIm1vdmUiLCJyYWRpdXMiLCJkcmF3Iiwic3Ryb2tlIiwiY29sb3IiLCJwb3NpdGlvbiIsInRvcCIsImhlaWdodCIsIndpbmRvdyIsIm9wZW4iLCJ3aWR0aCIsImN1cnNvciIsInB1c2giLCJib3R0b20iLCJEYXRlIiwiZ2V0RnVsbFllYXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFjO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQywrQ0FBUzs7QUFFNUI7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDTkEsZ0JBQWdCLG1CQUFPLENBQUMseURBQWM7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsMkRBQWU7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHFEQUFZO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxxREFBWTtBQUNsQyxjQUFjLG1CQUFPLENBQUMscURBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDL0JBLHFCQUFxQixtQkFBTyxDQUFDLG1FQUFtQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsK0RBQWlCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFpQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQywrREFBaUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyWGE7QUFDYjtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHNFQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFVO0FBQ25DLHVCQUF1QixtQkFBTyxDQUFDLDRFQUFnQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBNEI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQVU7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsd0JBQXdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0ZGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pGYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkdBQXFDO0FBQy9ELG1CQUFtQixtQkFBTyxDQUFDLCtHQUFzQztBQUNqRSxrQkFBa0IsbUJBQU8sQ0FBQyw2R0FBcUM7QUFDL0Qsb0JBQW9CLG1CQUFPLENBQUMsaUhBQXVDO0FBQ25FLGlCQUFpQixtQkFBTyxDQUFDLDZHQUFxQztBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyxtSEFBd0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsaUhBQXVDO0FBQ2xFLG1CQUFtQixtQkFBTyxDQUFDLGlIQUF1QztBQUNsRSxxQkFBcUIsbUJBQU8sQ0FBQyxtSEFBd0M7QUFDckUsb0JBQW9CLG1CQUFPLENBQUMsaUhBQXVDO0FBQ25FLGtCQUFrQixtQkFBTyxDQUFDLCtHQUFzQztBQUNoRSxrQkFBa0IsbUJBQU8sQ0FBQyw2R0FBcUM7QUFDL0Qsa0JBQWtCLG1CQUFPLENBQUMsNkdBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pEYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9KYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsMkJBQTJCLG1CQUFPLENBQUMscUhBQXlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RHYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyxvSEFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRixpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLHFHQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsRUFBRSxTQUFTLE1BQU07QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLHdHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsdUdBQWlCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLG1HQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHVHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyx1R0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEVBQUUsU0FBUyxNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMkdBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFHQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMscUdBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMseUdBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsNkdBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywrRkFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBVztBQUNyQyxlQUFlLG1CQUFPLENBQUMsMkZBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQVU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDJGQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLGlHQUFXO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQywyRkFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQywrRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyx1R0FBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyx5R0FBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMseUdBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw4RkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMscUhBQStCO0FBQy9ELDJCQUEyQixtQkFBTyxDQUFDLG1IQUE4QjtBQUNqRSx5QkFBeUIsbUJBQU8sQ0FBQyx5SEFBaUM7QUFDbEUscUJBQXFCLG1CQUFPLENBQUMseUdBQXlCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLHFHQUF1QjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBeUI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMseUZBQWlCO0FBQzFDLHlCQUF5QixtQkFBTyxDQUFDLDJGQUFrQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxtRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9JYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBaUI7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNYYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLG9HQUFrQjtBQUMzQyw0QkFBNEIsbUJBQU8sQ0FBQyxzSEFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLDJGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx1R0FBZTtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGlHQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdHQUFhO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLHNHQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGlHQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsaUdBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHFHQUFlO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLHlHQUFpQjtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeERhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDRGQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBUztBQUNqQyxlQUFlLG1CQUFPLENBQUMsZ0dBQWE7QUFDcEMsb0JBQW9CLG1CQUFPLENBQUMsZ0dBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsb0dBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsOEZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNIYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxxR0FBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLG9HQUEwQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMkZBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9CYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsaUhBQW9CO0FBQ3ZELDBCQUEwQixtQkFBTyxDQUFDLGlHQUF1QjtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDakQsMkJBQTJCLG1CQUFPLENBQUMsbUdBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLCtGQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywyRkFBYTtBQUNwQywwQkFBMEIsbUJBQU8sQ0FBQyxxSEFBMEI7QUFDNUQsa0JBQWtCLG1CQUFPLENBQUMsdUdBQW1CO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLCtGQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywyRkFBYTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsbUhBQXlCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLHVHQUFtQjtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDJGQUFhO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLG1HQUFpQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakdhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyw4R0FBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDLDBCQUEwQixtQkFBTyxDQUFDLGlHQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMseUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZHYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsd0dBQWlCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLGlHQUF1QjtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDM0MsMkJBQTJCLG1CQUFPLENBQUMsbUdBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHVHQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQywyR0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsMkZBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMsNkZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsMkZBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25JYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsaUdBQW9CO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGlIQUE0QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuSGE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQyxhQUFhLEVBQUUsRUFBRTtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLGlIQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpRkFBUzs7Ozs7Ozs7Ozs7OztBQ3hGakI7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0ZBQWtGOzs7Ozs7Ozs7Ozs7O0FDTnRFO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0MsYUFBYSxFQUFFLEVBQUU7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLHlHQUFxQjs7Ozs7Ozs7Ozs7OztBQ1o3QjtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUdBQWdCO0FBQy9DLHVCQUF1QixtQkFBTyxDQUFDLGlIQUEwQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Q2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLHVIQUE2QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLHNIQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxxREFBcUQ7QUFDaEg7QUFDQTtBQUNBLHVCQUF1QixRQUFRLElBQUksUUFBUSxLQUFLLFFBQVEsS0FBSyxxREFBcUQ7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2YWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBVTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBYTtBQUN6QztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvVGE7QUFDYiw4Q0FBOEMsY0FB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RCxPQUFPO0FBQ3BFLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNB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QUEsZUFIWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFERixlQVFFO0FBQVEsa0JBQUksRUFBQyxRQUFiO0FBQXNCLHVCQUFNLHNCQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxvQkFSRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBYkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQVhGLGVBOENFO0FBQVEsaUJBQVMsRUFBQyxhQUFsQjtBQUFnQyxhQUFLLEVBQUU7QUFBRVAsa0JBQVEsRUFBRSxVQUFaO0FBQXdCUSxnQkFBTSxFQUFFLEVBQWhDO0FBQW9DSCxlQUFLLEVBQUU7QUFBM0MsU0FBdkM7QUFBQSxpREFDZTtBQUFHLGNBQUksRUFBQyxtQ0FBUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFEZixZQUNtRixJQUFJSSxJQUFKLEdBQVdDLFdBQVgsRUFEbkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBOUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGLG1CQURGO0FBc0REOztHQXpEdUJwQixJO1VBQ1BFLHFEOzs7S0FET0YsSSIsImZpbGUiOiJzdGF0aWMvd2VicGFjay9wYWdlcy9pbmRleC5jNjExZDdlZTdmODE2YmVjYTAyZS5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwiIWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpZVtyXT10W3JdfShleHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIHIobil7aWYodFtuXSlyZXR1cm4gdFtuXS5leHBvcnRzO3ZhciBpPXRbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHIpLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIHIubT1lLHIuYz10LHIuZD1mdW5jdGlvbihlLHQsbil7ci5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0Om59KX0sci5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9cihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIGkgaW4gZSlyLmQobixpLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsaSkpO3JldHVybiBufSxyLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHIuZCh0LFwiYVwiLHQpLHR9LHIubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sci5wPVwiXCIscihyLnM9MSl9KFtmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwicmVhY3RcIil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsbil7dm9pZCAwPT09biYmKG49ciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KX06ZnVuY3Rpb24oZSx0LHIsbil7dm9pZCAwPT09biYmKG49ciksZVtuXT10W3JdfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fHQuaGFzT3duUHJvcGVydHkocil8fG4odCxlLHIpfSxvPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUGFydGljbGVzPXZvaWQgMDt2YXIgYT1vKHIoMikpO3QuUGFydGljbGVzPWEuZGVmYXVsdCxpKHIoMTApLHQpLGkocigxMSksdCksaShyKDEyKSx0KSxpKHIoMTMpLHQpLGkocigxNCksdCksaShyKDE1KSx0KSxpKHIoMTYpLHQpLGkocigxNyksdCksaShyKDE4KSx0KSxpKHIoMTkpLHQpLGkocigyMCksdCksaShyKDIxKSx0KSx0LmRlZmF1bHQ9YS5kZWZhdWx0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19ZnVuY3Rpb24gbyhlLHQscil7cmV0dXJuKG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1mdW5jdGlvbihlLHQpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiZudWxsIT09KGU9bChlKSk7KTtyZXR1cm4gZX0oZSx0KTtpZihuKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7cmV0dXJuIGkuZ2V0P2kuZ2V0LmNhbGwocik6aS52YWx1ZX19KShlLHQscnx8ZSl9ZnVuY3Rpb24gYShlLHQpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX1mdW5jdGlvbiBzKGUpe3ZhciB0PWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciByLG49bChlKTtpZih0KXt2YXIgaT1sKHRoaXMpLmNvbnN0cnVjdG9yO3I9UmVmbGVjdC5jb25zdHJ1Y3Qobixhcmd1bWVudHMsaSl9ZWxzZSByPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB1KHRoaXMscil9fWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PW4odCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/YyhlKTp0fWZ1bmN0aW9uIGMoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gbChlKXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9dmFyIGY9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPXIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSl9OmZ1bmN0aW9uKGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPXIpLGVbbl09dFtyXX0pLHA9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksZD10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCIhPT1yJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiZmKHQsZSxyKTtyZXR1cm4gcCh0LGUpLHR9LHk9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHY9ZChyKDApKSxiPXIoMCksaD15KHIoMykpLG09cig0KSxnPXIoNSksUD1yKDYpLE89cig5KSxfPWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmYShlLHQpfShmLGUpO3ZhciB0LHIsbix1PXMoZik7ZnVuY3Rpb24gZihlKXt2YXIgdDtyZXR1cm4gZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGYpLCh0PXUuY2FsbCh0aGlzLGUpKS5zdGF0ZT17Y2FudmFzOnZvaWQgMCxsaWJyYXJ5OnZvaWQgMH0sdC5sb2FkQ2FudmFzPXQubG9hZENhbnZhcy5iaW5kKGModCkpLHR9cmV0dXJuIHQ9Ziwocj1be2tleTpcImJ1aWxkUGFydGljbGVzTGlicmFyeVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e2lmKHZvaWQgMD09PXdpbmRvdylyZXR1cm4gbnVsbH1jYXRjaChlKXtyZXR1cm4gbnVsbH1PLnRzUGFydGljbGVzLmluaXQoKTt2YXIgcj1uZXcgbS5PcHRpb25zO3IubG9hZChQLmRlZmF1bHRQYXJhbXMpLHIubG9hZCh0KTt2YXIgbj1uZXcgZy5Db250YWluZXIoZSxyKTtyZXR1cm4gdGhpcy5wcm9wcy5wYXJ0aWNsZXNSZWYmJih0aGlzLnByb3BzLnBhcnRpY2xlc1JlZi5jdXJyZW50PW4pLG59fSx7a2V5OlwicmVmcmVzaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj10aGlzLnN0YXRlLmNhbnZhcztyJiYodGhpcy5kZXN0cm95KCksdGhpcy5zZXRTdGF0ZSh7bGlicmFyeTp0aGlzLmJ1aWxkUGFydGljbGVzTGlicmFyeShlLmlkLGUucGFyYW1zKX0sKGZ1bmN0aW9uKCl7dC5sb2FkQ2FudmFzKHIpfSkpKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnN0YXRlLmxpYnJhcnkmJnRoaXMuc3RhdGUubGlicmFyeS5kZXN0cm95KCl9fSx7a2V5OlwibG9hZENhbnZhc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7ZSYmdGhpcy5zZXRTdGF0ZSh7Y2FudmFzOmV9LChmdW5jdGlvbigpe3ZhciByPXQuc3RhdGUubGlicmFyeTtyJiYoci5jYW52YXMubG9hZENhbnZhcyhlKSxyLnN0YXJ0KCkpfSkpfX0se2tleTpcInNob3VsZENvbXBvbmVudFVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiFoLmRlZmF1bHQoZSx0aGlzLnByb3BzKX19LHtrZXk6XCJjb21wb25lbnREaWRVcGRhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucmVmcmVzaCh0aGlzLnByb3BzKX19LHtrZXk6XCJmb3JjZVVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZWZyZXNoKHRoaXMucHJvcHMpLG8obChmLnByb3RvdHlwZSksXCJmb3JjZVVwZGF0ZVwiLHRoaXMpLmNhbGwodGhpcyl9fSx7a2V5OlwiY29tcG9uZW50RGlkTW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc2V0U3RhdGUoe2xpYnJhcnk6dGhpcy5idWlsZFBhcnRpY2xlc0xpYnJhcnkodGhpcy5wcm9wcy5pZCx0aGlzLnByb3BzLnBhcmFtcyl9KX19LHtrZXk6XCJjb21wb25lbnRXaWxsVW5tb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95KCksdGhpcy5zZXRTdGF0ZSh7bGlicmFyeTp2b2lkIDB9KX19LHtrZXk6XCJyZW5kZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMucHJvcHMsdD1lLndpZHRoLHI9ZS5oZWlnaHQsbj1lLmNsYXNzTmFtZSxpPWUuY2FudmFzQ2xhc3NOYW1lLG89ZS5pZDtyZXR1cm4gdi5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpuLGlkOm99LHYuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLHtyZWY6dGhpcy5sb2FkQ2FudmFzLGNsYXNzTmFtZTppLHN0eWxlOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnByb3BzLnN0eWxlKSx7d2lkdGg6dCxoZWlnaHQ6cn0pfSkpfX1dKSYmaSh0LnByb3RvdHlwZSxyKSxuJiZpKHQsbiksZn0oYi5Db21wb25lbnQpO3QuZGVmYXVsdD1fLF8uZGVmYXVsdFByb3BzPXt3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIscGFyYW1zOlAuZGVmYXVsdFBhcmFtcyxzdHlsZTp7fSxpZDpcInRzcGFydGljbGVzXCJ9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwibG9kYXNoL2lzRXF1YWxcIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlcy9kaXN0L09wdGlvbnMvQ2xhc3Nlcy9PcHRpb25zXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9Db3JlL0NvbnRhaW5lclwiKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdFBhcmFtcz12b2lkIDA7dmFyIG49cig3KSxpPXIoOCk7dC5kZWZhdWx0UGFyYW1zPXtwYXJ0aWNsZXM6e251bWJlcjp7dmFsdWU6NDAsbWF4Oi0xLGRlbnNpdHk6e2VuYWJsZTohMSxhcmVhOjEyMDB9fSxjb2xvcjp7dmFsdWU6XCIjRkZGXCJ9LHNoYXBlOnt0eXBlOm4uU2hhcGVUeXBlLmNpcmNsZSxwb2x5Z29uOntzaWRlczo1fSxpbWFnZTp7c3JjOlwiXCIsd2lkdGg6MTAwLGhlaWdodDoxMDB9fSxzdHJva2U6e3dpZHRoOjAsY29sb3I6XCIjMDAwMDAwXCJ9LG9wYWNpdHk6e3ZhbHVlOi41LHJhbmRvbTohMSxhbmltOntlbmFibGU6ITAsc3BlZWQ6MSxtaW5pbXVtVmFsdWU6LjEsc3luYzohMX19LHNpemU6e3ZhbHVlOjEscmFuZG9tOiExLGFuaW06e2VuYWJsZTohMSxzcGVlZDo0MCxtaW5pbXVtVmFsdWU6MCxzeW5jOiExfX0sbGlua3M6e2VuYWJsZTohMCxkaXN0YW5jZToxNTAsY29sb3I6XCIjRkZGXCIsb3BhY2l0eTouNix3aWR0aDoxLHNoYWRvdzp7ZW5hYmxlOiExLGJsdXI6NSxjb2xvcjpcImxpbWVcIn19LG1vdmU6e2VuYWJsZTohMCxzcGVlZDozLGRpcmVjdGlvbjpuLk1vdmVEaXJlY3Rpb24ubm9uZSxyYW5kb206ITEsc3RyYWlnaHQ6ITEsb3V0TW9kZTpuLk91dE1vZGUuYm91bmNlLGJvdW5jZTohMCxhdHRyYWN0OntlbmFibGU6ITEscm90YXRlWDozZTMscm90YXRlWTozZTN9fX0saW50ZXJhY3Rpdml0eTp7ZGV0ZWN0c09uOm4uSW50ZXJhY3Rpdml0eURldGVjdC5jYW52YXMsZXZlbnRzOntvbkhvdmVyOntlbmFibGU6ITEsbW9kZTpuLkhvdmVyTW9kZS5ncmFifSxvbkNsaWNrOntlbmFibGU6ITEsbW9kZTpuLkNsaWNrTW9kZS5yZXB1bHNlfSxyZXNpemU6ITB9LG1vZGVzOntncmFiOntkaXN0YW5jZToxODAsbGlua3M6e29wYWNpdHk6LjM1fX0sYnViYmxlOntkaXN0YW5jZToyMDAsc2l6ZTo4MCxkdXJhdGlvbjouNH0scmVwdWxzZTp7ZGlzdGFuY2U6MTAwLGR1cmF0aW9uOjV9LHB1c2g6e3F1YW50aXR5OjR9LHJlbW92ZTp7cXVhbnRpdHk6Mn19fSxkZXRlY3RSZXRpbmE6ITAsZnBzTGltaXQ6OTk5LHBvbHlnb246e2VuYWJsZTohMSxzY2FsZToxLHR5cGU6aS5UeXBlLmlubGluZSxpbmxpbmU6e2FycmFuZ2VtZW50OmkuSW5saW5lQXJyYW5nZW1lbnQub25lUGVyUG9pbnR9LGRyYXc6e2VuYWJsZTohMSxzdHJva2U6e3dpZHRoOi41LGNvbG9yOlwicmdiYSgyNTUsIDI1NSwgMjU1LCAuMSlcIn19LG1vdmU6e3JhZGl1czoxMCx0eXBlOmkuTW92ZVR5cGUucGF0aH0sdXJsOlwiXCJ9fX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXNcIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlcy9kaXN0L1BsdWdpbnMvUG9seWdvbk1hc2svUG9seWdvbk1hc2tQbHVnaW5cIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlc1wiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvSW50ZXJhY3Rpdml0eURldGVjdFwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvTW92ZURpcmVjdGlvblwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvT3V0TW9kZVwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvUG9seWdvbk1hc2tJbmxpbmVBcnJhbmdlbWVudFwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvUG9seWdvbk1hc2tNb3ZlVHlwZVwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvUG9seWdvbk1hc2tUeXBlXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9Qcm9jZXNzQnViYmxlVHlwZVwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvUm90YXRlRGlyZWN0aW9uXCIpfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1yZXF1aXJlKFwidHNwYXJ0aWNsZXMvZGlzdC9FbnVtcy9TaGFwZVR5cGVcIil9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJlcXVpcmUoXCJ0c3BhcnRpY2xlcy9kaXN0L0VudW1zL01vZGVzL0NsaWNrTW9kZVwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvRGl2TW9kZVwiKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cmVxdWlyZShcInRzcGFydGljbGVzL2Rpc3QvRW51bXMvTW9kZXMvSG92ZXJNb2RlXCIpfV0pKTsiLCJjb25zdCBSZWFjdFBhcnRpY2xlcyA9IHJlcXVpcmUoJy4vY2pzL3BhcnRpY2xlcycpO1xuZm9yIChsZXQga2V5IGluIFJlYWN0UGFydGljbGVzKSB7XG4gICAgUmVhY3RQYXJ0aWNsZXMuZGVmYXVsdFtrZXldID0gUmVhY3RQYXJ0aWNsZXNba2V5XTtcbn1cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQYXJ0aWNsZXMuZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FudmFzID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbmNsYXNzIENhbnZhcyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnNpemUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRDYW52YXMgPSBmYWxzZTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnVsbFNjcmVlbi5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsU3R5bGUgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIGVsZW1lbnQuc3R5bGUpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS56SW5kZXggPSBvcHRpb25zLmZ1bGxTY3JlZW4uekluZGV4LnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IChfYiA9IChfYSA9IHRoaXMub3JpZ2luYWxTdHlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuekluZGV4ID0gKF9kID0gKF9jID0gdGhpcy5vcmlnaW5hbFN0eWxlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuekluZGV4KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gKF9mID0gKF9lID0gdGhpcy5vcmlnaW5hbFN0eWxlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9wKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IChfaCA9IChfZyA9IHRoaXMub3JpZ2luYWxTdHlsZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlZnQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IChfayA9IChfaiA9IHRoaXMub3JpZ2luYWxTdHlsZSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLndpZHRoKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKF9tID0gKF9sID0gdGhpcy5vcmlnaW5hbFN0eWxlKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdmVyID0gb3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5jb3ZlcjtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb3Zlci5jb2xvcjtcbiAgICAgICAgY29uc3QgdHJhaWwgPSBvcHRpb25zLnBhcnRpY2xlcy5tb3ZlLnRyYWlsO1xuICAgICAgICBjb25zdCBjb3ZlclJnYiA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKGNvbG9yKTtcbiAgICAgICAgdGhpcy5jb3ZlckNvbG9yID1cbiAgICAgICAgICAgIGNvdmVyUmdiICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcjogY292ZXJSZ2IucixcbiAgICAgICAgICAgICAgICAgICAgZzogY292ZXJSZ2IuZyxcbiAgICAgICAgICAgICAgICAgICAgYjogY292ZXJSZ2IuYixcbiAgICAgICAgICAgICAgICAgICAgYTogY292ZXIub3BhY2l0eSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudHJhaWxGaWxsQ29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYih0cmFpbC5maWxsQ29sb3IpO1xuICAgICAgICB0aGlzLmluaXRCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMucGFpbnQoKTtcbiAgICB9XG4gICAgbG9hZENhbnZhcyhjYW52YXMsIGdlbmVyYXRlZENhbnZhcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghY2FudmFzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFV0aWxzXzEuQ29uc3RhbnRzLmNhbnZhc0NsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlZENhbnZhcykge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRDYW52YXMgPSBnZW5lcmF0ZWRDYW52YXMgIT09IG51bGwgJiYgZ2VuZXJhdGVkQ2FudmFzICE9PSB2b2lkIDAgPyBnZW5lcmF0ZWRDYW52YXMgOiB0aGlzLmdlbmVyYXRlZENhbnZhcztcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gY2FudmFzO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3R5bGUgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIHRoaXMuZWxlbWVudC5zdHlsZSk7XG4gICAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLnNpemUud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuZWxlbWVudC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJldGluYS5pbml0KCk7XG4gICAgICAgIHRoaXMuaW5pdEJhY2tncm91bmQoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZWRDYW52YXMpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuY2xlYXIodGhpcy5jb250ZXh0LCB0aGlzLnNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhaW50KCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5lbmFibGUgJiYgb3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5jb3ZlciAmJiB0aGlzLmNvdmVyQ29sb3IpIHtcbiAgICAgICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuY2xlYXIodGhpcy5jb250ZXh0LCB0aGlzLnNpemUpO1xuICAgICAgICAgICAgdGhpcy5wYWludEJhc2UoVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYih0aGlzLmNvdmVyQ29sb3IsIHRoaXMuY292ZXJDb2xvci5hKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50QmFzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgdHJhaWwgPSBvcHRpb25zLnBhcnRpY2xlcy5tb3ZlLnRyYWlsO1xuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kTWFzay5lbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFpbC5lbmFibGUgJiYgdHJhaWwubGVuZ3RoID4gMCAmJiB0aGlzLnRyYWlsRmlsbENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50QmFzZShVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKHRoaXMudHJhaWxGaWxsQ29sb3IsIDEgLyB0cmFpbC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuY2xlYXIodGhpcy5jb250ZXh0LCB0aGlzLnNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuc2V0UmVzcG9uc2l2ZSh0aGlzLnNpemUud2lkdGgsIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbywgY29udGFpbmVyLm9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGljbGVzLnNldERlbnNpdHkoKTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIGNvbnRhaW5lci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnJlc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLnJlc2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNvbnRhaW5lci5jYW52YXMuc2l6ZTtcbiAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgc2l6ZS53aWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCAqIHB4UmF0aW87XG4gICAgICAgIHNpemUuaGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCAqIHB4UmF0aW87XG4gICAgICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplRmFjdG9yID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoIC8gb2xkU2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0IC8gb2xkU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXdDb25uZWN0TGluZShwMSwgcDIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZVN0eWxlID0gdGhpcy5saW5lU3R5bGUocDEsIHAyKTtcbiAgICAgICAgaWYgKCFsaW5lU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3MxID0gcDEuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgcG9zMiA9IHAyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd0Nvbm5lY3RMaW5lKGN0eCwgKF9hID0gcDEubGlua3NXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jb250YWluZXIucmV0aW5hLmxpbmtzV2lkdGgsIGxpbmVTdHlsZSwgcG9zMSwgcG9zMik7XG4gICAgfVxuICAgIGRyYXdHcmFiTGluZShwYXJ0aWNsZSwgbGluZUNvbG9yLCBvcGFjaXR5LCBtb3VzZVBvcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBjdHggPSBjb250YWluZXIuY2FudmFzLmNvbnRleHQ7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmVnaW5Qb3MgPSBwYXJ0aWNsZS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBVdGlsc18xLkNhbnZhc1V0aWxzLmRyYXdHcmFiTGluZShjdHgsIChfYSA9IHBhcnRpY2xlLmxpbmtzV2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRhaW5lci5yZXRpbmEubGlua3NXaWR0aCwgYmVnaW5Qb3MsIG1vdXNlUG9zLCBsaW5lQ29sb3IsIG9wYWNpdHkpO1xuICAgIH1cbiAgICBkcmF3UGFydGljbGVTaGFkb3cocGFydGljbGUsIG1vdXNlUG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHNfMS5DYW52YXNVdGlscy5kcmF3UGFydGljbGVTaGFkb3codGhpcy5jb250YWluZXIsIHRoaXMuY29udGV4dCwgcGFydGljbGUsIG1vdXNlUG9zKTtcbiAgICB9XG4gICAgZHJhd0xpbmtUcmlhbmdsZShwMSwgbGluazEsIGxpbmsyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgcDIgPSBsaW5rMS5kZXN0aW5hdGlvbjtcbiAgICAgICAgY29uc3QgcDMgPSBsaW5rMi5kZXN0aW5hdGlvbjtcbiAgICAgICAgY29uc3QgdHJpYW5nbGVPcHRpb25zID0gcDEub3B0aW9ucy5saW5rcy50cmlhbmdsZXM7XG4gICAgICAgIGNvbnN0IG9wYWNpdHlUcmlhbmdsZSA9IChfYSA9IHRyaWFuZ2xlT3B0aW9ucy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAobGluazEub3BhY2l0eSArIGxpbmsyLm9wYWNpdHkpIC8gMjtcbiAgICAgICAgaWYgKG9wYWNpdHlUcmlhbmdsZSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zMSA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHBvczIgPSBwMi5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBwb3MzID0gcDMuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvczEsIHBvczIpID4gY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlIHx8XG4gICAgICAgICAgICBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvczMsIHBvczIpID4gY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlIHx8XG4gICAgICAgICAgICBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvczMsIHBvczEpID4gY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbG9yVHJpYW5nbGUgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYih0cmlhbmdsZU9wdGlvbnMuY29sb3IpO1xuICAgICAgICBpZiAoIWNvbG9yVHJpYW5nbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzT3B0aW9ucyA9IHAxLm9wdGlvbnMubGlua3M7XG4gICAgICAgICAgICBjb25zdCBsaW5rQ29sb3IgPSBsaW5rc09wdGlvbnMuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9ycy5nZXQobGlua3NPcHRpb25zLmlkKVxuICAgICAgICAgICAgICAgIDogY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9yO1xuICAgICAgICAgICAgY29sb3JUcmlhbmdsZSA9IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRMaW5rQ29sb3IocDEsIHAyLCBsaW5rQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sb3JUcmlhbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd0xpbmtUcmlhbmdsZShjdHgsIHBvczEsIHBvczIsIHBvczMsIG9wdGlvbnMuYmFja2dyb3VuZE1hc2suZW5hYmxlLCBvcHRpb25zLmJhY2tncm91bmRNYXNrLmNvbXBvc2l0ZSwgY29sb3JUcmlhbmdsZSwgb3BhY2l0eVRyaWFuZ2xlKTtcbiAgICB9XG4gICAgZHJhd0xpbmtMaW5lKHAxLCBsaW5rKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHAyID0gbGluay5kZXN0aW5hdGlvbjtcbiAgICAgICAgbGV0IG9wYWNpdHkgPSBsaW5rLm9wYWNpdHk7XG4gICAgICAgIGNvbnN0IHBvczEgPSBwMS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBwb3MyID0gcDIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2xvckxpbmU7XG4gICAgICAgIGNvbnN0IHR3aW5rbGUgPSBwMS5vcHRpb25zLnR3aW5rbGUubGluZXM7XG4gICAgICAgIGlmICh0d2lua2xlLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdHdpbmtsZUZyZXEgPSB0d2lua2xlLmZyZXF1ZW5jeTtcbiAgICAgICAgICAgIGNvbnN0IHR3aW5rbGVSZ2IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYih0d2lua2xlLmNvbG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHR3aW5rbGluZyA9IE1hdGgucmFuZG9tKCkgPCB0d2lua2xlRnJlcTtcbiAgICAgICAgICAgIGlmICh0d2lua2xpbmcgJiYgdHdpbmtsZVJnYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29sb3JMaW5lID0gdHdpbmtsZVJnYjtcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gdHdpbmtsZS5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29sb3JMaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rc09wdGlvbnMgPSBwMS5vcHRpb25zLmxpbmtzO1xuICAgICAgICAgICAgY29uc3QgbGlua0NvbG9yID0gbGlua3NPcHRpb25zLmlkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGNvbnRhaW5lci5wYXJ0aWNsZXMubGlua3NDb2xvcnMuZ2V0KGxpbmtzT3B0aW9ucy5pZClcbiAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5wYXJ0aWNsZXMubGlua3NDb2xvcjtcbiAgICAgICAgICAgIGNvbG9yTGluZSA9IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRMaW5rQ29sb3IocDEsIHAyLCBsaW5rQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29sb3JMaW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkdGggPSAoX2EgPSBwMS5saW5rc1dpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250YWluZXIucmV0aW5hLmxpbmtzV2lkdGg7XG4gICAgICAgIGNvbnN0IG1heERpc3RhbmNlID0gKF9iID0gcDEubGlua3NEaXN0YW5jZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlO1xuICAgICAgICBVdGlsc18xLkNhbnZhc1V0aWxzLmRyYXdMaW5rTGluZShjdHgsIHdpZHRoLCBwb3MxLCBwb3MyLCBtYXhEaXN0YW5jZSwgY29udGFpbmVyLmNhbnZhcy5zaXplLCBwMS5vcHRpb25zLmxpbmtzLndhcnAsIG9wdGlvbnMuYmFja2dyb3VuZE1hc2suZW5hYmxlLCBvcHRpb25zLmJhY2tncm91bmRNYXNrLmNvbXBvc2l0ZSwgY29sb3JMaW5lLCBvcGFjaXR5LCBwMS5vcHRpb25zLmxpbmtzLnNoYWRvdyk7XG4gICAgfVxuICAgIGRyYXdQYXJ0aWNsZShwYXJ0aWNsZSwgZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoKChfYSA9IHBhcnRpY2xlLmltYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9hZGVkKSA9PT0gZmFsc2UgfHwgcGFydGljbGUuc3Bhd25pbmcgfHwgcGFydGljbGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGZDb2xvciA9IHBhcnRpY2xlLmdldEZpbGxDb2xvcigpO1xuICAgICAgICBjb25zdCBwc0NvbG9yID0gKF9iID0gcGFydGljbGUuZ2V0U3Ryb2tlQ29sb3IoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcGZDb2xvcjtcbiAgICAgICAgaWYgKCFwZkNvbG9yICYmICFwc0NvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBPcHRpb25zID0gcGFydGljbGUub3B0aW9ucztcbiAgICAgICAgY29uc3QgdHdpbmtsZSA9IHBPcHRpb25zLnR3aW5rbGUucGFydGljbGVzO1xuICAgICAgICBjb25zdCB0d2lua2xlRnJlcSA9IHR3aW5rbGUuZnJlcXVlbmN5O1xuICAgICAgICBjb25zdCB0d2lua2xlUmdiID0gVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2IodHdpbmtsZS5jb2xvcik7XG4gICAgICAgIGNvbnN0IHR3aW5rbGluZyA9IHR3aW5rbGUuZW5hYmxlICYmIE1hdGgucmFuZG9tKCkgPCB0d2lua2xlRnJlcTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gcGFydGljbGUuZ2V0UmFkaXVzKCk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSB0d2lua2xpbmcgPyB0d2lua2xlLm9wYWNpdHkgOiAoX2MgPSBwYXJ0aWNsZS5idWJibGUub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcGFydGljbGUub3BhY2l0eS52YWx1ZTtcbiAgICAgICAgY29uc3QgaW5mZWN0aW9uU3RhZ2UgPSBwYXJ0aWNsZS5pbmZlY3Rlci5pbmZlY3Rpb25TdGFnZTtcbiAgICAgICAgY29uc3QgaW5mZWN0aW9uID0gb3B0aW9ucy5pbmZlY3Rpb247XG4gICAgICAgIGNvbnN0IGluZmVjdGlvblN0YWdlcyA9IGluZmVjdGlvbi5zdGFnZXM7XG4gICAgICAgIGNvbnN0IGluZmVjdGlvbkNvbG9yID0gaW5mZWN0aW9uU3RhZ2UgIT09IHVuZGVmaW5lZCA/IGluZmVjdGlvblN0YWdlc1tpbmZlY3Rpb25TdGFnZV0uY29sb3IgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGluZmVjdGlvblJnYiA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKGluZmVjdGlvbkNvbG9yKTtcbiAgICAgICAgY29uc3QgZkNvbG9yID0gdHdpbmtsaW5nICYmIHR3aW5rbGVSZ2IgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0d2lua2xlUmdiXG4gICAgICAgICAgICA6IGluZmVjdGlvblJnYiAhPT0gbnVsbCAmJiBpbmZlY3Rpb25SZ2IgIT09IHZvaWQgMCA/IGluZmVjdGlvblJnYiA6IChwZkNvbG9yID8gVXRpbHNfMS5Db2xvclV0aWxzLmhzbFRvUmdiKHBmQ29sb3IpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgc0NvbG9yID0gdHdpbmtsaW5nICYmIHR3aW5rbGVSZ2IgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0d2lua2xlUmdiXG4gICAgICAgICAgICA6IGluZmVjdGlvblJnYiAhPT0gbnVsbCAmJiBpbmZlY3Rpb25SZ2IgIT09IHZvaWQgMCA/IGluZmVjdGlvblJnYiA6IChwc0NvbG9yID8gVXRpbHNfMS5Db2xvclV0aWxzLmhzbFRvUmdiKHBzQ29sb3IpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgZmlsbENvbG9yVmFsdWUgPSBmQ29sb3IgIT09IHVuZGVmaW5lZCA/IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IoZkNvbG9yLCBvcGFjaXR5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgKCFmaWxsQ29sb3JWYWx1ZSAmJiAhc0NvbG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cm9rZUNvbG9yVmFsdWUgPSBzQ29sb3IgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKHNDb2xvciwgKF9kID0gcGFydGljbGUuc3Ryb2tlLm9wYWNpdHkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG9wYWNpdHkpXG4gICAgICAgICAgICA6IGZpbGxDb2xvclZhbHVlO1xuICAgICAgICB0aGlzLmRyYXdQYXJ0aWNsZUxpbmtzKHBhcnRpY2xlKTtcbiAgICAgICAgaWYgKHJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd1BhcnRpY2xlKHRoaXMuY29udGFpbmVyLCB0aGlzLmNvbnRleHQsIHBhcnRpY2xlLCBkZWx0YSwgZmlsbENvbG9yVmFsdWUsIHN0cm9rZUNvbG9yVmFsdWUsIG9wdGlvbnMuYmFja2dyb3VuZE1hc2suZW5hYmxlLCBvcHRpb25zLmJhY2tncm91bmRNYXNrLmNvbXBvc2l0ZSwgcmFkaXVzLCBvcGFjaXR5LCBwYXJ0aWNsZS5vcHRpb25zLnNoYWRvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhd1BhcnRpY2xlTGlua3MocGFydGljbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGFydGljbGVzID0gY29udGFpbmVyLnBhcnRpY2xlcztcbiAgICAgICAgY29uc3QgcE9wdGlvbnMgPSBwYXJ0aWNsZS5vcHRpb25zO1xuICAgICAgICBpZiAocGFydGljbGUubGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHAxTGlua3MgPSBwYXJ0aWNsZS5saW5rcy5maWx0ZXIoKGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rRnJlcSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMuZ2V0TGlua0ZyZXF1ZW5jeShwYXJ0aWNsZSwgbC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtGcmVxIDw9IHBPcHRpb25zLmxpbmtzLmZyZXF1ZW5jeTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5rIG9mIHAxTGlua3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IGxpbmsuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHBPcHRpb25zLmxpbmtzLnRyaWFuZ2xlcy5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua3MgPSBwMUxpbmtzLm1hcCgobCkgPT4gbC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzID0gcDIubGlua3MuZmlsdGVyKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rRnJlcSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMuZ2V0TGlua0ZyZXF1ZW5jeShwMiwgdC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlua0ZyZXEgPD0gcDIub3B0aW9ucy5saW5rcy5mcmVxdWVuY3kgJiYgbGlua3MuaW5kZXhPZih0LmRlc3RpbmF0aW9uKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdmVydGljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwMyA9IHZlcnRleC5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmlhbmdsZUZyZXEgPSBwYXJ0aWNsZXMuZ2V0VHJpYW5nbGVGcmVxdWVuY3kocGFydGljbGUsIHAyLCBwMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFuZ2xlRnJlcSA+IHBPcHRpb25zLmxpbmtzLnRyaWFuZ2xlcy5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmtUcmlhbmdsZShwYXJ0aWNsZSwgbGluaywgdmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGluay5vcGFjaXR5ID4gMCAmJiBjb250YWluZXIucmV0aW5hLmxpbmtzV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmtMaW5lKHBhcnRpY2xlLCBsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXdQbHVnaW4ocGx1Z2luLCBkZWx0YSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzXzEuQ2FudmFzVXRpbHMuZHJhd1BsdWdpbih0aGlzLmNvbnRleHQsIHBsdWdpbiwgZGVsdGEpO1xuICAgIH1cbiAgICBkcmF3TGlnaHQobW91c2VQb3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBVdGlsc18xLkNhbnZhc1V0aWxzLmRyYXdMaWdodCh0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250ZXh0LCBtb3VzZVBvcyk7XG4gICAgfVxuICAgIHBhaW50QmFzZShiYXNlQ29sb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBVdGlsc18xLkNhbnZhc1V0aWxzLnBhaW50QmFzZSh0aGlzLmNvbnRleHQsIHRoaXMuc2l6ZSwgYmFzZUNvbG9yKTtcbiAgICB9XG4gICAgbGluZVN0eWxlKHAxLCBwMikge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBjb25uZWN0T3B0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5jb25uZWN0O1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5DYW52YXNVdGlscy5ncmFkaWVudCh0aGlzLmNvbnRleHQsIHAxLCBwMiwgY29ubmVjdE9wdGlvbnMubGlua3Mub3BhY2l0eSk7XG4gICAgfVxuICAgIGluaXRCYWNrZ3JvdW5kKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IG9wdGlvbnMuYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgY29uc3QgZWxlbWVudFN0eWxlID0gZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnN0eWxlO1xuICAgICAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kLmNvbG9yKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKGJhY2tncm91bmQuY29sb3IpO1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID8gVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihjb2xvciwgYmFja2dyb3VuZC5vcGFjaXR5KSA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50U3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZC5pbWFnZSB8fCBcIlwiO1xuICAgICAgICBlbGVtZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gYmFja2dyb3VuZC5wb3NpdGlvbiB8fCBcIlwiO1xuICAgICAgICBlbGVtZW50U3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IGJhY2tncm91bmQucmVwZWF0IHx8IFwiXCI7XG4gICAgICAgIGVsZW1lbnRTdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGJhY2tncm91bmQuc2l6ZSB8fCBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGFpbmVyID0gdm9pZCAwO1xuY29uc3QgQ2FudmFzXzEgPSByZXF1aXJlKFwiLi9DYW52YXNcIik7XG5jb25zdCBQYXJ0aWNsZXNfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlc1wiKTtcbmNvbnN0IFJldGluYV8xID0gcmVxdWlyZShcIi4vUmV0aW5hXCIpO1xuY29uc3QgRnJhbWVNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9GcmFtZU1hbmFnZXJcIik7XG5jb25zdCBPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgVmVjdG9yXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZS9WZWN0b3JcIik7XG5jbGFzcyBDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBzb3VyY2VPcHRpb25zLCAuLi5wcmVzZXRzKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mcHNMaW1pdCA9IDYwO1xuICAgICAgICB0aGlzLmZpcnN0U3RhcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnBhZ2VIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc291cmNlT3B0aW9ucyA9IHNvdXJjZU9wdGlvbnM7XG4gICAgICAgIHRoaXMucmV0aW5hID0gbmV3IFJldGluYV8xLlJldGluYSh0aGlzKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzXzEuQ2FudmFzKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IG5ldyBQYXJ0aWNsZXNfMS5QYXJ0aWNsZXModGhpcyk7XG4gICAgICAgIHRoaXMuZHJhd2VyID0gbmV3IEZyYW1lTWFuYWdlcl8xLkZyYW1lTWFuYWdlcih0aGlzKTtcbiAgICAgICAgdGhpcy5wYXRoR2VuZXJhdG9yID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gVmVjdG9yXzEuVmVjdG9yLmNyZWF0ZSgwLCAwKTtcbiAgICAgICAgICAgICAgICB2Lmxlbmd0aCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgdi5hbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0OiAoKSA9PiB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmludGVyYWN0aXZpdHkgPSB7XG4gICAgICAgICAgICBtb3VzZToge1xuICAgICAgICAgICAgICAgIGNsaWNraW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5idWJibGUgPSB7fTtcbiAgICAgICAgdGhpcy5yZXB1bHNlID0geyBwYXJ0aWNsZXM6IFtdIH07XG4gICAgICAgIHRoaXMuYXR0cmFjdCA9IHsgcGFydGljbGVzOiBbXSB9O1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhd2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kZW5zaXR5ID0gMTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG5ldyBPcHRpb25zXzEuT3B0aW9ucygpO1xuICAgICAgICB0aGlzLmFjdHVhbE9wdGlvbnMgPSBuZXcgT3B0aW9uc18xLk9wdGlvbnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcmVzZXQgb2YgcHJlc2V0cykge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5sb2FkKFV0aWxzXzEuUGx1Z2lucy5nZXRQcmVzZXQocHJlc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcGVzID0gVXRpbHNfMS5QbHVnaW5zLmdldFN1cHBvcnRlZFNoYXBlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2hhcGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkcmF3ZXIgPSBVdGlsc18xLlBsdWdpbnMuZ2V0U2hhcGVEcmF3ZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZHJhd2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3ZXJzLnNldCh0eXBlLCBkcmF3ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmxvYWQodGhpcy5fc291cmNlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG5ldyBVdGlsc18xLkV2ZW50TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB0aGlzLmludGVyc2VjdGlvbk1hbmFnZXIoZW50cmllcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IHNvdXJjZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VPcHRpb25zO1xuICAgIH1cbiAgICBwbGF5KGZvcmNlKSB7XG4gICAgICAgIGNvbnN0IG5lZWRzVXBkYXRlID0gdGhpcy5wYXVzZWQgfHwgZm9yY2U7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0U3RhcnQgJiYgIXRoaXMuYWN0dWFsT3B0aW9ucy5hdXRvUGxheSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ucGxheSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhd0FuaW1hdGlvbkZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFV0aWxzXzEuVXRpbHMuY2FuY2VsQW5pbWF0aW9uKHRoaXMuZHJhd0FuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRyYXdBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnBhdXNlKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBhZ2VIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICB0aGlzLmRyYXdBbmltYXRpb25GcmFtZSA9IFV0aWxzXzEuVXRpbHMuYW5pbWF0ZSgodGltZXN0YW1wKSA9PiB0aGlzLmRyYXdlci5uZXh0RnJhbWUodGltZXN0YW1wKSk7XG4gICAgfVxuICAgIGdldEFuaW1hdGlvblN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnBhdXNlZDtcbiAgICB9XG4gICAgc2V0Tm9pc2Uobm9pc2VPckdlbmVyYXRvciwgaW5pdCwgdXBkYXRlKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aChub2lzZU9yR2VuZXJhdG9yLCBpbml0LCB1cGRhdGUpO1xuICAgIH1cbiAgICBzZXRQYXRoKHBhdGhPckdlbmVyYXRvciwgaW5pdCwgdXBkYXRlKSB7XG4gICAgICAgIGlmICghcGF0aE9yR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoT3JHZW5lcmF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5wYXRoR2VuZXJhdG9yLmdlbmVyYXRlID0gcGF0aE9yR2VuZXJhdG9yO1xuICAgICAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhHZW5lcmF0b3IuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoR2VuZXJhdG9yLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXRoT3JHZW5lcmF0b3IuZ2VuZXJhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhHZW5lcmF0b3IuZ2VuZXJhdGUgPSBwYXRoT3JHZW5lcmF0b3IuZ2VuZXJhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aE9yR2VuZXJhdG9yLmluaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhHZW5lcmF0b3IuaW5pdCA9IHBhdGhPckdlbmVyYXRvci5pbml0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGhPckdlbmVyYXRvci51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhHZW5lcmF0b3IudXBkYXRlID0gcGF0aE9yR2VuZXJhdG9yLnVwZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVzdHJveSgpO1xuICAgICAgICBmb3IgKGNvbnN0IFssIGRyYXdlcl0gb2YgdGhpcy5kcmF3ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZHJhd2VyLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBkcmF3ZXIuZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmRyYXdlcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBleHBvcnRJbWcoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5leHBvcnRJbWFnZShjYWxsYmFjayk7XG4gICAgfVxuICAgIGV4cG9ydEltYWdlKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY2FudmFzLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0Jsb2IoY2FsbGJhY2ssIHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdm9pZCAwID8gdHlwZSA6IFwiaW1hZ2UvcG5nXCIsIHF1YWxpdHkpO1xuICAgIH1cbiAgICBleHBvcnRDb25maWd1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5hY3R1YWxPcHRpb25zLCB1bmRlZmluZWQsIDIpO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBuZXcgT3B0aW9uc18xLk9wdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3RTdGFydCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIHRoaXMucGFydGljbGVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLmludGVyYWN0aXZpdHkuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmludGVyYWN0aXZpdHkuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHBsdWdpbi5zdG9wKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnBsdWdpbnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMubGlua3NDb2xvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcnRpY2xlcy5ncmFiTGluZUNvbG9yO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXJ0aWNsZXMubGlua3NDb2xvcjtcbiAgICB9XG4gICAgbG9hZFRoZW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0dWFsT3B0aW9ucy5zZXRUaGVtZShuYW1lKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5hZGRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0aXZpdHkuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5pbnRlcmFjdGl2aXR5LmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3RhcnRBc3luYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHBsdWdpbi5zdGFydEFzeW5jKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbi5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0dWFsT3B0aW9ucyA9IG5ldyBPcHRpb25zXzEuT3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5hY3R1YWxPcHRpb25zLmxvYWQodGhpcy5fb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJldGluYS5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmFjdHVhbE9wdGlvbnMuc2V0UmVzcG9uc2l2ZSh0aGlzLmNhbnZhcy5zaXplLndpZHRoLCB0aGlzLnJldGluYS5waXhlbFJhdGlvLCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYWN0dWFsT3B0aW9ucy5zZXRUaGVtZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5mcHNMaW1pdCA9IHRoaXMuYWN0dWFsT3B0aW9ucy5mcHNMaW1pdCA+IDAgPyB0aGlzLmFjdHVhbE9wdGlvbnMuZnBzTGltaXQgOiA2MDtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVBsdWdpbnMgPSBVdGlsc18xLlBsdWdpbnMuZ2V0QXZhaWxhYmxlUGx1Z2lucyh0aGlzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBwbHVnaW5dIG9mIGF2YWlsYWJsZVBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMuc2V0KGlkLCBwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBkcmF3ZXJdIG9mIHRoaXMuZHJhd2Vycykge1xuICAgICAgICAgICAgICAgIGlmIChkcmF3ZXIuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBkcmF3ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbml0KHRoaXMuYWN0dWFsT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbi5pbml0QXN5bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBwbHVnaW4uaW5pdEFzeW5jKHRoaXMuYWN0dWFsT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5zZXREZW5zaXR5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnRlcnNlY3Rpb25NYW5hZ2VyKGVudHJpZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdHVhbE9wdGlvbnMucGF1c2VPbk91dHNpZGVWaWV3cG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldCAhPT0gdGhpcy5pbnRlcmFjdGl2aXR5LmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJhbWVNYW5hZ2VyID0gdm9pZCAwO1xuY2xhc3MgRnJhbWVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIG5leHRGcmFtZSh0aW1lc3RhbXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5sYXN0RnJhbWVUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPCBjb250YWluZXIubGFzdEZyYW1lVGltZSArIDEwMDAgLyBjb250YWluZXIuZnBzTGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZHJhdygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhVmFsdWUgPSB0aW1lc3RhbXAgLSBjb250YWluZXIubGFzdEZyYW1lVGltZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWx0YVZhbHVlLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogKDYwICogZGVsdGFWYWx1ZSkgLyAxMDAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5sYXN0RnJhbWVUaW1lID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5kcmF3KGRlbHRhKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZ2V0QW5pbWF0aW9uU3RhdHVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwidHNQYXJ0aWNsZXMgZXJyb3IgaW4gYW5pbWF0aW9uIGxvb3BcIiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZyYW1lTWFuYWdlciA9IEZyYW1lTWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvYWRlciA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbmNvbnN0IHRzUGFydGljbGVzRG9tID0gW107XG5mdW5jdGlvbiBmZXRjaEVycm9yKHN0YXR1c0NvZGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciB0c1BhcnRpY2xlcyAtIGZldGNoIHN0YXR1czogJHtzdGF0dXNDb2RlfWApO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB0c1BhcnRpY2xlcyAtIEZpbGUgY29uZmlnIG5vdCBmb3VuZFwiKTtcbn1cbmNsYXNzIExvYWRlciB7XG4gICAgc3RhdGljIGRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRzUGFydGljbGVzRG9tO1xuICAgIH1cbiAgICBzdGF0aWMgZG9tSXRlbShpbmRleCkge1xuICAgICAgICBjb25zdCBkb20gPSBMb2FkZXIuZG9tKCk7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkb21baW5kZXhdO1xuICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGRvbS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBzdGF0aWMgbG9hZCh0YWdJZCwgb3B0aW9ucywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhZ0lkKTtcbiAgICAgICAgICAgIGlmICghZG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIExvYWRlci5zZXQodGFnSWQsIGRvbUNvbnRhaW5lciwgb3B0aW9ucywgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHNldChpZCwgZG9tQ29udGFpbmVyLCBvcHRpb25zLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9wdGlvbnMgPSBvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkob3B0aW9ucywgaW5kZXgpIDogb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGRvbSA9IExvYWRlci5kb20oKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEluZGV4ID0gZG9tLmZpbmRJbmRleCgodikgPT4gdi5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBMb2FkZXIuZG9tSXRlbShvbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG9sZCAmJiAhb2xkLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICBvbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBkb20uc3BsaWNlKG9sZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FudmFzRWw7XG4gICAgICAgICAgICBsZXQgZ2VuZXJhdGVkQ2FudmFzO1xuICAgICAgICAgICAgaWYgKGRvbUNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNFbCA9IGRvbUNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRDYW52YXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FudmFzZXMgPSBkb21Db250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ2FudmFzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0VsID0gZXhpc3RpbmdDYW52YXNlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW52YXNFbC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0VsLmNsYXNzTmFtZSA9IFV0aWxzXzEuQ29uc3RhbnRzLmNhbnZhc0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZENhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ2FudmFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNFbC5jbGFzc05hbWUgPSBVdGlsc18xLkNvbnN0YW50cy5jYW52YXNDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzRWwuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvbUNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXNFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoaWQsIGN1cnJlbnRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvbGRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9tLnNwbGljZShvbGRJbmRleCwgMCwgbmV3SXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20ucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0l0ZW0uY2FudmFzLmxvYWRDYW52YXMoY2FudmFzRWwsIGdlbmVyYXRlZENhbnZhcyk7XG4gICAgICAgICAgICB5aWVsZCBuZXdJdGVtLnN0YXJ0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3SXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkSlNPTih0YWdJZCwganNvblVybCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGpzb25VcmwgaW5zdGFuY2VvZiBBcnJheSA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShqc29uVXJsLCBpbmRleCkgOiBqc29uVXJsO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmwpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvYWRlci5sb2FkKHRhZ0lkLCB5aWVsZCByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hFcnJvcihyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHNldEpTT04oaWQsIGRvbUNvbnRhaW5lciwganNvblVybCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChqc29uVXJsKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvYWRlci5zZXQoaWQsIGRvbUNvbnRhaW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZXRjaEVycm9yKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0T25DbGlja0hhbmRsZXIoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZG9tID0gTG9hZGVyLmRvbSgpO1xuICAgICAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgc2V0IGNsaWNrIGhhbmRsZXJzIGFmdGVyIGNhbGxpbmcgdHNQYXJ0aWNsZXMubG9hZCgpIG9yIHRzUGFydGljbGVzLmxvYWRKU09OKClcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkb21JdGVtIG9mIGRvbSkge1xuICAgICAgICAgICAgY29uc3QgZWwgPSBkb21JdGVtLmludGVyYWN0aXZpdHkuZWxlbWVudDtcbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsaWNrT3JUb3VjaEhhbmRsZXIgPSAoZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUl0ZW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHhSYXRpbyA9IGRvbUl0ZW0ucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zUmV0aW5hID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCAqIHB4UmF0aW8sXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvcy55ICogcHhSYXRpbyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlcyA9IGRvbUl0ZW0ucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5Q2lyY2xlKHBvc1JldGluYSwgZG9tSXRlbS5yZXRpbmEuc2l6ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBwYXJ0aWNsZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrSGFuZGxlciA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUl0ZW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IGU7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZUV2ZW50Lm9mZnNldFggfHwgbW91c2VFdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZUV2ZW50Lm9mZnNldFkgfHwgbW91c2VFdmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2xpY2tPclRvdWNoSGFuZGxlcihlLCBwb3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoU3RhcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb21JdGVtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb21JdGVtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUl0ZW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoZWQgJiYgIXRvdWNoTW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG91Y2hFdmVudCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb3VjaCA9IHRvdWNoRXZlbnQudG91Y2hlc1t0b3VjaEV2ZW50LnRvdWNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSAoX2EgPSBkb21JdGVtLmNhbnZhcy5lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGxhc3RUb3VjaC5jbGllbnRYIC0gKChfYiA9IGNhbnZhc1JlY3QgPT09IG51bGwgfHwgY2FudmFzUmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FudmFzUmVjdC5sZWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGxhc3RUb3VjaC5jbGllbnRZIC0gKChfYyA9IGNhbnZhc1JlY3QgPT09IG51bGwgfHwgY2FudmFzUmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FudmFzUmVjdC50b3ApICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjbGlja09yVG91Y2hIYW5kbGVyKGUsIHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0b3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdG91Y2hDYW5jZWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb21JdGVtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0b3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0b3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hFbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0b3VjaENhbmNlbEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGljbGUgPSB2b2lkIDA7XG5jb25zdCBVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZS9VcGRhdGVyXCIpO1xuY29uc3QgUGFydGljbGVzT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvUGFydGljbGVzT3B0aW9uc1wiKTtcbmNvbnN0IFNoYXBlXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9ucy9DbGFzc2VzL1BhcnRpY2xlcy9TaGFwZS9TaGFwZVwiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vRW51bXNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgSW5mZWN0ZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlL0luZmVjdGVyXCIpO1xuY29uc3QgTW92ZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlL01vdmVyXCIpO1xuY29uc3QgVmVjdG9yXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZS9WZWN0b3JcIik7XG5jbGFzcyBQYXJ0aWNsZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGNvbnRhaW5lciwgcG9zaXRpb24sIG92ZXJyaWRlT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5saW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmZpbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0UGF0aFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuYnJlYWthYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3BsaXRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubWlzcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9vcHMgPSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXNPcHRpb25zID0gbmV3IFBhcnRpY2xlc09wdGlvbnNfMS5QYXJ0aWNsZXNPcHRpb25zKCk7XG4gICAgICAgIHBhcnRpY2xlc09wdGlvbnMubG9hZChvcHRpb25zLnBhcnRpY2xlcyk7XG4gICAgICAgIGNvbnN0IHNoYXBlVHlwZSA9IHBhcnRpY2xlc09wdGlvbnMuc2hhcGUudHlwZTtcbiAgICAgICAgY29uc3QgcmVkdWNlRHVwbGljYXRlcyA9IHBhcnRpY2xlc09wdGlvbnMucmVkdWNlRHVwbGljYXRlcztcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlVHlwZSBpbnN0YW5jZW9mIEFycmF5ID8gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KHNoYXBlVHlwZSwgdGhpcy5pZCwgcmVkdWNlRHVwbGljYXRlcykgOiBzaGFwZVR5cGU7XG4gICAgICAgIGlmIChvdmVycmlkZU9wdGlvbnMgPT09IG51bGwgfHwgb3ZlcnJpZGVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZU9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZU9wdGlvbnMuc2hhcGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlU2hhcGVUeXBlID0gb3ZlcnJpZGVPcHRpb25zLnNoYXBlLnR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlU2hhcGVUeXBlIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KG92ZXJyaWRlU2hhcGVUeXBlLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvdmVycmlkZVNoYXBlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYXBlT3B0aW9ucyA9IG5ldyBTaGFwZV8xLlNoYXBlKCk7XG4gICAgICAgICAgICBzaGFwZU9wdGlvbnMubG9hZChvdmVycmlkZU9wdGlvbnMuc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZURhdGEgPSBzaGFwZU9wdGlvbnMub3B0aW9uc1t0aGlzLnNoYXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVEYXRhID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBzaGFwZURhdGEgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkoc2hhcGVEYXRhLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzaGFwZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlRGF0YSA9IHBhcnRpY2xlc09wdGlvbnMuc2hhcGUub3B0aW9uc1t0aGlzLnNoYXBlXTtcbiAgICAgICAgICAgIGlmIChzaGFwZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlRGF0YSA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgc2hhcGVEYXRhIGluc3RhbmNlb2YgQXJyYXkgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkoc2hhcGVEYXRhLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKSA6IHNoYXBlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJyaWRlT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZXNPcHRpb25zLmxvYWQob3ZlcnJpZGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuc2hhcGVEYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFydGljbGVzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZXNPcHRpb25zLmxvYWQoKF9iID0gdGhpcy5zaGFwZURhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0aWNsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsbCA9IChfZCA9IChfYyA9IHRoaXMuc2hhcGVEYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmlsbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5maWxsO1xuICAgICAgICB0aGlzLmNsb3NlID0gKF9mID0gKF9lID0gdGhpcy5zaGFwZURhdGEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jbG9zZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5jbG9zZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFydGljbGVzT3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXRoRGVsYXkgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKHRoaXMub3B0aW9ucy5tb3ZlLnBhdGguZGVsYXkpICogMTAwMDtcbiAgICAgICAgY29udGFpbmVyLnJldGluYS5pbml0UGFydGljbGUodGhpcyk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yO1xuICAgICAgICBjb25zdCBzaXplT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICBjb25zdCBzaXplVmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKHNpemVPcHRpb25zKSAqIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgcmFuZG9tU2l6ZSA9IHR5cGVvZiBzaXplT3B0aW9ucy5yYW5kb20gPT09IFwiYm9vbGVhblwiID8gc2l6ZU9wdGlvbnMucmFuZG9tIDogc2l6ZU9wdGlvbnMucmFuZG9tLmVuYWJsZTtcbiAgICAgICAgdGhpcy5zaXplID0ge1xuICAgICAgICAgICAgdmFsdWU6IHNpemVWYWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMubW92ZS5kaXJlY3Rpb247XG4gICAgICAgIHRoaXMuYnViYmxlID0ge1xuICAgICAgICAgICAgaW5SYW5nZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbFZlbG9jaXR5ID0gdGhpcy5jYWxjdWxhdGVWZWxvY2l0eSgpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5pbml0aWFsVmVsb2NpdHkuY29weSgpO1xuICAgICAgICBjb25zdCByb3RhdGVPcHRpb25zID0gdGhpcy5vcHRpb25zLnJvdGF0ZTtcbiAgICAgICAgdGhpcy5yb3RhdGUgPSB7XG4gICAgICAgICAgICB2YWx1ZTogKFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0UmFuZ2VWYWx1ZShyb3RhdGVPcHRpb25zLnZhbHVlKSAqIE1hdGguUEkpIC8gMTgwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcm90YXRlRGlyZWN0aW9uID0gcm90YXRlT3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIGlmIChyb3RhdGVEaXJlY3Rpb24gPT09IEVudW1zXzEuUm90YXRlRGlyZWN0aW9uLnJhbmRvbSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcbiAgICAgICAgICAgIHJvdGF0ZURpcmVjdGlvbiA9IGluZGV4ID4gMCA/IEVudW1zXzEuUm90YXRlRGlyZWN0aW9uLmNvdW50ZXJDbG9ja3dpc2UgOiBFbnVtc18xLlJvdGF0ZURpcmVjdGlvbi5jbG9ja3dpc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChyb3RhdGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Sb3RhdGVEaXJlY3Rpb24uY291bnRlckNsb2Nrd2lzZTpcbiAgICAgICAgICAgIGNhc2UgXCJjb3VudGVyQ2xvY2t3aXNlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Sb3RhdGVEaXJlY3Rpb24uY2xvY2t3aXNlOlxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlLnN0YXR1cyA9IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm90YXRlQW5pbWF0aW9uID0gdGhpcy5vcHRpb25zLnJvdGF0ZS5hbmltYXRpb247XG4gICAgICAgIGlmIChyb3RhdGVBbmltYXRpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZS52ZWxvY2l0eSA9IChyb3RhdGVBbmltYXRpb24uc3BlZWQgLyAzNjApICogY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3I7XG4gICAgICAgICAgICBpZiAoIXJvdGF0ZUFuaW1hdGlvbi5zeW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUudmVsb2NpdHkgKj0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplQW5pbWF0aW9uID0gdGhpcy5vcHRpb25zLnNpemUuYW5pbWF0aW9uO1xuICAgICAgICBpZiAoc2l6ZUFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zdGF0dXMgPSBFbnVtc18xLkFuaW1hdGlvblN0YXR1cy5pbmNyZWFzaW5nO1xuICAgICAgICAgICAgaWYgKCFyYW5kb21TaXplKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzaXplQW5pbWF0aW9uLnN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLlN0YXJ0VmFsdWVUeXBlLm1pbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZS52YWx1ZSA9IHNpemVBbmltYXRpb24ubWluaW11bVZhbHVlICogcHhSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuU3RhcnRWYWx1ZVR5cGUucmFuZG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplLnZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKFV0aWxzXzEuTnVtYmVyVXRpbHMuc2V0UmFuZ2VWYWx1ZShzaXplQW5pbWF0aW9uLm1pbmltdW1WYWx1ZSAqIHB4UmF0aW8sIHRoaXMuc2l6ZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5TdGFydFZhbHVlVHlwZS5tYXg6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZS52ZWxvY2l0eSA9XG4gICAgICAgICAgICAgICAgKCgoX2cgPSB0aGlzLnNpemVBbmltYXRpb25TcGVlZCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogY29udGFpbmVyLnJldGluYS5zaXplQW5pbWF0aW9uU3BlZWQpIC8gMTAwKSAqXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICAgICAgaWYgKCFzaXplQW5pbWF0aW9uLnN5bmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUudmVsb2NpdHkgKj0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoc2xDb2xvciA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvSHNsKGNvbG9yLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKTtcbiAgICAgICAgaWYgKGhzbENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0ge1xuICAgICAgICAgICAgICAgIGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhzbENvbG9yLmgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoc2xDb2xvci5zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaHNsQ29sb3IubCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yQW5pbWF0aW9uID0gdGhpcy5vcHRpb25zLmNvbG9yLmFuaW1hdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JBbmltYXRpb24oY29sb3JBbmltYXRpb24uaCwgdGhpcy5jb2xvci5oKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JBbmltYXRpb24oY29sb3JBbmltYXRpb24ucywgdGhpcy5jb2xvci5zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JBbmltYXRpb24oY29sb3JBbmltYXRpb24ubCwgdGhpcy5jb2xvci5sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5jYWxjUG9zaXRpb24odGhpcy5jb250YWluZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5pbml0aWFsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmNvcHkoKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBWZWN0b3JfMS5WZWN0b3IuY3JlYXRlKDAsIDApO1xuICAgICAgICBjb25zdCBvcGFjaXR5T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICBjb25zdCByYW5kb21PcGFjaXR5ID0gdHlwZW9mIG9wYWNpdHlPcHRpb25zLnJhbmRvbSA9PT0gXCJib29sZWFuXCIgPyBvcGFjaXR5T3B0aW9ucy5yYW5kb20gOiBvcGFjaXR5T3B0aW9ucy5yYW5kb20uZW5hYmxlO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSB7XG4gICAgICAgICAgICB2YWx1ZTogVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShvcGFjaXR5T3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wYWNpdHlBbmltYXRpb24gPSBvcGFjaXR5T3B0aW9ucy5hbmltYXRpb247XG4gICAgICAgIGlmIChvcGFjaXR5QW5pbWF0aW9uLmVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5LnN0YXR1cyA9IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmc7XG4gICAgICAgICAgICBpZiAoIXJhbmRvbU9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wYWNpdHlBbmltYXRpb24uc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuU3RhcnRWYWx1ZVR5cGUubWluOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5LnZhbHVlID0gb3BhY2l0eUFuaW1hdGlvbi5taW5pbXVtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLlN0YXJ0VmFsdWVUeXBlLnJhbmRvbTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eS52YWx1ZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZShVdGlsc18xLk51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUob3BhY2l0eUFuaW1hdGlvbi5taW5pbXVtVmFsdWUsIHRoaXMub3BhY2l0eS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5TdGFydFZhbHVlVHlwZS5tYXg6XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3BhY2l0eS52ZWxvY2l0eSA9IChvcGFjaXR5QW5pbWF0aW9uLnNwZWVkIC8gMTAwKSAqIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICAgICAgaWYgKCFvcGFjaXR5QW5pbWF0aW9uLnN5bmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkudmVsb2NpdHkgKj0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZGVzID0gMjQ7XG4gICAgICAgIGxldCBkcmF3ZXIgPSBjb250YWluZXIuZHJhd2Vycy5nZXQodGhpcy5zaGFwZSk7XG4gICAgICAgIGlmICghZHJhd2VyKSB7XG4gICAgICAgICAgICBkcmF3ZXIgPSBVdGlsc18xLlBsdWdpbnMuZ2V0U2hhcGVEcmF3ZXIodGhpcy5zaGFwZSk7XG4gICAgICAgICAgICBpZiAoZHJhd2VyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmRyYXdlcnMuc2V0KHRoaXMuc2hhcGUsIGRyYXdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lkZUNvdW50RnVuYyA9IGRyYXdlciA9PT0gbnVsbCB8fCBkcmF3ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYXdlci5nZXRTaWRlc0NvdW50O1xuICAgICAgICBpZiAoc2lkZUNvdW50RnVuYykge1xuICAgICAgICAgICAgdGhpcy5zaWRlcyA9IHNpZGVDb3VudEZ1bmModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2VTaGFwZSA9IHRoaXMubG9hZEltYWdlU2hhcGUoY29udGFpbmVyLCBkcmF3ZXIpO1xuICAgICAgICBpZiAoaW1hZ2VTaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlU2hhcGUuaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmZpbGwgPSBpbWFnZVNoYXBlLmZpbGw7XG4gICAgICAgICAgICB0aGlzLmNsb3NlID0gaW1hZ2VTaGFwZS5jbG9zZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cm9rZSA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3Ryb2tlIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheSh0aGlzLm9wdGlvbnMuc3Ryb2tlLCB0aGlzLmlkLCByZWR1Y2VEdXBsaWNhdGVzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLnN0cm9rZTtcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlLndpZHRoICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICBjb25zdCBzdHJva2VIc2xDb2xvciA9IChfaCA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvSHNsKHRoaXMuc3Ryb2tlLmNvbG9yKSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdGhpcy5nZXRGaWxsQ29sb3IoKTtcbiAgICAgICAgaWYgKHN0cm9rZUhzbENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0ge1xuICAgICAgICAgICAgICAgIGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cm9rZUhzbENvbG9yLmgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdHJva2VIc2xDb2xvci5zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3Ryb2tlSHNsQ29sb3IubCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUNvbG9yQW5pbWF0aW9uID0gKF9qID0gdGhpcy5zdHJva2UuY29sb3IpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5hbmltYXRpb247XG4gICAgICAgICAgICBpZiAoc3Ryb2tlQ29sb3JBbmltYXRpb24gJiYgdGhpcy5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JBbmltYXRpb24oc3Ryb2tlQ29sb3JBbmltYXRpb24uaCwgdGhpcy5zdHJva2VDb2xvci5oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbG9yQW5pbWF0aW9uKHN0cm9rZUNvbG9yQW5pbWF0aW9uLnMsIHRoaXMuc3Ryb2tlQ29sb3Iucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb2xvckFuaW1hdGlvbihzdHJva2VDb2xvckFuaW1hdGlvbi5sLCB0aGlzLnN0cm9rZUNvbG9yLmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpZmVPcHRpb25zID0gcGFydGljbGVzT3B0aW9ucy5saWZlO1xuICAgICAgICB0aGlzLmxpZmVEZWxheSA9IGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yXG4gICAgICAgICAgICA/ICgoVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShsaWZlT3B0aW9ucy5kZWxheSkgKiAobGlmZU9wdGlvbnMuZGVsYXkuc3luYyA/IDEgOiBNYXRoLnJhbmRvbSgpKSkgL1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yKSAqXG4gICAgICAgICAgICAgICAgMTAwMFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB0aGlzLmxpZmVEZWxheVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxpZmVEdXJhdGlvbiA9IGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yXG4gICAgICAgICAgICA/ICgoVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShsaWZlT3B0aW9ucy5kdXJhdGlvbikgKiAobGlmZU9wdGlvbnMuZHVyYXRpb24uc3luYyA/IDEgOiBNYXRoLnJhbmRvbSgpKSkgL1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yKSAqXG4gICAgICAgICAgICAgICAgMTAwMFxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB0aGlzLmxpZmVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5saXZlc1JlbWFpbmluZyA9IHBhcnRpY2xlc09wdGlvbnMubGlmZS5jb3VudDtcbiAgICAgICAgdGhpcy5zcGF3bmluZyA9IHRoaXMubGlmZURlbGF5ID4gMDtcbiAgICAgICAgaWYgKHRoaXMubGlmZUR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlmZUR1cmF0aW9uID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGl2ZXNSZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5saXZlc1JlbWFpbmluZyA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhZG93Q29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYih0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yKTtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gbmV3IFVwZGF0ZXJfMS5VcGRhdGVyKGNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgIHRoaXMuaW5mZWN0ZXIgPSBuZXcgSW5mZWN0ZXJfMS5JbmZlY3Rlcihjb250YWluZXIpO1xuICAgICAgICB0aGlzLm1vdmVyID0gbmV3IE1vdmVyXzEuTW92ZXIoY29udGFpbmVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGRyYXdlciAmJiBkcmF3ZXIucGFydGljbGVJbml0KSB7XG4gICAgICAgICAgICBkcmF3ZXIucGFydGljbGVJbml0KGNvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShkZWx0YSkge1xuICAgICAgICB0aGlzLm1vdmVyLm1vdmUoZGVsdGEpO1xuICAgIH1cbiAgICB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVyLnVwZGF0ZShkZWx0YSk7XG4gICAgfVxuICAgIGRyYXcoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2FudmFzLmRyYXdQYXJ0aWNsZSh0aGlzLCBkZWx0YSk7XG4gICAgfVxuICAgIGdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5hZGQodGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICBnZXRSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1YmJsZS5yYWRpdXMgfHwgdGhpcy5zaXplLnZhbHVlO1xuICAgIH1cbiAgICBnZXRNYXNzKCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLmdldFJhZGl1cygpO1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KHJhZGl1cywgMikgKiBNYXRoLlBJKSAvIDI7XG4gICAgfVxuICAgIGdldEZpbGxDb2xvcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5idWJibGUuY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRIc2xGcm9tQW5pbWF0aW9uKHRoaXMuY29sb3IpO1xuICAgIH1cbiAgICBnZXRTdHJva2VDb2xvcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuYnViYmxlLmNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0SHNsRnJvbUFuaW1hdGlvbih0aGlzLnN0cm9rZUNvbG9yKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5nZXRGaWxsQ29sb3IoKTtcbiAgICB9XG4gICAgZGVzdHJveShvdmVycmlkZSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnViYmxlLmluUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5rcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy51bmJyZWFrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWJibGUuaW5SYW5nZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5jb250YWluZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHBsdWdpbi5wYXJ0aWNsZURlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5wYXJ0aWNsZURlc3Ryb3llZCh0aGlzLCBvdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdHJveU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZGVzdHJveTtcbiAgICAgICAgaWYgKGRlc3Ryb3lPcHRpb25zLm1vZGUgPT09IEVudW1zXzEuRGVzdHJveU1vZGUuc3BsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5sb29wcy5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5sb29wcy5zaXplID0gMDtcbiAgICB9XG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5kZXN0cm95LnNwbGl0O1xuICAgICAgICBpZiAoc3BsaXRPcHRpb25zLmNvdW50ID49IDAgJiYgdGhpcy5zcGxpdENvdW50KysgPiBzcGxpdE9wdGlvbnMuY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXRlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZVZhbHVlKHNwbGl0T3B0aW9ucy5yYXRlLnZhbHVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXRlOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhcnRpY2xlcy5hZGRTcGxpdFBhcnRpY2xlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbG9yQW5pbWF0aW9uKGNvbG9yQW5pbWF0aW9uLCBjb2xvclZhbHVlKSB7XG4gICAgICAgIGlmIChjb2xvckFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgIGNvbG9yVmFsdWUudmVsb2NpdHkgPSAoY29sb3JBbmltYXRpb24uc3BlZWQgLyAxMDApICogdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgICAgIGlmIChjb2xvckFuaW1hdGlvbi5zeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sb3JWYWx1ZS5zdGF0dXMgPSBFbnVtc18xLkFuaW1hdGlvblN0YXR1cy5pbmNyZWFzaW5nO1xuICAgICAgICAgICAgY29sb3JWYWx1ZS52ZWxvY2l0eSAqPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgaWYgKGNvbG9yVmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb2xvclZhbHVlLnZhbHVlICo9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjUG9zaXRpb24oY29udGFpbmVyLCBwb3NpdGlvbiwgdHJ5Q291bnQgPSAwKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGZvciAoY29uc3QgWywgcGx1Z2luXSBvZiBjb250YWluZXIucGx1Z2lucykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luUG9zID0gcGx1Z2luLnBhcnRpY2xlUG9zaXRpb24gIT09IHVuZGVmaW5lZCA/IHBsdWdpbi5wYXJ0aWNsZVBvc2l0aW9uKHBvc2l0aW9uLCB0aGlzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwbHVnaW5Qb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3JfMS5WZWN0b3IuY3JlYXRlKHBsdWdpblBvcy54LCBwbHVnaW5Qb3MueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gVmVjdG9yXzEuVmVjdG9yLmNyZWF0ZSgoX2EgPSBwb3NpdGlvbiA9PT0gbnVsbCB8fCBwb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9zaXRpb24ueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTWF0aC5yYW5kb20oKSAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCwgKF9iID0gcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1hdGgucmFuZG9tKCkgKiBjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgY29uc3Qgb3V0TW9kZSA9IHRoaXMub3B0aW9ucy5tb3ZlLm91dE1vZGU7XG4gICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzSW5BcnJheShvdXRNb2RlLCBFbnVtc18xLk91dE1vZGUuYm91bmNlKSB8fCBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShvdXRNb2RlLCBFbnVtc18xLk91dE1vZGUuYm91bmNlSG9yaXpvbnRhbCkpIHtcbiAgICAgICAgICAgIGlmIChwb3MueCA+IGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCAtIHRoaXMuc2l6ZS52YWx1ZSAqIDIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCAtPSB0aGlzLnNpemUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3MueCA8IHRoaXMuc2l6ZS52YWx1ZSAqIDIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCArPSB0aGlzLnNpemUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KG91dE1vZGUsIEVudW1zXzEuT3V0TW9kZS5ib3VuY2UpIHx8IFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KG91dE1vZGUsIEVudW1zXzEuT3V0TW9kZS5ib3VuY2VWZXJ0aWNhbCkpIHtcbiAgICAgICAgICAgIGlmIChwb3MueSA+IGNvbnRhaW5lci5jYW52YXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUudmFsdWUgKiAyKSB7XG4gICAgICAgICAgICAgICAgcG9zLnkgLT0gdGhpcy5zaXplLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9zLnkgPCB0aGlzLnNpemUudmFsdWUgKiAyKSB7XG4gICAgICAgICAgICAgICAgcG9zLnkgKz0gdGhpcy5zaXplLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoZWNrT3ZlcmxhcChwb3MsIHRyeUNvdW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1Bvc2l0aW9uKGNvbnRhaW5lciwgdW5kZWZpbmVkLCB0cnlDb3VudCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGNoZWNrT3ZlcmxhcChwb3MsIHRyeUNvdW50ID0gMCkge1xuICAgICAgICBjb25zdCBvdmVybGFwT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5jb2xsaXNpb25zLm92ZXJsYXA7XG4gICAgICAgIGlmICghb3ZlcmxhcE9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCByZXRyaWVzID0gb3ZlcmxhcE9wdGlvbnMucmV0cmllcztcbiAgICAgICAgICAgIGlmIChyZXRyaWVzID49IDAgJiYgdHJ5Q291bnQgPiByZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFydGljbGUgaXMgb3ZlcmxhcHBpbmcgYW5kIGNhbid0IGJlIHBsYWNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvdmVybGFwcyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiB0aGlzLmNvbnRhaW5lci5wYXJ0aWNsZXMuYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MsIHBhcnRpY2xlLnBvc2l0aW9uKSA8IHRoaXMuc2l6ZS52YWx1ZSArIHBhcnRpY2xlLnNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxhcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYWxjdWxhdGVWZWxvY2l0eSgpIHtcbiAgICAgICAgY29uc3QgYmFzZVZlbG9jaXR5ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRQYXJ0aWNsZUJhc2VWZWxvY2l0eSh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2VWZWxvY2l0eS5jb3B5KCk7XG4gICAgICAgIGNvbnN0IG1vdmVPcHRpb25zID0gdGhpcy5vcHRpb25zLm1vdmU7XG4gICAgICAgIGxldCByYWQ7XG4gICAgICAgIGxldCByYWRPZmZzZXQgPSBNYXRoLlBJIC8gNDtcbiAgICAgICAgaWYgKHR5cGVvZiBtb3ZlT3B0aW9ucy5hbmdsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmFkID0gKE1hdGguUEkgLyAxODApICogbW92ZU9wdGlvbnMuYW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYWQgPSAoTWF0aC5QSSAvIDE4MCkgKiBtb3ZlT3B0aW9ucy5hbmdsZS52YWx1ZTtcbiAgICAgICAgICAgIHJhZE9mZnNldCA9IChNYXRoLlBJIC8gMTgwKSAqIG1vdmVPcHRpb25zLmFuZ2xlLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgIGxlZnQ6IE1hdGguc2luKHJhZE9mZnNldCArIHJhZCAvIDIpIC0gTWF0aC5zaW4ocmFkT2Zmc2V0IC0gcmFkIC8gMiksXG4gICAgICAgICAgICByaWdodDogTWF0aC5jb3MocmFkT2Zmc2V0ICsgcmFkIC8gMikgLSBNYXRoLmNvcyhyYWRPZmZzZXQgLSByYWQgLyAyKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFtb3ZlT3B0aW9ucy5zdHJhaWdodCB8fCBtb3ZlT3B0aW9ucy5yYW5kb20pIHtcbiAgICAgICAgICAgIHJlcy54ICs9IFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZShVdGlsc18xLk51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUocmFuZ2UubGVmdCwgcmFuZ2UucmlnaHQpKSAvIDI7XG4gICAgICAgICAgICByZXMueSArPSBVdGlsc18xLk51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UoVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKHJhbmdlLmxlZnQsIHJhbmdlLnJpZ2h0KSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGxvYWRJbWFnZVNoYXBlKGNvbnRhaW5lciwgZHJhd2VyKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGlmICghKHRoaXMuc2hhcGUgPT09IEVudW1zXzEuU2hhcGVUeXBlLmltYWdlIHx8IHRoaXMuc2hhcGUgPT09IEVudW1zXzEuU2hhcGVUeXBlLmltYWdlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbWFnZURyYXdlciA9IGRyYXdlcjtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gaW1hZ2VEcmF3ZXIuZ2V0SW1hZ2VzKGNvbnRhaW5lcikuaW1hZ2VzO1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSB0aGlzLnNoYXBlRGF0YTtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSAoX2EgPSBpbWFnZXMuZmluZCgodCkgPT4gdC5zb3VyY2UgPT09IGltYWdlRGF0YS5zcmMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbWFnZXNbMF07XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3IoKTtcbiAgICAgICAgbGV0IGltYWdlUmVzO1xuICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlLnN2Z0RhdGEgIT09IHVuZGVmaW5lZCAmJiBpbWFnZURhdGEucmVwbGFjZUNvbG9yICYmIGNvbG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdmdDb2xvcmVkRGF0YSA9IFV0aWxzXzEuQ29sb3JVdGlscy5yZXBsYWNlQ29sb3JTdmcoaW1hZ2UsIGNvbG9yLCB0aGlzLm9wYWNpdHkudmFsdWUpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnID0gbmV3IEJsb2IoW3N2Z0NvbG9yZWREYXRhXSwgeyB0eXBlOiBcImltYWdlL3N2Zyt4bWxcIiB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRvbVVybCA9IFVSTCB8fCB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZG9tVXJsLmNyZWF0ZU9iamVjdFVSTChzdmcpO1xuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZVJlcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBpbWFnZURhdGEud2lkdGggLyBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJlcGxhY2VDb2xvcjogKF9iID0gaW1hZ2VEYXRhLnJlcGxhY2VDb2xvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaW1hZ2VEYXRhLnJlcGxhY2VfY29sb3IsXG4gICAgICAgICAgICAgICAgc291cmNlOiBpbWFnZURhdGEuc3JjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbGVtZW50ID0gaW1nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb21VcmwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbVVybC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICAgICAgICBVdGlsc18xLlV0aWxzLmxvYWRJbWFnZShpbWFnZURhdGEuc3JjKS50aGVuKChpbWcyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltYWdlICYmIGltZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmVsZW1lbnQgPSBpbWcyLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlUmVzID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGltYWdlLFxuICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYXRpbzogaW1hZ2VEYXRhLndpZHRoIC8gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29sb3I6IChfYyA9IGltYWdlRGF0YS5yZXBsYWNlQ29sb3IpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGltYWdlRGF0YS5yZXBsYWNlX2NvbG9yLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogaW1hZ2VEYXRhLnNyYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbWFnZVJlcy5yYXRpbykge1xuICAgICAgICAgICAgaW1hZ2VSZXMucmF0aW8gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGwgPSAoX2QgPSBpbWFnZURhdGEuZmlsbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5maWxsO1xuICAgICAgICBjb25zdCBjbG9zZSA9IChfZSA9IGltYWdlRGF0YS5jbG9zZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5jbG9zZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZVJlcyxcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBjbG9zZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlBhcnRpY2xlID0gUGFydGljbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mZWN0ZXIgPSB2b2lkIDA7XG5jbGFzcyBJbmZlY3RlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICBzdGFydEluZmVjdGlvbihzdGFnZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3Qgc3RhZ2VzID0gb3B0aW9ucy5pbmZlY3Rpb24uc3RhZ2VzO1xuICAgICAgICBjb25zdCBzdGFnZXNDb3VudCA9IHN0YWdlcy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFnZSA+IHN0YWdlc0NvdW50IHx8IHN0YWdlIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mZWN0aW9uRGVsYXkgPSAwO1xuICAgICAgICB0aGlzLmluZmVjdGlvbkRlbGF5U3RhZ2UgPSBzdGFnZTtcbiAgICB9XG4gICAgdXBkYXRlSW5mZWN0aW9uU3RhZ2Uoc3RhZ2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHN0YWdlc0NvdW50ID0gb3B0aW9ucy5pbmZlY3Rpb24uc3RhZ2VzLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YWdlID4gc3RhZ2VzQ291bnQgfHwgc3RhZ2UgPCAwIHx8ICh0aGlzLmluZmVjdGlvblN0YWdlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbmZlY3Rpb25TdGFnZSA+IHN0YWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mZWN0aW9uU3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5pbmZlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgdXBkYXRlSW5mZWN0aW9uKGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmZlY3Rpb24gPSBvcHRpb25zLmluZmVjdGlvbjtcbiAgICAgICAgY29uc3Qgc3RhZ2VzID0gb3B0aW9ucy5pbmZlY3Rpb24uc3RhZ2VzO1xuICAgICAgICBjb25zdCBzdGFnZXNDb3VudCA9IHN0YWdlcy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLmluZmVjdGlvbkRlbGF5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbmZlY3Rpb25EZWxheVN0YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWdlID0gdGhpcy5pbmZlY3Rpb25EZWxheVN0YWdlO1xuICAgICAgICAgICAgaWYgKHN0YWdlID4gc3RhZ2VzQ291bnQgfHwgc3RhZ2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5mZWN0aW9uRGVsYXkgPiBpbmZlY3Rpb24uZGVsYXkgKiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZlY3Rpb25TdGFnZSA9IHN0YWdlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mZWN0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5mZWN0aW9uRGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5mZWN0aW9uRGVsYXlTdGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mZWN0aW9uRGVsYXkgKz0gZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmZlY3Rpb25EZWxheTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvbkRlbGF5U3RhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5mZWN0aW9uU3RhZ2UgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluZmVjdGlvblRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgaW5mZWN0aW9uU3RhZ2UgPSBzdGFnZXNbdGhpcy5pbmZlY3Rpb25TdGFnZV07XG4gICAgICAgICAgICBpZiAoaW5mZWN0aW9uU3RhZ2UuZHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiBpbmZlY3Rpb25TdGFnZS5kdXJhdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mZWN0aW9uVGltZSA+IGluZmVjdGlvblN0YWdlLmR1cmF0aW9uICogMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRJbmZlY3Rpb25TdGFnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmZlY3Rpb25UaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mZWN0aW9uVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluZmVjdGlvblN0YWdlO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5mZWN0aW9uVGltZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0SW5mZWN0aW9uU3RhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBzdGFnZXNDb3VudCA9IG9wdGlvbnMuaW5mZWN0aW9uLnN0YWdlcy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFnZXNDb3VudCA8PSAwIHx8IHRoaXMuaW5mZWN0aW9uU3RhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIGlmIChzdGFnZXNDb3VudCA8PSArK3RoaXMuaW5mZWN0aW9uU3RhZ2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluZmVjdGlvbi5jdXJlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5mZWN0aW9uU3RhZ2U7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5mZWN0aW9uVGltZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZmVjdGlvblN0YWdlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZmVjdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbmZlY3RlciA9IEluZmVjdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyYWN0aW9uTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IEdyYWJiZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvR3JhYmJlclwiKTtcbmNvbnN0IFJlcHVsc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL1JlcHVsc2VyXCIpO1xuY29uc3QgQnViYmxlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9FeHRlcm5hbC9CdWJibGVyXCIpO1xuY29uc3QgQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL0Nvbm5lY3RvclwiKTtcbmNvbnN0IExpbmtlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvTGlua2VyXCIpO1xuY29uc3QgQXR0cmFjdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL1BhcnRpY2xlcy9BdHRyYWN0b3JcIik7XG5jb25zdCBDb2xsaWRlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvQ29sbGlkZXJcIik7XG5jb25zdCBJbmZlY3Rlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvSW5mZWN0ZXJcIik7XG5jb25zdCBUcmFpbE1ha2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vSW50ZXJhY3Rpb25zL0V4dGVybmFsL1RyYWlsTWFrZXJcIik7XG5jb25zdCBBdHRyYWN0b3JfMiA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvQXR0cmFjdG9yXCIpO1xuY29uc3QgTGlnaHRlcl8xID0gcmVxdWlyZShcIi4uLy4uL0ludGVyYWN0aW9ucy9QYXJ0aWNsZXMvTGlnaHRlclwiKTtcbmNvbnN0IExpZ2h0ZXJfMiA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvTGlnaHRlclwiKTtcbmNvbnN0IEJvdW5jZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9JbnRlcmFjdGlvbnMvRXh0ZXJuYWwvQm91bmNlclwiKTtcbmNsYXNzIEludGVyYWN0aW9uTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmV4dGVybmFsSW50ZXJhY3RvcnMgPSBbXG4gICAgICAgICAgICBuZXcgQm91bmNlcl8xLkJvdW5jZXIoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBCdWJibGVyXzEuQnViYmxlcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IENvbm5lY3Rvcl8xLkNvbm5lY3Rvcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IEdyYWJiZXJfMS5HcmFiYmVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgTGlnaHRlcl8yLkxpZ2h0ZXIoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBBdHRyYWN0b3JfMi5BdHRyYWN0b3IoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBSZXB1bHNlcl8xLlJlcHVsc2VyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgVHJhaWxNYWtlcl8xLlRyYWlsTWFrZXIoY29udGFpbmVyKSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUludGVyYWN0b3JzID0gW1xuICAgICAgICAgICAgbmV3IEF0dHJhY3Rvcl8xLkF0dHJhY3Rvcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IExpZ2h0ZXJfMS5MaWdodGVyKGNvbnRhaW5lciksXG4gICAgICAgICAgICBuZXcgQ29sbGlkZXJfMS5Db2xsaWRlcihjb250YWluZXIpLFxuICAgICAgICAgICAgbmV3IEluZmVjdGVyXzEuSW5mZWN0ZXIoY29udGFpbmVyKSxcbiAgICAgICAgICAgIG5ldyBMaW5rZXJfMS5MaW5rZXIoY29udGFpbmVyKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICB9XG4gICAgZXh0ZXJuYWxJbnRlcmFjdChkZWx0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGludGVyYWN0b3Igb2YgdGhpcy5leHRlcm5hbEludGVyYWN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rvci5pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0b3IuaW50ZXJhY3QoZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnRpY2xlc0ludGVyYWN0KHBhcnRpY2xlLCBkZWx0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGludGVyYWN0b3Igb2YgdGhpcy5leHRlcm5hbEludGVyYWN0b3JzKSB7XG4gICAgICAgICAgICBpbnRlcmFjdG9yLnJlc2V0KHBhcnRpY2xlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGludGVyYWN0b3Igb2YgdGhpcy5wYXJ0aWNsZUludGVyYWN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rvci5pc0VuYWJsZWQocGFydGljbGUpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rvci5pbnRlcmFjdChwYXJ0aWNsZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmFjdGlvbk1hbmFnZXIgPSBJbnRlcmFjdGlvbk1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtc1wiKTtcbmNsYXNzIE1vdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHBhcnRpY2xlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnBhcnRpY2xlID0gcGFydGljbGU7XG4gICAgfVxuICAgIG1vdmUoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBwYXJ0aWNsZS5idWJibGUuaW5SYW5nZSA9IGZhbHNlO1xuICAgICAgICBwYXJ0aWNsZS5saW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgdGhpcy5jb250YWluZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5wYXJ0aWNsZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5wYXJ0aWNsZVVwZGF0ZShwYXJ0aWNsZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVQYXJ0aWNsZShkZWx0YSk7XG4gICAgICAgIHRoaXMubW92ZVBhcmFsbGF4KCk7XG4gICAgfVxuICAgIG1vdmVQYXJ0aWNsZShkZWx0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc09wdGlvbnMgPSBwYXJ0aWNsZS5vcHRpb25zO1xuICAgICAgICBpZiAoIXBhcnRpY2xlc09wdGlvbnMubW92ZS5lbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgc2xvd0ZhY3RvciA9IHRoaXMuZ2V0UHJveGltaXR5U3BlZWRGYWN0b3IoKTtcbiAgICAgICAgY29uc3QgYmFzZVNwZWVkID0gKChfYSA9IHBhcnRpY2xlLm1vdmVTcGVlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZVZhbHVlKHBhcnRpY2xlLm9wdGlvbnMubW92ZS5zcGVlZCkgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW8pICpcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICBjb25zdCBtYXhTaXplID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZU1heChwYXJ0aWNsZS5vcHRpb25zLnNpemUudmFsdWUpICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICBjb25zdCBzaXplRmFjdG9yID0gcGFydGljbGVzT3B0aW9ucy5tb3ZlLnNpemUgPyBwYXJ0aWNsZS5nZXRSYWRpdXMoKSAvIG1heFNpemUgOiAxO1xuICAgICAgICBjb25zdCBtb3ZlU3BlZWQgPSAoYmFzZVNwZWVkIC8gMikgKiBzaXplRmFjdG9yICogc2xvd0ZhY3RvciAqIGRlbHRhLmZhY3RvcjtcbiAgICAgICAgY29uc3QgbW92ZURyaWZ0ID0gKF9iID0gcGFydGljbGUubW92ZURyaWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBVdGlsc18xLk51bWJlclV0aWxzLmdldFJhbmdlVmFsdWUocGFydGljbGUub3B0aW9ucy5tb3ZlLmRyaWZ0KSAqIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5hcHBseVBhdGgoZGVsdGEpO1xuICAgICAgICBjb25zdCBncmF2aXR5T3B0aW9ucyA9IHBhcnRpY2xlc09wdGlvbnMubW92ZS5ncmF2aXR5O1xuICAgICAgICBpZiAoZ3Jhdml0eU9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS55ICs9IChncmF2aXR5T3B0aW9ucy5hY2NlbGVyYXRpb24gKiBkZWx0YS5mYWN0b3IpIC8gKDYwICogbW92ZVNwZWVkKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS54ICs9IChtb3ZlRHJpZnQgKiBkZWx0YS5mYWN0b3IpIC8gKDYwICogbW92ZVNwZWVkKTtcbiAgICAgICAgY29uc3QgZGVjYXkgPSAxIC0gcGFydGljbGUub3B0aW9ucy5tb3ZlLmRlY2F5O1xuICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5tdWx0VG8oZGVjYXkpO1xuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IHBhcnRpY2xlLnZlbG9jaXR5Lm11bHQobW92ZVNwZWVkKTtcbiAgICAgICAgaWYgKGdyYXZpdHlPcHRpb25zLmVuYWJsZSAmJiB2ZWxvY2l0eS55ID49IGdyYXZpdHlPcHRpb25zLm1heFNwZWVkICYmIGdyYXZpdHlPcHRpb25zLm1heFNwZWVkID4gMCkge1xuICAgICAgICAgICAgdmVsb2NpdHkueSA9IGdyYXZpdHlPcHRpb25zLm1heFNwZWVkO1xuICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkueSA9IHZlbG9jaXR5LnkgLyBtb3ZlU3BlZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFydGljbGUucG9zaXRpb24uYWRkVG8odmVsb2NpdHkpO1xuICAgICAgICBpZiAocGFydGljbGVzT3B0aW9ucy5tb3ZlLnZpYnJhdGUpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggKz0gTWF0aC5zaW4ocGFydGljbGUucG9zaXRpb24ueCAqIE1hdGguY29zKHBhcnRpY2xlLnBvc2l0aW9uLnkpKTtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgKz0gTWF0aC5jb3MocGFydGljbGUucG9zaXRpb24ueSAqIE1hdGguc2luKHBhcnRpY2xlLnBvc2l0aW9uLngpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSBwYXJ0aWNsZS5pbml0aWFsUG9zaXRpb247XG4gICAgICAgIGNvbnN0IGluaXRpYWxEaXN0YW5jZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UoaW5pdGlhbFBvc2l0aW9uLCBwYXJ0aWNsZS5wb3NpdGlvbik7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5tYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxEaXN0YW5jZSA+PSBwYXJ0aWNsZS5tYXhEaXN0YW5jZSAmJiAhcGFydGljbGUubWlzcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUubWlzcGxhY2VkID0gaW5pdGlhbERpc3RhbmNlID4gcGFydGljbGUubWF4RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkueCA9IHBhcnRpY2xlLnZlbG9jaXR5LnkgLyAyIC0gcGFydGljbGUudmVsb2NpdHkueDtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS55ID0gcGFydGljbGUudmVsb2NpdHkueCAvIDIgLSBwYXJ0aWNsZS52ZWxvY2l0eS55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbERpc3RhbmNlIDwgcGFydGljbGUubWF4RGlzdGFuY2UgJiYgcGFydGljbGUubWlzcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUubWlzcGxhY2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0aWNsZS5taXNwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHBhcnRpY2xlLnBvc2l0aW9uLnggPCBpbml0aWFsUG9zaXRpb24ueCAmJiBwYXJ0aWNsZS52ZWxvY2l0eS54IDwgMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcnRpY2xlLnBvc2l0aW9uLnggPiBpbml0aWFsUG9zaXRpb24ueCAmJiBwYXJ0aWNsZS52ZWxvY2l0eS54ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkueCAqPSAtTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwYXJ0aWNsZS5wb3NpdGlvbi55IDwgaW5pdGlhbFBvc2l0aW9uLnkgJiYgcGFydGljbGUudmVsb2NpdHkueSA8IDApIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJ0aWNsZS5wb3NpdGlvbi55ID4gaW5pdGlhbFBvc2l0aW9uLnkgJiYgcGFydGljbGUudmVsb2NpdHkueSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnkgKj0gLU1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UGF0aChkZWx0YSkge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc09wdGlvbnMgPSBwYXJ0aWNsZS5vcHRpb25zO1xuICAgICAgICBjb25zdCBwYXRoT3B0aW9ucyA9IHBhcnRpY2xlc09wdGlvbnMubW92ZS5wYXRoO1xuICAgICAgICBjb25zdCBwYXRoRW5hYmxlZCA9IHBhdGhPcHRpb25zLmVuYWJsZTtcbiAgICAgICAgaWYgKCFwYXRoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAocGFydGljbGUubGFzdFBhdGhUaW1lIDw9IHBhcnRpY2xlLnBhdGhEZWxheSkge1xuICAgICAgICAgICAgcGFydGljbGUubGFzdFBhdGhUaW1lICs9IGRlbHRhLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnZW5lcmF0b3IgPSBjb250YWluZXIucGF0aEdlbmVyYXRvcjtcbiAgICAgICAgaWYgKHBhdGhPcHRpb25zLmdlbmVyYXRvcikge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tR2VuZXJhdG9yID0gVXRpbHNfMS5QbHVnaW5zLmdldFBhdGhHZW5lcmF0b3IocGF0aE9wdGlvbnMuZ2VuZXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3IgPSBjdXN0b21HZW5lcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IGdlbmVyYXRvci5nZW5lcmF0ZShwYXJ0aWNsZSk7XG4gICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LmFkZFRvKHBhdGgpO1xuICAgICAgICBpZiAocGF0aE9wdGlvbnMuY2xhbXApIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnggPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKHBhcnRpY2xlLnZlbG9jaXR5LngsIC0xLCAxKTtcbiAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnkgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKHBhcnRpY2xlLnZlbG9jaXR5LnksIC0xLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWNsZS5sYXN0UGF0aFRpbWUgLT0gcGFydGljbGUucGF0aERlbGF5O1xuICAgIH1cbiAgICBtb3ZlUGFyYWxsYXgoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzU3NyKCkgfHwgIW9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5wYXJhbGxheC5lbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHBhcmFsbGF4Rm9yY2UgPSBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uSG92ZXIucGFyYWxsYXguZm9yY2U7XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgIGlmICghbW91c2VQb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXNDZW50ZXIgPSB7XG4gICAgICAgICAgICB4OiBjb250YWluZXIuY2FudmFzLnNpemUud2lkdGggLyAyLFxuICAgICAgICAgICAgeTogY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCAvIDIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFsbGF4U21vb3RoID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cy5vbkhvdmVyLnBhcmFsbGF4LnNtb290aDtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gcGFydGljbGUuZ2V0UmFkaXVzKCkgLyBwYXJhbGxheEZvcmNlO1xuICAgICAgICBjb25zdCB0bXAgPSB7XG4gICAgICAgICAgICB4OiAobW91c2VQb3MueCAtIGNhbnZhc0NlbnRlci54KSAqIGZhY3RvcixcbiAgICAgICAgICAgIHk6IChtb3VzZVBvcy55IC0gY2FudmFzQ2VudGVyLnkpICogZmFjdG9yLFxuICAgICAgICB9O1xuICAgICAgICBwYXJ0aWNsZS5vZmZzZXQueCArPSAodG1wLnggLSBwYXJ0aWNsZS5vZmZzZXQueCkgLyBwYXJhbGxheFNtb290aDtcbiAgICAgICAgcGFydGljbGUub2Zmc2V0LnkgKz0gKHRtcC55IC0gcGFydGljbGUub2Zmc2V0LnkpIC8gcGFyYWxsYXhTbW9vdGg7XG4gICAgfVxuICAgIGdldFByb3hpbWl0eVNwZWVkRmFjdG9yKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5zbG93LCBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uSG92ZXIubW9kZSk7XG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb3VzZVBvcyA9IHRoaXMuY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgIGlmICghbW91c2VQb3MpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlUG9zID0gdGhpcy5wYXJ0aWNsZS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBkaXN0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShtb3VzZVBvcywgcGFydGljbGVQb3MpO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBjb250YWluZXIucmV0aW5hLnNsb3dNb2RlUmFkaXVzO1xuICAgICAgICBpZiAoZGlzdCA+IHJhZGl1cykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveGltaXR5RmFjdG9yID0gZGlzdCAvIHJhZGl1cyB8fCAwO1xuICAgICAgICBjb25zdCBzbG93RmFjdG9yID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLnNsb3cuZmFjdG9yO1xuICAgICAgICByZXR1cm4gcHJveGltaXR5RmFjdG9yIC8gc2xvd0ZhY3RvcjtcbiAgICB9XG59XG5leHBvcnRzLk1vdmVyID0gTW92ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zXCIpO1xuY29uc3QgT3V0TW9kZURpcmVjdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zL0RpcmVjdGlvbnMvT3V0TW9kZURpcmVjdGlvblwiKTtcbmZ1bmN0aW9uIGJvdW5jZUhvcml6b250YWwoZGF0YSkge1xuICAgIGlmIChkYXRhLm91dE1vZGUgPT09IEVudW1zXzEuT3V0TW9kZS5ib3VuY2UgfHxcbiAgICAgICAgZGF0YS5vdXRNb2RlID09PSBFbnVtc18xLk91dE1vZGUuYm91bmNlSG9yaXpvbnRhbCB8fFxuICAgICAgICBkYXRhLm91dE1vZGUgPT09IFwiYm91bmNlSG9yaXpvbnRhbFwiIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLnNwbGl0KSB7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gZGF0YS5wYXJ0aWNsZS52ZWxvY2l0eS54O1xuICAgICAgICBsZXQgYm91bmNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRhdGEuZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5yaWdodCAmJiBkYXRhLmJvdW5kcy5yaWdodCA+PSBkYXRhLmNhbnZhc1NpemUud2lkdGggJiYgdmVsb2NpdHkgPiAwKSB8fFxuICAgICAgICAgICAgKGRhdGEuZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5sZWZ0ICYmIGRhdGEuYm91bmRzLmxlZnQgPD0gMCAmJiB2ZWxvY2l0eSA8IDApKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWZWxvY2l0eSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUoZGF0YS5wYXJ0aWNsZS5vcHRpb25zLmJvdW5jZS5ob3Jpem9udGFsKTtcbiAgICAgICAgICAgIGRhdGEucGFydGljbGUudmVsb2NpdHkueCAqPSAtbmV3VmVsb2NpdHk7XG4gICAgICAgICAgICBib3VuY2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvdW5jZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5Qb3MgPSBkYXRhLm9mZnNldC54ICsgZGF0YS5zaXplO1xuICAgICAgICBpZiAoZGF0YS5ib3VuZHMucmlnaHQgPj0gZGF0YS5jYW52YXNTaXplLndpZHRoKSB7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLnBvc2l0aW9uLnggPSBkYXRhLmNhbnZhc1NpemUud2lkdGggLSBtaW5Qb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5ib3VuZHMubGVmdCA8PSAwKSB7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLnBvc2l0aW9uLnggPSBtaW5Qb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLnNwbGl0KSB7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJvdW5jZVZlcnRpY2FsKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5vdXRNb2RlID09PSBFbnVtc18xLk91dE1vZGUuYm91bmNlIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLmJvdW5jZVZlcnRpY2FsIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gXCJib3VuY2VWZXJ0aWNhbFwiIHx8XG4gICAgICAgIGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLnNwbGl0KSB7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gZGF0YS5wYXJ0aWNsZS52ZWxvY2l0eS55O1xuICAgICAgICBsZXQgYm91bmNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRhdGEuZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5ib3R0b20gJiZcbiAgICAgICAgICAgIGRhdGEuYm91bmRzLmJvdHRvbSA+PSBkYXRhLmNhbnZhc1NpemUuaGVpZ2h0ICYmXG4gICAgICAgICAgICB2ZWxvY2l0eSA+IDApIHx8XG4gICAgICAgICAgICAoZGF0YS5kaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLnRvcCAmJiBkYXRhLmJvdW5kcy50b3AgPD0gMCAmJiB2ZWxvY2l0eSA8IDApKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWZWxvY2l0eSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUoZGF0YS5wYXJ0aWNsZS5vcHRpb25zLmJvdW5jZS52ZXJ0aWNhbCk7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLnZlbG9jaXR5LnkgKj0gLW5ld1ZlbG9jaXR5O1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFib3VuY2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWluUG9zID0gZGF0YS5vZmZzZXQueSArIGRhdGEuc2l6ZTtcbiAgICAgICAgaWYgKGRhdGEuYm91bmRzLmJvdHRvbSA+PSBkYXRhLmNhbnZhc1NpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLnBvc2l0aW9uLnkgPSBkYXRhLmNhbnZhc1NpemUuaGVpZ2h0IC0gbWluUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEuYm91bmRzLnRvcCA8PSAwKSB7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLnBvc2l0aW9uLnkgPSBtaW5Qb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3V0TW9kZSA9PT0gRW51bXNfMS5PdXRNb2RlLnNwbGl0KSB7XG4gICAgICAgICAgICBkYXRhLnBhcnRpY2xlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRGVzdHJveShwYXJ0aWNsZSwgZGVzdHJveSwgdmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICAgIHN3aXRjaCAoZGVzdHJveSkge1xuICAgICAgICBjYXNlIEVudW1zXzEuRGVzdHJveVR5cGUubWF4OlxuICAgICAgICAgICAgaWYgKHZhbHVlID49IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRW51bXNfMS5EZXN0cm95VHlwZS5taW46XG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5jbGFzcyBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHBhcnRpY2xlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnBhcnRpY2xlID0gcGFydGljbGU7XG4gICAgfVxuICAgIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUxpZmUoZGVsdGEpO1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZS5kZXN0cm95ZWQgfHwgdGhpcy5wYXJ0aWNsZS5zcGF3bmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlT3BhY2l0eShkZWx0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZShkZWx0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlQW5nbGUoZGVsdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yKGRlbHRhKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHJva2VDb2xvcihkZWx0YSk7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0TW9kZXMoZGVsdGEpO1xuICAgIH1cbiAgICB1cGRhdGVMaWZlKGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgbGV0IGp1c3RTcGF3bmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJ0aWNsZS5zcGF3bmluZykge1xuICAgICAgICAgICAgcGFydGljbGUubGlmZURlbGF5VGltZSArPSBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5saWZlRGVsYXlUaW1lID49IHBhcnRpY2xlLmxpZmVEZWxheSkge1xuICAgICAgICAgICAgICAgIGp1c3RTcGF3bmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5zcGF3bmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVEZWxheVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljbGUubGlmZUR1cmF0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFydGljbGUuc3Bhd25pbmcpIHtcbiAgICAgICAgICAgIGlmIChqdXN0U3Bhd25lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lICs9IGRlbHRhLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmxpZmVUaW1lID49IHBhcnRpY2xlLmxpZmVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpZmVUaW1lID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocGFydGljbGUubGl2ZXNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxpdmVzUmVtYWluaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5saXZlc1JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IHRoaXMuY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBVdGlsc18xLk51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UoVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKDAsIGNhbnZhc1NpemUud2lkdGgpKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKFV0aWxzXzEuTnVtYmVyVXRpbHMuc2V0UmFuZ2VWYWx1ZSgwLCBjYW52YXNTaXplLmhlaWdodCkpO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNwYXduaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5saWZlRGVsYXlUaW1lID0gMDtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5saWZlVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgcGFydGljbGUucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaWZlT3B0aW9ucyA9IHBhcnRpY2xlLm9wdGlvbnMubGlmZTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5saWZlRGVsYXkgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKGxpZmVPcHRpb25zLmRlbGF5KSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgcGFydGljbGUubGlmZUR1cmF0aW9uID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRWYWx1ZShsaWZlT3B0aW9ucy5kdXJhdGlvbikgKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU9wYWNpdHkoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBjb25zdCBvcGFjaXR5T3B0ID0gcGFydGljbGUub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICBjb25zdCBvcGFjaXR5QW5pbSA9IG9wYWNpdHlPcHQuYW5pbWF0aW9uO1xuICAgICAgICBjb25zdCBtaW5WYWx1ZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0UmFuZ2VNaW4ob3BhY2l0eU9wdC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IG1heFZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZU1heChvcGFjaXR5T3B0LnZhbHVlKTtcbiAgICAgICAgaWYgKCFwYXJ0aWNsZS5kZXN0cm95ZWQgJiZcbiAgICAgICAgICAgIG9wYWNpdHlBbmltLmVuYWJsZSAmJlxuICAgICAgICAgICAgKG9wYWNpdHlBbmltLmNvdW50IDw9IDAgfHwgcGFydGljbGUubG9vcHMuc2l6ZSA8IG9wYWNpdHlBbmltLmNvdW50KSkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0aWNsZS5vcGFjaXR5LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLm9wYWNpdHkudmFsdWUgPj0gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9wYWNpdHkuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxvb3BzLm9wYWNpdHkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9wYWNpdHkudmFsdWUgKz0gKChfYSA9IHBhcnRpY2xlLm9wYWNpdHkudmVsb2NpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICogZGVsdGEuZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLm9wYWNpdHkudmFsdWUgPD0gbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9wYWNpdHkuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxvb3BzLm9wYWNpdHkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9wYWNpdHkudmFsdWUgLT0gKChfYiA9IHBhcnRpY2xlLm9wYWNpdHkudmVsb2NpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApICogZGVsdGEuZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tEZXN0cm95KHBhcnRpY2xlLCBvcGFjaXR5QW5pbS5kZXN0cm95LCBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNsZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcChwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBjb25zdCBzaXplT3B0ID0gcGFydGljbGUub3B0aW9ucy5zaXplO1xuICAgICAgICBjb25zdCBzaXplQW5pbSA9IHNpemVPcHQuYW5pbWF0aW9uO1xuICAgICAgICBjb25zdCBzaXplVmVsb2NpdHkgPSAoKF9hID0gcGFydGljbGUuc2l6ZS52ZWxvY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKiBkZWx0YS5mYWN0b3I7XG4gICAgICAgIGNvbnN0IG1pblZhbHVlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZU1pbihzaXplT3B0LnZhbHVlKSAqIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgbWF4VmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFJhbmdlTWF4KHNpemVPcHQudmFsdWUpICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICBpZiAoIXBhcnRpY2xlLmRlc3Ryb3llZCAmJiBzaXplQW5pbS5lbmFibGUgJiYgKHNpemVBbmltLmNvdW50IDw9IDAgfHwgcGFydGljbGUubG9vcHMuc2l6ZSA8IHNpemVBbmltLmNvdW50KSkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0aWNsZS5zaXplLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnNpemUudmFsdWUgPj0gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxvb3BzLnNpemUrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgKz0gc2l6ZVZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnNpemUudmFsdWUgPD0gbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmxvb3BzLnNpemUrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgLT0gc2l6ZVZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0Rlc3Ryb3kocGFydGljbGUsIHNpemVBbmltLmRlc3Ryb3ksIHBhcnRpY2xlLnNpemUudmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2xlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKHBhcnRpY2xlLnNpemUudmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQW5nbGUoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IHJvdGF0ZSA9IHBhcnRpY2xlLm9wdGlvbnMucm90YXRlO1xuICAgICAgICBjb25zdCByb3RhdGVBbmltYXRpb24gPSByb3RhdGUuYW5pbWF0aW9uO1xuICAgICAgICBjb25zdCBzcGVlZCA9ICgoX2EgPSBwYXJ0aWNsZS5yb3RhdGUudmVsb2NpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICogZGVsdGEuZmFjdG9yO1xuICAgICAgICBjb25zdCBtYXggPSAyICogTWF0aC5QSTtcbiAgICAgICAgaWYgKHJvdGF0ZUFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydGljbGUucm90YXRlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuaW5jcmVhc2luZzpcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUucm90YXRlLnZhbHVlICs9IHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGljbGUucm90YXRlLnZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5yb3RhdGUudmFsdWUgLT0gbWF4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5yb3RhdGUudmFsdWUgLT0gc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5yb3RhdGUudmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5yb3RhdGUudmFsdWUgKz0gbWF4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbG9yKGRlbHRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBwYXJ0aWNsZS5vcHRpb25zLmNvbG9yLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKCgoX2EgPSBwYXJ0aWNsZS5jb2xvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JWYWx1ZShwYXJ0aWNsZSwgZGVsdGEsIHBhcnRpY2xlLmNvbG9yLmgsIGFuaW1hdGlvbk9wdGlvbnMuaCwgMzYwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2IgPSBwYXJ0aWNsZS5jb2xvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JWYWx1ZShwYXJ0aWNsZSwgZGVsdGEsIHBhcnRpY2xlLmNvbG9yLnMsIGFuaW1hdGlvbk9wdGlvbnMucywgMTAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYyA9IHBhcnRpY2xlLmNvbG9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2xvclZhbHVlKHBhcnRpY2xlLCBkZWx0YSwgcGFydGljbGUuY29sb3IubCwgYW5pbWF0aW9uT3B0aW9ucy5sLCAxMDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0cm9rZUNvbG9yKGRlbHRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIGlmICghcGFydGljbGUuc3Ryb2tlLmNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IHBhcnRpY2xlLnN0cm9rZS5jb2xvci5hbmltYXRpb247XG4gICAgICAgIGNvbnN0IHZhbHVlQW5pbWF0aW9ucyA9IGFuaW1hdGlvbk9wdGlvbnM7XG4gICAgICAgIGlmICh2YWx1ZUFuaW1hdGlvbnMuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGh1ZSA9IChfYiA9IChfYSA9IHBhcnRpY2xlLnN0cm9rZUNvbG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gcGFydGljbGUuY29sb3IpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5oO1xuICAgICAgICAgICAgaWYgKGh1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JWYWx1ZShwYXJ0aWNsZSwgZGVsdGEsIGh1ZSwgdmFsdWVBbmltYXRpb25zLCAzNjAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhzbEFuaW1hdGlvbnMgPSBhbmltYXRpb25PcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaCA9IChfZSA9IChfZCA9IHBhcnRpY2xlLnN0cm9rZUNvbG9yKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gcGFydGljbGUuY29sb3IpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5oO1xuICAgICAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yVmFsdWUocGFydGljbGUsIGRlbHRhLCBoLCBoc2xBbmltYXRpb25zLmgsIDM2MCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcyA9IChfaCA9IChfZyA9IHBhcnRpY2xlLnN0cm9rZUNvbG9yKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogKF9qID0gcGFydGljbGUuY29sb3IpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5zO1xuICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yVmFsdWUocGFydGljbGUsIGRlbHRhLCBzLCBoc2xBbmltYXRpb25zLnMsIDEwMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsID0gKF9sID0gKF9rID0gcGFydGljbGUuc3Ryb2tlQ29sb3IpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5sKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiAoX20gPSBwYXJ0aWNsZS5jb2xvcikgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmw7XG4gICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sb3JWYWx1ZShwYXJ0aWNsZSwgZGVsdGEsIGwsIGhzbEFuaW1hdGlvbnMubCwgMTAwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDb2xvclZhbHVlKHBhcnRpY2xlLCBkZWx0YSwgdmFsdWUsIHZhbHVlQW5pbWF0aW9uLCBtYXgsIGRlY3JlYXNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoIWNvbG9yVmFsdWUgfHwgIXZhbHVlQW5pbWF0aW9uLmVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZSh2YWx1ZUFuaW1hdGlvbi5vZmZzZXQpO1xuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9ICgoX2EgPSB2YWx1ZS52ZWxvY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKiBkZWx0YS5mYWN0b3IgKyBvZmZzZXQgKiAzLjY7XG4gICAgICAgIGlmICghZGVjcmVhc2UgfHwgY29sb3JWYWx1ZS5zdGF0dXMgPT09IEVudW1zXzEuQW5pbWF0aW9uU3RhdHVzLmluY3JlYXNpbmcpIHtcbiAgICAgICAgICAgIGNvbG9yVmFsdWUudmFsdWUgKz0gdmVsb2NpdHk7XG4gICAgICAgICAgICBpZiAoZGVjcmVhc2UgJiYgY29sb3JWYWx1ZS52YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIGNvbG9yVmFsdWUuc3RhdHVzID0gRW51bXNfMS5BbmltYXRpb25TdGF0dXMuZGVjcmVhc2luZztcbiAgICAgICAgICAgICAgICBjb2xvclZhbHVlLnZhbHVlIC09IGNvbG9yVmFsdWUudmFsdWUgJSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvclZhbHVlLnZhbHVlIC09IHZlbG9jaXR5O1xuICAgICAgICAgICAgaWYgKGNvbG9yVmFsdWUudmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29sb3JWYWx1ZS5zdGF0dXMgPSBFbnVtc18xLkFuaW1hdGlvblN0YXR1cy5pbmNyZWFzaW5nO1xuICAgICAgICAgICAgICAgIGNvbG9yVmFsdWUudmFsdWUgKz0gY29sb3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3JWYWx1ZS52YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgY29sb3JWYWx1ZS52YWx1ZSAlPSBtYXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlT3V0TW9kZXMoZGVsdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvdXRNb2RlcyA9IHRoaXMucGFydGljbGUub3B0aW9ucy5tb3ZlLm91dE1vZGVzO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dE1vZGUoZGVsdGEsIChfYSA9IG91dE1vZGVzLmJvdHRvbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3V0TW9kZXMuZGVmYXVsdCwgT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24uYm90dG9tKTtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRNb2RlKGRlbHRhLCAoX2IgPSBvdXRNb2Rlcy5sZWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBvdXRNb2Rlcy5kZWZhdWx0LCBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5sZWZ0KTtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRNb2RlKGRlbHRhLCAoX2MgPSBvdXRNb2Rlcy5yaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogb3V0TW9kZXMuZGVmYXVsdCwgT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24ucmlnaHQpO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dE1vZGUoZGVsdGEsIChfZCA9IG91dE1vZGVzLnRvcCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3V0TW9kZXMuZGVmYXVsdCwgT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24udG9wKTtcbiAgICB9XG4gICAgdXBkYXRlT3V0TW9kZShkZWx0YSwgb3V0TW9kZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHRoaXMucGFydGljbGU7XG4gICAgICAgIHN3aXRjaCAob3V0TW9kZSkge1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUuYm91bmNlOlxuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUuYm91bmNlVmVydGljYWw6XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuT3V0TW9kZS5ib3VuY2VIb3Jpem9udGFsOlxuICAgICAgICAgICAgY2FzZSBcImJvdW5jZVZlcnRpY2FsXCI6XG4gICAgICAgICAgICBjYXNlIFwiYm91bmNlSG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUuc3BsaXQ6XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuY2UoZGVsdGEsIGRpcmVjdGlvbiwgb3V0TW9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuT3V0TW9kZS5kZXN0cm95OlxuICAgICAgICAgICAgICAgIGlmICghVXRpbHNfMS5VdGlscy5pc1BvaW50SW5zaWRlKHBhcnRpY2xlLnBvc2l0aW9uLCBjb250YWluZXIuY2FudmFzLnNpemUsIHBhcnRpY2xlLmdldFJhZGl1cygpLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJ0aWNsZXMucmVtb3ZlKHBhcnRpY2xlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuT3V0TW9kZS5vdXQ6XG4gICAgICAgICAgICAgICAgaWYgKCFVdGlsc18xLlV0aWxzLmlzUG9pbnRJbnNpZGUocGFydGljbGUucG9zaXRpb24sIGNvbnRhaW5lci5jYW52YXMuc2l6ZSwgcGFydGljbGUuZ2V0UmFkaXVzKCksIGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhPdXRPZkNhbnZhc1Bvc2l0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLk91dE1vZGUubm9uZTpcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5jZU5vbmUoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXhPdXRPZkNhbnZhc1Bvc2l0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBjb25zdCB3cmFwID0gcGFydGljbGUub3B0aW9ucy5tb3ZlLndhcnA7XG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSBjb250YWluZXIuY2FudmFzLnNpemU7XG4gICAgICAgIGNvbnN0IG5ld1BvcyA9IHtcbiAgICAgICAgICAgIGJvdHRvbTogY2FudmFzU2l6ZS5oZWlnaHQgKyBwYXJ0aWNsZS5nZXRSYWRpdXMoKSAtIHBhcnRpY2xlLm9mZnNldC55LFxuICAgICAgICAgICAgbGVmdDogLXBhcnRpY2xlLmdldFJhZGl1cygpIC0gcGFydGljbGUub2Zmc2V0LngsXG4gICAgICAgICAgICByaWdodDogY2FudmFzU2l6ZS53aWR0aCArIHBhcnRpY2xlLmdldFJhZGl1cygpICsgcGFydGljbGUub2Zmc2V0LngsXG4gICAgICAgICAgICB0b3A6IC1wYXJ0aWNsZS5nZXRSYWRpdXMoKSAtIHBhcnRpY2xlLm9mZnNldC55LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaXplVmFsdWUgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKTtcbiAgICAgICAgY29uc3QgbmV4dEJvdW5kcyA9IFV0aWxzXzEuVXRpbHMuY2FsY3VsYXRlQm91bmRzKHBhcnRpY2xlLnBvc2l0aW9uLCBzaXplVmFsdWUpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5yaWdodCAmJiBuZXh0Qm91bmRzLmxlZnQgPiBjYW52YXNTaXplLndpZHRoIC0gcGFydGljbGUub2Zmc2V0LngpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBuZXdQb3MubGVmdDtcbiAgICAgICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgPSBNYXRoLnJhbmRvbSgpICogY2FudmFzU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5sZWZ0ICYmIG5leHRCb3VuZHMucmlnaHQgPCAtcGFydGljbGUub2Zmc2V0LngpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBuZXdQb3MucmlnaHQ7XG4gICAgICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhc1NpemUuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLmJvdHRvbSAmJiBuZXh0Qm91bmRzLnRvcCA+IGNhbnZhc1NpemUuaGVpZ2h0IC0gcGFydGljbGUub2Zmc2V0LnkpIHtcbiAgICAgICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBNYXRoLnJhbmRvbSgpICogY2FudmFzU2l6ZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgPSBuZXdQb3MudG9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24udG9wICYmIG5leHRCb3VuZHMuYm90dG9tIDwgLXBhcnRpY2xlLm9mZnNldC55KSB7XG4gICAgICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhc1NpemUud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ID0gbmV3UG9zLmJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVCb3VuY2UoZGVsdGEsIGRpcmVjdGlvbiwgb3V0TW9kZSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ucGFydGljbGVCb3VuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSBwbHVnaW4ucGFydGljbGVCb3VuY2UocGFydGljbGUsIGRlbHRhLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCksIG9mZnNldCA9IHBhcnRpY2xlLm9mZnNldCwgc2l6ZSA9IHBhcnRpY2xlLmdldFJhZGl1cygpLCBib3VuZHMgPSBVdGlsc18xLlV0aWxzLmNhbGN1bGF0ZUJvdW5kcyhwb3MsIHNpemUpLCBjYW52YXNTaXplID0gY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICBib3VuY2VIb3Jpem9udGFsKHsgcGFydGljbGUsIG91dE1vZGUsIGRpcmVjdGlvbiwgYm91bmRzLCBjYW52YXNTaXplLCBvZmZzZXQsIHNpemUgfSk7XG4gICAgICAgIGJvdW5jZVZlcnRpY2FsKHsgcGFydGljbGUsIG91dE1vZGUsIGRpcmVjdGlvbiwgYm91bmRzLCBjYW52YXNTaXplLCBvZmZzZXQsIHNpemUgfSk7XG4gICAgfVxuICAgIGJvdW5jZU5vbmUoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZTtcbiAgICAgICAgaWYgKHBhcnRpY2xlLm9wdGlvbnMubW92ZS5kaXN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyYXZpdHlPcHRpb25zID0gcGFydGljbGUub3B0aW9ucy5tb3ZlLmdyYXZpdHk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAoIWdyYXZpdHlPcHRpb25zLmVuYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFVdGlsc18xLlV0aWxzLmlzUG9pbnRJbnNpZGUocGFydGljbGUucG9zaXRpb24sIGNvbnRhaW5lci5jYW52YXMuc2l6ZSwgcGFydGljbGUuZ2V0UmFkaXVzKCksIGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLnJlbW92ZShwYXJ0aWNsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBhcnRpY2xlLnBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKChncmF2aXR5T3B0aW9ucy5hY2NlbGVyYXRpb24gPj0gMCAmJlxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgPiBjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5ib3R0b20pIHx8XG4gICAgICAgICAgICAgICAgKGdyYXZpdHlPcHRpb25zLmFjY2VsZXJhdGlvbiA8IDAgJiYgcG9zaXRpb24ueSA8IDAgJiYgZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi50b3ApKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5yZW1vdmUocGFydGljbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VcGRhdGVyID0gVXBkYXRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZWN0b3IgPSB2b2lkIDA7XG5jbGFzcyBWZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgbGV0IGRlZlgsIGRlZlk7XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRzUGFydGljbGVzIC0gVmVjdG9yIG5vdCBpbml0aWFsaXplZCBjb3JyZWN0bHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSB4O1xuICAgICAgICAgICAgW2RlZlgsIGRlZlldID0gW2Nvb3Jkcy54LCBjb29yZHMueV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBbZGVmWCwgZGVmWV0gPSBbeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gZGVmWDtcbiAgICAgICAgdGhpcy55ID0gZGVmWTtcbiAgICB9XG4gICAgc3RhdGljIGNsb25lKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShzb3VyY2UueCwgc291cmNlLnkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSk7XG4gICAgfVxuICAgIGdldCBhbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH1cbiAgICBzZXQgYW5nbGUoYW5nbGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tQW5nbGUoYW5nbGUsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLngsIDIpICsgTWF0aC5wb3codGhpcy55LCAyKSk7XG4gICAgfVxuICAgIHNldCBsZW5ndGgobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUFuZ2xlKHRoaXMuYW5nbGUsIGxlbmd0aCk7XG4gICAgfVxuICAgIGFkZCh2KSB7XG4gICAgICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcbiAgICB9XG4gICAgYWRkVG8odikge1xuICAgICAgICB0aGlzLnggKz0gdi54O1xuICAgICAgICB0aGlzLnkgKz0gdi55O1xuICAgIH1cbiAgICBzdWIodikge1xuICAgICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZSh0aGlzLnggLSB2LngsIHRoaXMueSAtIHYueSk7XG4gICAgfVxuICAgIHN1YkZyb20odikge1xuICAgICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgICB0aGlzLnkgLT0gdi55O1xuICAgIH1cbiAgICBtdWx0KG4pIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUodGhpcy54ICogbiwgdGhpcy55ICogbik7XG4gICAgfVxuICAgIG11bHRUbyhuKSB7XG4gICAgICAgIHRoaXMueCAqPSBuO1xuICAgICAgICB0aGlzLnkgKj0gbjtcbiAgICB9XG4gICAgZGl2KG4pIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUodGhpcy54IC8gbiwgdGhpcy55IC8gbik7XG4gICAgfVxuICAgIGRpdlRvKG4pIHtcbiAgICAgICAgdGhpcy54IC89IG47XG4gICAgICAgIHRoaXMueSAvPSBuO1xuICAgIH1cbiAgICBkaXN0YW5jZVRvKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHYpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0TGVuZ3RoU3EoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLngsIDIpICsgTWF0aC5wb3codGhpcy55LCAyKTtcbiAgICB9XG4gICAgZGlzdGFuY2VUb1NxKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHYpLmdldExlbmd0aFNxKCk7XG4gICAgfVxuICAgIG1hbmhhdHRhbkRpc3RhbmNlVG8odikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModi54IC0gdGhpcy54KSArIE1hdGguYWJzKHYueSAtIHRoaXMueSk7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3IuY2xvbmUodGhpcyk7XG4gICAgfVxuICAgIHNldFRvKHZlbG9jaXR5KSB7XG4gICAgICAgIHRoaXMueCA9IHZlbG9jaXR5Lng7XG4gICAgICAgIHRoaXMueSA9IHZlbG9jaXR5Lnk7XG4gICAgfVxuICAgIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZSh0aGlzLnggKiBNYXRoLmNvcyhhbmdsZSkgLSB0aGlzLnkgKiBNYXRoLnNpbihhbmdsZSksIHRoaXMueCAqIE1hdGguc2luKGFuZ2xlKSArIHRoaXMueSAqIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21BbmdsZShhbmdsZSwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMueCA9IE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aDtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoO1xuICAgIH1cbn1cbmV4cG9ydHMuVmVjdG9yID0gVmVjdG9yO1xuVmVjdG9yLm9yaWdpbiA9IFZlY3Rvci5jcmVhdGUoMCwgMCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGljbGVzID0gdm9pZCAwO1xuY29uc3QgUGFydGljbGVfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGUvSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuY29uc3QgUGFydGljbGVzT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvUGFydGljbGVzT3B0aW9uc1wiKTtcbmNsYXNzIFBhcnRpY2xlcyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5saW1pdCA9IDA7XG4gICAgICAgIHRoaXMubGlua3NGcmVxID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlc0ZyZXEgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gbmV3IEludGVyYWN0aW9uTWFuYWdlcl8xLkludGVyYWN0aW9uTWFuYWdlcihjb250YWluZXIpO1xuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gdGhpcy5jb250YWluZXIuY2FudmFzLnNpemU7XG4gICAgICAgIHRoaXMubGlua3NDb2xvcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucXVhZFRyZWUgPSBuZXcgVXRpbHNfMS5RdWFkVHJlZShuZXcgVXRpbHNfMS5SZWN0YW5nbGUoLWNhbnZhc1NpemUud2lkdGggLyA0LCAtY2FudmFzU2l6ZS5oZWlnaHQgLyA0LCAoY2FudmFzU2l6ZS53aWR0aCAqIDMpIC8gMiwgKGNhbnZhc1NpemUuaGVpZ2h0ICogMykgLyAyKSwgNCk7XG4gICAgfVxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICB0aGlzLmxpbmtzRnJlcSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZXNGcmVxID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIG9wdGlvbnMubWFudWFsUGFydGljbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBwYXJ0aWNsZS5wb3NpdGlvblxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB4OiAocGFydGljbGUucG9zaXRpb24ueCAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCkgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IChwYXJ0aWNsZS5wb3NpdGlvbi55ICogY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCkgLyAxMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hZGRQYXJ0aWNsZShwb3MsIHBhcnRpY2xlLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgWywgcGx1Z2luXSBvZiBjb250YWluZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKHBsdWdpbi5wYXJ0aWNsZXNJbml0aWFsaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHBsdWdpbi5wYXJ0aWNsZXNJbml0aWFsaXphdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvdW50OyBpIDwgb3B0aW9ucy5wYXJ0aWNsZXMubnVtYmVyLnZhbHVlOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcnRpY2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5mZWN0aW9uLmVuYWJsZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmluZmVjdGlvbi5pbmZlY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RJbmZlY3RlZCA9IHRoaXMuYXJyYXkuZmlsdGVyKChwKSA9PiBwLmluZmVjdGVyLmluZmVjdGlvblN0YWdlID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZmVjdGVkID0gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KG5vdEluZmVjdGVkKTtcbiAgICAgICAgICAgICAgICBpbmZlY3RlZC5pbmZlY3Rlci5zdGFydEluZmVjdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5pbml0KCk7XG4gICAgICAgIGNvbnRhaW5lci5wYXRoR2VuZXJhdG9yLmluaXQoKTtcbiAgICB9XG4gICAgcmVkcmF3KCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB0aGlzLmRyYXcoeyB2YWx1ZTogMCwgZmFjdG9yOiAwIH0pO1xuICAgIH1cbiAgICByZW1vdmVBdChpbmRleCwgcXVhbnRpdHksIG92ZXJyaWRlKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMuY291bnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIHF1YW50aXR5ICE9PSBudWxsICYmIHF1YW50aXR5ICE9PSB2b2lkIDAgPyBxdWFudGl0eSA6IDEpKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUuZGVzdHJveShvdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHBhcnRpY2xlLCBvdmVycmlkZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KHRoaXMuYXJyYXkuaW5kZXhPZihwYXJ0aWNsZSksIHVuZGVmaW5lZCwgb3ZlcnJpZGUpO1xuICAgIH1cbiAgICB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc1RvRGVsZXRlID0gW107XG4gICAgICAgIGNvbnRhaW5lci5wYXRoR2VuZXJhdG9yLnVwZGF0ZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IFssIHBsdWdpbl0gb2YgY29udGFpbmVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW4udXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4udXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUZhY3RvciA9IHRoaXMuY29udGFpbmVyLmNhbnZhcy5yZXNpemVGYWN0b3I7XG4gICAgICAgICAgICBpZiAocmVzaXplRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueCAqPSByZXNpemVGYWN0b3Iud2lkdGg7XG4gICAgICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSAqPSByZXNpemVGYWN0b3IuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFydGljbGUubW92ZShkZWx0YSk7XG4gICAgICAgICAgICBpZiAocGFydGljbGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGVzVG9EZWxldGUucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1YWRUcmVlLmluc2VydChuZXcgVXRpbHNfMS5Qb2ludChwYXJ0aWNsZS5nZXRQb3NpdGlvbigpLCBwYXJ0aWNsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgcGFydGljbGVzVG9EZWxldGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHBhcnRpY2xlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5leHRlcm5hbEludGVyYWN0KGRlbHRhKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiB0aGlzLmNvbnRhaW5lci5wYXJ0aWNsZXMuYXJyYXkpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2xlLmRlc3Ryb3llZCAmJiAhcGFydGljbGUuc3Bhd25pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5wYXJ0aWNsZXNJbnRlcmFjdChwYXJ0aWNsZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjb250YWluZXIuY2FudmFzLnJlc2l6ZUZhY3RvcjtcbiAgICB9XG4gICAgZHJhdyhkZWx0YSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29udGFpbmVyLmNhbnZhcy5jbGVhcigpO1xuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gdGhpcy5jb250YWluZXIuY2FudmFzLnNpemU7XG4gICAgICAgIHRoaXMucXVhZFRyZWUgPSBuZXcgVXRpbHNfMS5RdWFkVHJlZShuZXcgVXRpbHNfMS5SZWN0YW5nbGUoLWNhbnZhc1NpemUud2lkdGggLyA0LCAtY2FudmFzU2l6ZS5oZWlnaHQgLyA0LCAoY2FudmFzU2l6ZS53aWR0aCAqIDMpIC8gMiwgKGNhbnZhc1NpemUuaGVpZ2h0ICogMykgLyAyKSwgNCk7XG4gICAgICAgIHRoaXMudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIGNvbnRhaW5lci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmRyYXdQbHVnaW4ocGx1Z2luLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIHAuZHJhdyhkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgcHVzaChuYiwgbW91c2UsIG92ZXJyaWRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMucGFydGljbGVzLm51bWJlci5saW1pdCAqIGNvbnRhaW5lci5kZW5zaXR5O1xuICAgICAgICB0aGlzLnB1c2hpbmcgPSB0cnVlO1xuICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudFRvUmVtb3ZlID0gdGhpcy5jb3VudCArIG5iIC0gbGltaXQ7XG4gICAgICAgICAgICBpZiAoY291bnRUb1JlbW92ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVF1YW50aXR5KGNvdW50VG9SZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRQYXJ0aWNsZShtb3VzZSA9PT0gbnVsbCB8fCBtb3VzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW91c2UucG9zaXRpb24sIG92ZXJyaWRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZFBhcnRpY2xlKHBvc2l0aW9uLCBvdmVycmlkZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFBhcnRpY2xlKHBvc2l0aW9uLCBvdmVycmlkZU9wdGlvbnMpO1xuICAgIH1cbiAgICBhZGRTcGxpdFBhcnRpY2xlKHBhcmVudCkge1xuICAgICAgICBjb25zdCBzcGxpdE9wdGlvbnMgPSBwYXJlbnQub3B0aW9ucy5kZXN0cm95LnNwbGl0O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbmV3IFBhcnRpY2xlc09wdGlvbnNfMS5QYXJ0aWNsZXNPcHRpb25zKCk7XG4gICAgICAgIG9wdGlvbnMubG9hZChwYXJlbnQub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0UmFuZ2VWYWx1ZShzcGxpdE9wdGlvbnMuZmFjdG9yLnZhbHVlKTtcbiAgICAgICAgb3B0aW9ucy5jb2xvci5sb2FkKHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgaHNsOiBwYXJlbnQuZ2V0RmlsbENvbG9yKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUudmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2l6ZS52YWx1ZSAvPSBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnNpemUudmFsdWUubWluIC89IGZhY3RvcjtcbiAgICAgICAgICAgIG9wdGlvbnMuc2l6ZS52YWx1ZS5tYXggLz0gZmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMubG9hZChzcGxpdE9wdGlvbnMucGFydGljbGVzKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKC1wYXJlbnQuc2l6ZS52YWx1ZSwgcGFyZW50LnNpemUudmFsdWUpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBhcmVudC5wb3NpdGlvbi54ICsgVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKG9mZnNldCksXG4gICAgICAgICAgICB5OiBwYXJlbnQucG9zaXRpb24ueSArIFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZShvZmZzZXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoUGFydGljbGUocG9zaXRpb24sIG9wdGlvbnMsIChwYXJ0aWNsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLnNpemUudmFsdWUgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5sZW5ndGggPSBVdGlsc18xLk51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UoVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKHBhcmVudC52ZWxvY2l0eS5sZW5ndGgsIHBhcnRpY2xlLnZlbG9jaXR5Lmxlbmd0aCkpO1xuICAgICAgICAgICAgcGFydGljbGUuc3BsaXRDb3VudCA9IHBhcmVudC5zcGxpdENvdW50ICsgMTtcbiAgICAgICAgICAgIHBhcnRpY2xlLnVuYnJlYWthYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnVuYnJlYWthYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVRdWFudGl0eShxdWFudGl0eSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KDAsIHF1YW50aXR5KTtcbiAgICB9XG4gICAgZ2V0TGlua0ZyZXF1ZW5jeShwMSwgcDIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7TWF0aC5taW4ocDEuaWQsIHAyLmlkKX1fJHtNYXRoLm1heChwMS5pZCwgcDIuaWQpfWA7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLmxpbmtzRnJlcS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgdGhpcy5saW5rc0ZyZXEuc2V0KGtleSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBnZXRUcmlhbmdsZUZyZXF1ZW5jeShwMSwgcDIsIHAzKSB7XG4gICAgICAgIGxldCBbaWQxLCBpZDIsIGlkM10gPSBbcDEuaWQsIHAyLmlkLCBwMy5pZF07XG4gICAgICAgIGlmIChpZDEgPiBpZDIpIHtcbiAgICAgICAgICAgIFtpZDIsIGlkMV0gPSBbaWQxLCBpZDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZDIgPiBpZDMpIHtcbiAgICAgICAgICAgIFtpZDMsIGlkMl0gPSBbaWQyLCBpZDNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZDEgPiBpZDMpIHtcbiAgICAgICAgICAgIFtpZDMsIGlkMV0gPSBbaWQxLCBpZDNdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2lkMX1fJHtpZDJ9XyR7aWQzfWA7XG4gICAgICAgIGxldCByZXMgPSB0aGlzLnRyaWFuZ2xlc0ZyZXEuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGVzRnJlcS5zZXQoa2V5LCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHNldERlbnNpdHkoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICB0aGlzLmFwcGx5RGVuc2l0eShvcHRpb25zLnBhcnRpY2xlcyk7XG4gICAgfVxuICAgIGFwcGx5RGVuc2l0eShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoKF9hID0gb3B0aW9ucy5udW1iZXIuZGVuc2l0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1iZXJPcHRpb25zID0gb3B0aW9ucy5udW1iZXI7XG4gICAgICAgIGNvbnN0IGRlbnNpdHlGYWN0b3IgPSB0aGlzLmluaXREZW5zaXR5RmFjdG9yKG51bWJlck9wdGlvbnMuZGVuc2l0eSk7XG4gICAgICAgIGNvbnN0IG9wdFBhcnRpY2xlc051bWJlciA9IG51bWJlck9wdGlvbnMudmFsdWU7XG4gICAgICAgIGNvbnN0IG9wdFBhcnRpY2xlc0xpbWl0ID0gbnVtYmVyT3B0aW9ucy5saW1pdCA+IDAgPyBudW1iZXJPcHRpb25zLmxpbWl0IDogb3B0UGFydGljbGVzTnVtYmVyO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXNOdW1iZXIgPSBNYXRoLm1pbihvcHRQYXJ0aWNsZXNOdW1iZXIsIG9wdFBhcnRpY2xlc0xpbWl0KSAqIGRlbnNpdHlGYWN0b3I7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc0NvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgdGhpcy5saW1pdCA9IG51bWJlck9wdGlvbnMubGltaXQgKiBkZW5zaXR5RmFjdG9yO1xuICAgICAgICBpZiAocGFydGljbGVzQ291bnQgPCBwYXJ0aWNsZXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChNYXRoLmFicyhwYXJ0aWNsZXNOdW1iZXIgLSBwYXJ0aWNsZXNDb3VudCksIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydGljbGVzQ291bnQgPiBwYXJ0aWNsZXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUXVhbnRpdHkocGFydGljbGVzQ291bnQgLSBwYXJ0aWNsZXNOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREZW5zaXR5RmFjdG9yKGRlbnNpdHlPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5jYW52YXMuZWxlbWVudCB8fCAhZGVuc2l0eU9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW52YXMgPSBjb250YWluZXIuY2FudmFzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIHJldHVybiAoY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodCkgLyAoZGVuc2l0eU9wdGlvbnMuZmFjdG9yICogcHhSYXRpbyAqIHB4UmF0aW8gKiBkZW5zaXR5T3B0aW9ucy5hcmVhKTtcbiAgICB9XG4gICAgcHVzaFBhcnRpY2xlKHBvc2l0aW9uLCBvdmVycmlkZU9wdGlvbnMsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IG5ldyBQYXJ0aWNsZV8xLlBhcnRpY2xlKHRoaXMubmV4dElkLCB0aGlzLmNvbnRhaW5lciwgcG9zaXRpb24sIG92ZXJyaWRlT3B0aW9ucyk7XG4gICAgICAgICAgICBsZXQgY2FuQWRkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplcikge1xuICAgICAgICAgICAgICAgIGNhbkFkZCA9IGluaXRpYWxpemVyKHBhcnRpY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuQWRkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcnJheS5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgICAgIHRoaXMubmV4dElkKys7XG4gICAgICAgICAgICByZXR1cm4gcGFydGljbGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgZXJyb3IgYWRkaW5nIHBhcnRpY2xlOiAke2V9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhcnRpY2xlcyA9IFBhcnRpY2xlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXRpbmEgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY2xhc3MgUmV0aW5hIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICFvcHRpb25zLmRldGVjdFJldGluYSB8fCBVdGlsc18xLlV0aWxzLmlzU3NyKCkgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IG1vdGlvbk9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zLm1vdGlvbjtcbiAgICAgICAgaWYgKG1vdGlvbk9wdGlvbnMgJiYgKG1vdGlvbk9wdGlvbnMuZGlzYWJsZSB8fCBtb3Rpb25PcHRpb25zLnJlZHVjZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzU3NyKCkgfHwgdHlwZW9mIG1hdGNoTWVkaWEgPT09IFwidW5kZWZpbmVkXCIgfHwgIW1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZUZhY3RvciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gbWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpO1xuICAgICAgICAgICAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW90aW9uQ2hhbmdlKG1lZGlhUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdGlvbkNoYW5nZShtZWRpYVF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWZyZXNoKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVkaWFRdWVyeS5hZGRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKGhhbmRsZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUZhY3RvciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIGlmIChjb250YWluZXIuY2FudmFzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXIuY2FudmFzLmVsZW1lbnQ7XG4gICAgICAgICAgICBjb250YWluZXIuY2FudmFzLnNpemUud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoICogcmF0aW87XG4gICAgICAgICAgICBjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBvcHRpb25zLnBhcnRpY2xlcztcbiAgICAgICAgdGhpcy5saW5rc0Rpc3RhbmNlID0gcGFydGljbGVzLmxpbmtzLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIHRoaXMubGlua3NXaWR0aCA9IHBhcnRpY2xlcy5saW5rcy53aWR0aCAqIHJhdGlvO1xuICAgICAgICB0aGlzLnNpemVBbmltYXRpb25TcGVlZCA9IHBhcnRpY2xlcy5zaXplLmFuaW1hdGlvbi5zcGVlZCAqIHJhdGlvO1xuICAgICAgICBjb25zdCBtb2RlcyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2RlcztcbiAgICAgICAgdGhpcy5jb25uZWN0TW9kZURpc3RhbmNlID0gbW9kZXMuY29ubmVjdC5kaXN0YW5jZSAqIHJhdGlvO1xuICAgICAgICB0aGlzLmNvbm5lY3RNb2RlUmFkaXVzID0gbW9kZXMuY29ubmVjdC5yYWRpdXMgKiByYXRpbztcbiAgICAgICAgdGhpcy5ncmFiTW9kZURpc3RhbmNlID0gbW9kZXMuZ3JhYi5kaXN0YW5jZSAqIHJhdGlvO1xuICAgICAgICB0aGlzLnJlcHVsc2VNb2RlRGlzdGFuY2UgPSBtb2Rlcy5yZXB1bHNlLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIHRoaXMuYm91bmNlTW9kZURpc3RhbmNlID0gbW9kZXMuYm91bmNlLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIHRoaXMuYXR0cmFjdE1vZGVEaXN0YW5jZSA9IG1vZGVzLmF0dHJhY3QuZGlzdGFuY2UgKiByYXRpbztcbiAgICAgICAgdGhpcy5zbG93TW9kZVJhZGl1cyA9IG1vZGVzLnNsb3cucmFkaXVzICogcmF0aW87XG4gICAgICAgIHRoaXMuYnViYmxlTW9kZURpc3RhbmNlID0gbW9kZXMuYnViYmxlLmRpc3RhbmNlICogcmF0aW87XG4gICAgICAgIGlmIChtb2Rlcy5idWJibGUuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5idWJibGVNb2RlU2l6ZSA9IG1vZGVzLmJ1YmJsZS5zaXplICogcmF0aW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFBhcnRpY2xlKHBhcnRpY2xlKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlc09wdGlvbnMgPSBwYXJ0aWNsZS5vcHRpb25zO1xuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgcGFydGljbGUubGlua3NEaXN0YW5jZSA9IHBhcnRpY2xlc09wdGlvbnMubGlua3MuZGlzdGFuY2UgKiByYXRpbztcbiAgICAgICAgcGFydGljbGUubGlua3NXaWR0aCA9IHBhcnRpY2xlc09wdGlvbnMubGlua3Mud2lkdGggKiByYXRpbztcbiAgICAgICAgcGFydGljbGUubW92ZURyaWZ0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZVZhbHVlKHBhcnRpY2xlc09wdGlvbnMubW92ZS5kcmlmdCkgKiByYXRpbztcbiAgICAgICAgcGFydGljbGUubW92ZVNwZWVkID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZVZhbHVlKHBhcnRpY2xlc09wdGlvbnMubW92ZS5zcGVlZCkgKiByYXRpbztcbiAgICAgICAgcGFydGljbGUuc2l6ZUFuaW1hdGlvblNwZWVkID0gcGFydGljbGVzT3B0aW9ucy5zaXplLmFuaW1hdGlvbi5zcGVlZCAqIHJhdGlvO1xuICAgICAgICBwYXJ0aWNsZS5tYXhEaXN0YW5jZSA9IHBhcnRpY2xlc09wdGlvbnMubW92ZS5kaXN0YW5jZSAqIHJhdGlvO1xuICAgIH1cbiAgICBoYW5kbGVNb3Rpb25DaGFuZ2UobWVkaWFRdWVyeSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkubWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgbW90aW9uID0gb3B0aW9ucy5tb3Rpb247XG4gICAgICAgICAgICB0aGlzLnJlZHVjZUZhY3RvciA9IG1vdGlvbi5kaXNhYmxlID8gMCA6IG1vdGlvbi5yZWR1Y2UudmFsdWUgPyAxIC8gbW90aW9uLnJlZHVjZS5mYWN0b3IgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2VGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXRpbmEgPSBSZXRpbmE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW5pbWF0aW9uU3RhdHVzID0gdm9pZCAwO1xudmFyIEFuaW1hdGlvblN0YXR1cztcbihmdW5jdGlvbiAoQW5pbWF0aW9uU3RhdHVzKSB7XG4gICAgQW5pbWF0aW9uU3RhdHVzW0FuaW1hdGlvblN0YXR1c1tcImluY3JlYXNpbmdcIl0gPSAwXSA9IFwiaW5jcmVhc2luZ1wiO1xuICAgIEFuaW1hdGlvblN0YXR1c1tBbmltYXRpb25TdGF0dXNbXCJkZWNyZWFzaW5nXCJdID0gMV0gPSBcImRlY3JlYXNpbmdcIjtcbn0pKEFuaW1hdGlvblN0YXR1cyA9IGV4cG9ydHMuQW5pbWF0aW9uU3RhdHVzIHx8IChleHBvcnRzLkFuaW1hdGlvblN0YXR1cyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZURpcmVjdGlvbiA9IHZvaWQgMDtcbnZhciBNb3ZlRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNb3ZlRGlyZWN0aW9uKSB7XG4gICAgTW92ZURpcmVjdGlvbltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gICAgTW92ZURpcmVjdGlvbltcImJvdHRvbUxlZnRcIl0gPSBcImJvdHRvbS1sZWZ0XCI7XG4gICAgTW92ZURpcmVjdGlvbltcImJvdHRvbVJpZ2h0XCJdID0gXCJib3R0b20tcmlnaHRcIjtcbiAgICBNb3ZlRGlyZWN0aW9uW1wibGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIE1vdmVEaXJlY3Rpb25bXCJub25lXCJdID0gXCJub25lXCI7XG4gICAgTW92ZURpcmVjdGlvbltcInJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIE1vdmVEaXJlY3Rpb25bXCJ0b3BcIl0gPSBcInRvcFwiO1xuICAgIE1vdmVEaXJlY3Rpb25bXCJ0b3BMZWZ0XCJdID0gXCJ0b3AtbGVmdFwiO1xuICAgIE1vdmVEaXJlY3Rpb25bXCJ0b3BSaWdodFwiXSA9IFwidG9wLXJpZ2h0XCI7XG59KShNb3ZlRGlyZWN0aW9uID0gZXhwb3J0cy5Nb3ZlRGlyZWN0aW9uIHx8IChleHBvcnRzLk1vdmVEaXJlY3Rpb24gPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk91dE1vZGVEaXJlY3Rpb24gPSB2b2lkIDA7XG52YXIgT3V0TW9kZURpcmVjdGlvbjtcbihmdW5jdGlvbiAoT3V0TW9kZURpcmVjdGlvbikge1xuICAgIE91dE1vZGVEaXJlY3Rpb25bXCJib3R0b21cIl0gPSBcImJvdHRvbVwiO1xuICAgIE91dE1vZGVEaXJlY3Rpb25bXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgT3V0TW9kZURpcmVjdGlvbltcInJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIE91dE1vZGVEaXJlY3Rpb25bXCJ0b3BcIl0gPSBcInRvcFwiO1xufSkoT3V0TW9kZURpcmVjdGlvbiA9IGV4cG9ydHMuT3V0TW9kZURpcmVjdGlvbiB8fCAoZXhwb3J0cy5PdXRNb2RlRGlyZWN0aW9uID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Sb3RhdGVEaXJlY3Rpb24gPSB2b2lkIDA7XG52YXIgUm90YXRlRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChSb3RhdGVEaXJlY3Rpb24pIHtcbiAgICBSb3RhdGVEaXJlY3Rpb25bXCJjbG9ja3dpc2VcIl0gPSBcImNsb2Nrd2lzZVwiO1xuICAgIFJvdGF0ZURpcmVjdGlvbltcImNvdW50ZXJDbG9ja3dpc2VcIl0gPSBcImNvdW50ZXItY2xvY2t3aXNlXCI7XG4gICAgUm90YXRlRGlyZWN0aW9uW1wicmFuZG9tXCJdID0gXCJyYW5kb21cIjtcbn0pKFJvdGF0ZURpcmVjdGlvbiA9IGV4cG9ydHMuUm90YXRlRGlyZWN0aW9uIHx8IChleHBvcnRzLlJvdGF0ZURpcmVjdGlvbiA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01vdmVEaXJlY3Rpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1JvdGF0ZURpcmVjdGlvblwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJhY3Rpdml0eURldGVjdCA9IHZvaWQgMDtcbnZhciBJbnRlcmFjdGl2aXR5RGV0ZWN0O1xuKGZ1bmN0aW9uIChJbnRlcmFjdGl2aXR5RGV0ZWN0KSB7XG4gICAgSW50ZXJhY3Rpdml0eURldGVjdFtcImNhbnZhc1wiXSA9IFwiY2FudmFzXCI7XG4gICAgSW50ZXJhY3Rpdml0eURldGVjdFtcInBhcmVudFwiXSA9IFwicGFyZW50XCI7XG4gICAgSW50ZXJhY3Rpdml0eURldGVjdFtcIndpbmRvd1wiXSA9IFwid2luZG93XCI7XG59KShJbnRlcmFjdGl2aXR5RGV0ZWN0ID0gZXhwb3J0cy5JbnRlcmFjdGl2aXR5RGV0ZWN0IHx8IChleHBvcnRzLkludGVyYWN0aXZpdHlEZXRlY3QgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWNrTW9kZSA9IHZvaWQgMDtcbnZhciBDbGlja01vZGU7XG4oZnVuY3Rpb24gKENsaWNrTW9kZSkge1xuICAgIENsaWNrTW9kZVtcImF0dHJhY3RcIl0gPSBcImF0dHJhY3RcIjtcbiAgICBDbGlja01vZGVbXCJidWJibGVcIl0gPSBcImJ1YmJsZVwiO1xuICAgIENsaWNrTW9kZVtcInB1c2hcIl0gPSBcInB1c2hcIjtcbiAgICBDbGlja01vZGVbXCJyZW1vdmVcIl0gPSBcInJlbW92ZVwiO1xuICAgIENsaWNrTW9kZVtcInJlcHVsc2VcIl0gPSBcInJlcHVsc2VcIjtcbiAgICBDbGlja01vZGVbXCJwYXVzZVwiXSA9IFwicGF1c2VcIjtcbiAgICBDbGlja01vZGVbXCJ0cmFpbFwiXSA9IFwidHJhaWxcIjtcbn0pKENsaWNrTW9kZSA9IGV4cG9ydHMuQ2xpY2tNb2RlIHx8IChleHBvcnRzLkNsaWNrTW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sbGlzaW9uTW9kZSA9IHZvaWQgMDtcbnZhciBDb2xsaXNpb25Nb2RlO1xuKGZ1bmN0aW9uIChDb2xsaXNpb25Nb2RlKSB7XG4gICAgQ29sbGlzaW9uTW9kZVtcImFic29yYlwiXSA9IFwiYWJzb3JiXCI7XG4gICAgQ29sbGlzaW9uTW9kZVtcImJvdW5jZVwiXSA9IFwiYm91bmNlXCI7XG4gICAgQ29sbGlzaW9uTW9kZVtcImRlc3Ryb3lcIl0gPSBcImRlc3Ryb3lcIjtcbn0pKENvbGxpc2lvbk1vZGUgPSBleHBvcnRzLkNvbGxpc2lvbk1vZGUgfHwgKGV4cG9ydHMuQ29sbGlzaW9uTW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVzdHJveU1vZGUgPSB2b2lkIDA7XG52YXIgRGVzdHJveU1vZGU7XG4oZnVuY3Rpb24gKERlc3Ryb3lNb2RlKSB7XG4gICAgRGVzdHJveU1vZGVbXCJub25lXCJdID0gXCJub25lXCI7XG4gICAgRGVzdHJveU1vZGVbXCJzcGxpdFwiXSA9IFwic3BsaXRcIjtcbn0pKERlc3Ryb3lNb2RlID0gZXhwb3J0cy5EZXN0cm95TW9kZSB8fCAoZXhwb3J0cy5EZXN0cm95TW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGl2TW9kZSA9IHZvaWQgMDtcbnZhciBEaXZNb2RlO1xuKGZ1bmN0aW9uIChEaXZNb2RlKSB7XG4gICAgRGl2TW9kZVtcImJvdW5jZVwiXSA9IFwiYm91bmNlXCI7XG4gICAgRGl2TW9kZVtcImJ1YmJsZVwiXSA9IFwiYnViYmxlXCI7XG4gICAgRGl2TW9kZVtcInJlcHVsc2VcIl0gPSBcInJlcHVsc2VcIjtcbn0pKERpdk1vZGUgPSBleHBvcnRzLkRpdk1vZGUgfHwgKGV4cG9ydHMuRGl2TW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSG92ZXJNb2RlID0gdm9pZCAwO1xudmFyIEhvdmVyTW9kZTtcbihmdW5jdGlvbiAoSG92ZXJNb2RlKSB7XG4gICAgSG92ZXJNb2RlW1wiYXR0cmFjdFwiXSA9IFwiYXR0cmFjdFwiO1xuICAgIEhvdmVyTW9kZVtcImJvdW5jZVwiXSA9IFwiYm91bmNlXCI7XG4gICAgSG92ZXJNb2RlW1wiYnViYmxlXCJdID0gXCJidWJibGVcIjtcbiAgICBIb3Zlck1vZGVbXCJjb25uZWN0XCJdID0gXCJjb25uZWN0XCI7XG4gICAgSG92ZXJNb2RlW1wiZ3JhYlwiXSA9IFwiZ3JhYlwiO1xuICAgIEhvdmVyTW9kZVtcImxpZ2h0XCJdID0gXCJsaWdodFwiO1xuICAgIEhvdmVyTW9kZVtcInJlcHVsc2VcIl0gPSBcInJlcHVsc2VcIjtcbiAgICBIb3Zlck1vZGVbXCJzbG93XCJdID0gXCJzbG93XCI7XG4gICAgSG92ZXJNb2RlW1widHJhaWxcIl0gPSBcInRyYWlsXCI7XG59KShIb3Zlck1vZGUgPSBleHBvcnRzLkhvdmVyTW9kZSB8fCAoZXhwb3J0cy5Ib3Zlck1vZGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk91dE1vZGUgPSB2b2lkIDA7XG52YXIgT3V0TW9kZTtcbihmdW5jdGlvbiAoT3V0TW9kZSkge1xuICAgIE91dE1vZGVbXCJib3VuY2VcIl0gPSBcImJvdW5jZVwiO1xuICAgIE91dE1vZGVbXCJib3VuY2VIb3Jpem9udGFsXCJdID0gXCJib3VuY2UtaG9yaXpvbnRhbFwiO1xuICAgIE91dE1vZGVbXCJib3VuY2VWZXJ0aWNhbFwiXSA9IFwiYm91bmNlLXZlcnRpY2FsXCI7XG4gICAgT3V0TW9kZVtcIm5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICBPdXRNb2RlW1wib3V0XCJdID0gXCJvdXRcIjtcbiAgICBPdXRNb2RlW1wiZGVzdHJveVwiXSA9IFwiZGVzdHJveVwiO1xuICAgIE91dE1vZGVbXCJzcGxpdFwiXSA9IFwic3BsaXRcIjtcbn0pKE91dE1vZGUgPSBleHBvcnRzLk91dE1vZGUgfHwgKGV4cG9ydHMuT3V0TW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l6ZU1vZGUgPSB2b2lkIDA7XG52YXIgU2l6ZU1vZGU7XG4oZnVuY3Rpb24gKFNpemVNb2RlKSB7XG4gICAgU2l6ZU1vZGVbXCJwcmVjaXNlXCJdID0gXCJwcmVjaXNlXCI7XG4gICAgU2l6ZU1vZGVbXCJwZXJjZW50XCJdID0gXCJwZXJjZW50XCI7XG59KShTaXplTW9kZSA9IGV4cG9ydHMuU2l6ZU1vZGUgfHwgKGV4cG9ydHMuU2l6ZU1vZGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRoZW1lTW9kZSA9IHZvaWQgMDtcbnZhciBUaGVtZU1vZGU7XG4oZnVuY3Rpb24gKFRoZW1lTW9kZSkge1xuICAgIFRoZW1lTW9kZVtcImFueVwiXSA9IFwiYW55XCI7XG4gICAgVGhlbWVNb2RlW1wiZGFya1wiXSA9IFwiZGFya1wiO1xuICAgIFRoZW1lTW9kZVtcImxpZ2h0XCJdID0gXCJsaWdodFwiO1xufSkoVGhlbWVNb2RlID0gZXhwb3J0cy5UaGVtZU1vZGUgfHwgKGV4cG9ydHMuVGhlbWVNb2RlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2xpY2tNb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EZXN0cm95TW9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGl2TW9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSG92ZXJNb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db2xsaXNpb25Nb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9PdXRNb2RlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TaXplTW9kZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVGhlbWVNb2RlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGlyZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01vZGVzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza0lubGluZUFycmFuZ2VtZW50ID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9seWdvbk1hc2tJbmxpbmVBcnJhbmdlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW51bXNfMS5JbmxpbmVBcnJhbmdlbWVudDsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza01vdmVUeXBlID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9QbHVnaW5zL1BvbHlnb25NYXNrL0VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUG9seWdvbk1hc2tNb3ZlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW51bXNfMS5Nb3ZlVHlwZTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFza1R5cGUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uL1BsdWdpbnMvUG9seWdvbk1hc2svRW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2x5Z29uTWFza1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVudW1zXzEuVHlwZTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EaXJlY3Rpb25zXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlc3Ryb3lUeXBlID0gdm9pZCAwO1xudmFyIERlc3Ryb3lUeXBlO1xuKGZ1bmN0aW9uIChEZXN0cm95VHlwZSkge1xuICAgIERlc3Ryb3lUeXBlW1wibm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIERlc3Ryb3lUeXBlW1wibWF4XCJdID0gXCJtYXhcIjtcbiAgICBEZXN0cm95VHlwZVtcIm1pblwiXSA9IFwibWluXCI7XG59KShEZXN0cm95VHlwZSA9IGV4cG9ydHMuRGVzdHJveVR5cGUgfHwgKGV4cG9ydHMuRGVzdHJveVR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpdlR5cGUgPSB2b2lkIDA7XG52YXIgRGl2VHlwZTtcbihmdW5jdGlvbiAoRGl2VHlwZSkge1xuICAgIERpdlR5cGVbXCJjaXJjbGVcIl0gPSBcImNpcmNsZVwiO1xuICAgIERpdlR5cGVbXCJyZWN0YW5nbGVcIl0gPSBcInJlY3RhbmdsZVwiO1xufSkoRGl2VHlwZSA9IGV4cG9ydHMuRGl2VHlwZSB8fCAoZXhwb3J0cy5EaXZUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9jZXNzQnViYmxlVHlwZSA9IHZvaWQgMDtcbnZhciBQcm9jZXNzQnViYmxlVHlwZTtcbihmdW5jdGlvbiAoUHJvY2Vzc0J1YmJsZVR5cGUpIHtcbiAgICBQcm9jZXNzQnViYmxlVHlwZVtcImNvbG9yXCJdID0gXCJjb2xvclwiO1xuICAgIFByb2Nlc3NCdWJibGVUeXBlW1wib3BhY2l0eVwiXSA9IFwib3BhY2l0eVwiO1xuICAgIFByb2Nlc3NCdWJibGVUeXBlW1wic2l6ZVwiXSA9IFwic2l6ZVwiO1xufSkoUHJvY2Vzc0J1YmJsZVR5cGUgPSBleHBvcnRzLlByb2Nlc3NCdWJibGVUeXBlIHx8IChleHBvcnRzLlByb2Nlc3NCdWJibGVUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaGFwZVR5cGUgPSB2b2lkIDA7XG52YXIgU2hhcGVUeXBlO1xuKGZ1bmN0aW9uIChTaGFwZVR5cGUpIHtcbiAgICBTaGFwZVR5cGVbXCJjaGFyXCJdID0gXCJjaGFyXCI7XG4gICAgU2hhcGVUeXBlW1wiY2hhcmFjdGVyXCJdID0gXCJjaGFyYWN0ZXJcIjtcbiAgICBTaGFwZVR5cGVbXCJjaXJjbGVcIl0gPSBcImNpcmNsZVwiO1xuICAgIFNoYXBlVHlwZVtcImVkZ2VcIl0gPSBcImVkZ2VcIjtcbiAgICBTaGFwZVR5cGVbXCJpbWFnZVwiXSA9IFwiaW1hZ2VcIjtcbiAgICBTaGFwZVR5cGVbXCJpbWFnZXNcIl0gPSBcImltYWdlc1wiO1xuICAgIFNoYXBlVHlwZVtcImxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBTaGFwZVR5cGVbXCJwb2x5Z29uXCJdID0gXCJwb2x5Z29uXCI7XG4gICAgU2hhcGVUeXBlW1wic3F1YXJlXCJdID0gXCJzcXVhcmVcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyXCJdID0gXCJzdGFyXCI7XG4gICAgU2hhcGVUeXBlW1widHJpYW5nbGVcIl0gPSBcInRyaWFuZ2xlXCI7XG59KShTaGFwZVR5cGUgPSBleHBvcnRzLlNoYXBlVHlwZSB8fCAoZXhwb3J0cy5TaGFwZVR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXJ0VmFsdWVUeXBlID0gdm9pZCAwO1xudmFyIFN0YXJ0VmFsdWVUeXBlO1xuKGZ1bmN0aW9uIChTdGFydFZhbHVlVHlwZSkge1xuICAgIFN0YXJ0VmFsdWVUeXBlW1wibWF4XCJdID0gXCJtYXhcIjtcbiAgICBTdGFydFZhbHVlVHlwZVtcIm1pblwiXSA9IFwibWluXCI7XG4gICAgU3RhcnRWYWx1ZVR5cGVbXCJyYW5kb21cIl0gPSBcInJhbmRvbVwiO1xufSkoU3RhcnRWYWx1ZVR5cGUgPSBleHBvcnRzLlN0YXJ0VmFsdWVUeXBlIHx8IChleHBvcnRzLlN0YXJ0VmFsdWVUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGVzdHJveVR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1Byb2Nlc3NCdWJibGVUeXBlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TaGFwZVR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1N0YXJ0VmFsdWVUeXBlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9EaXZUeXBlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGlyZWN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTW9kZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0FuaW1hdGlvblN0YXR1c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ludGVyYWN0aXZpdHlEZXRlY3RcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJhY3RvciA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY2xhc3MgQXR0cmFjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgaWYgKCEoKGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBtb3VzZS5wb3NpdGlvbikgfHwgKGV2ZW50cy5vbkNsaWNrLmVuYWJsZSAmJiBtb3VzZS5jbGlja1Bvc2l0aW9uKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBldmVudHMub25DbGljay5tb2RlO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5Ib3Zlck1vZGUuYXR0cmFjdCwgaG92ZXJNb2RlKSB8fCBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5hdHRyYWN0LCBjbGlja01vZGUpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlTW92ZVN0YXR1cyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LnN0YXR1cyA9PT0gVXRpbHNfMS5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGNvbnN0IGhvdmVyRW5hYmxlZCA9IGV2ZW50cy5vbkhvdmVyLmVuYWJsZTtcbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgY29uc3QgY2xpY2tFbmFibGVkID0gZXZlbnRzLm9uQ2xpY2suZW5hYmxlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBldmVudHMub25DbGljay5tb2RlO1xuICAgICAgICBpZiAobW91c2VNb3ZlU3RhdHVzICYmIGhvdmVyRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5hdHRyYWN0LCBob3Zlck1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyQXR0cmFjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsaWNrRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5hdHRyYWN0LCBjbGlja01vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrQXR0cmFjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhvdmVyQXR0cmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgIGlmICghbW91c2VQb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRyYWN0UmFkaXVzID0gY29udGFpbmVyLnJldGluYS5hdHRyYWN0TW9kZURpc3RhbmNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NBdHRyYWN0KG1vdXNlUG9zLCBhdHRyYWN0UmFkaXVzLCBuZXcgVXRpbHNfMS5DaXJjbGUobW91c2VQb3MueCwgbW91c2VQb3MueSwgYXR0cmFjdFJhZGl1cykpO1xuICAgIH1cbiAgICBwcm9jZXNzQXR0cmFjdChwb3NpdGlvbiwgYXR0cmFjdFJhZGl1cywgYXJlYSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5KGFyZWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICBjb25zdCB7IGR4LCBkeSwgZGlzdGFuY2UgfSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKHBhcnRpY2xlLnBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBub3JtVmVjID0ge1xuICAgICAgICAgICAgICAgIHg6IGR4IC8gZGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgeTogZHkgLyBkaXN0YW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYXR0cmFjdC5zcGVlZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJhY3RGYWN0b3IgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKCgxIC0gTWF0aC5wb3coZGlzdGFuY2UgLyBhdHRyYWN0UmFkaXVzLCAyKSkgKiB2ZWxvY2l0eSwgMCwgNTApO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueCAtPSBub3JtVmVjLnggKiBhdHRyYWN0RmFjdG9yO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24ueSAtPSBub3JtVmVjLnkgKiBhdHRyYWN0RmFjdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsaWNrQXR0cmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICghY29udGFpbmVyLmF0dHJhY3QuZmluaXNoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5hdHRyYWN0LmNvdW50KSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuY291bnQrKztcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuYXR0cmFjdC5jb3VudCA9PT0gY29udGFpbmVyLnBhcnRpY2xlcy5jb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyYWN0LmZpbmlzaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5hdHRyYWN0LmNsaWNraW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLmNsaWNrUG9zaXRpb247XG4gICAgICAgICAgICBpZiAoIW1vdXNlUG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0cmFjdFJhZGl1cyA9IGNvbnRhaW5lci5yZXRpbmEuYXR0cmFjdE1vZGVEaXN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0F0dHJhY3QobW91c2VQb3MsIGF0dHJhY3RSYWRpdXMsIG5ldyBVdGlsc18xLkNpcmNsZShtb3VzZVBvcy54LCBtb3VzZVBvcy55LCBhdHRyYWN0UmFkaXVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyLmF0dHJhY3QuY2xpY2tpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXR0cmFjdC5wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0cy5BdHRyYWN0b3IgPSBBdHRyYWN0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm91bmNlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zXCIpO1xuY29uc3QgVmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vQ29yZS9QYXJ0aWNsZS9WZWN0b3JcIik7XG5jbGFzcyBCb3VuY2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgY29uc3QgZGl2cyA9IGV2ZW50cy5vbkRpdjtcbiAgICAgICAgcmV0dXJuICgobW91c2UucG9zaXRpb24gJiYgZXZlbnRzLm9uSG92ZXIuZW5hYmxlICYmIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuSG92ZXJNb2RlLmJvdW5jZSwgZXZlbnRzLm9uSG92ZXIubW9kZSkpIHx8XG4gICAgICAgICAgICBVdGlsc18xLlV0aWxzLmlzRGl2TW9kZUVuYWJsZWQoRW51bXNfMS5EaXZNb2RlLmJvdW5jZSwgZGl2cykpO1xuICAgIH1cbiAgICBpbnRlcmFjdCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgY29uc3QgbW91c2VNb3ZlU3RhdHVzID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBVdGlsc18xLkNvbnN0YW50cy5tb3VzZU1vdmVFdmVudDtcbiAgICAgICAgY29uc3QgaG92ZXJFbmFibGVkID0gZXZlbnRzLm9uSG92ZXIuZW5hYmxlO1xuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICBjb25zdCBkaXZzID0gZXZlbnRzLm9uRGl2O1xuICAgICAgICBpZiAobW91c2VNb3ZlU3RhdHVzICYmIGhvdmVyRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5ib3VuY2UsIGhvdmVyTW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc01vdXNlQm91bmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBVdGlsc18xLlV0aWxzLmRpdk1vZGVFeGVjdXRlKEVudW1zXzEuRGl2TW9kZS5ib3VuY2UsIGRpdnMsIChzZWxlY3RvciwgZGl2KSA9PiB0aGlzLnNpbmdsZVNlbGVjdG9yQm91bmNlKHNlbGVjdG9yLCBkaXYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG4gICAgcHJvY2Vzc01vdXNlQm91bmNlKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gMTAgKiBweFJhdGlvO1xuICAgICAgICBjb25zdCBtb3VzZVBvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBjb250YWluZXIucmV0aW5hLmJvdW5jZU1vZGVEaXN0YW5jZTtcbiAgICAgICAgaWYgKG1vdXNlUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NCb3VuY2UobW91c2VQb3MsIHJhZGl1cywgbmV3IFV0aWxzXzEuQ2lyY2xlKG1vdXNlUG9zLngsIG1vdXNlUG9zLnksIHJhZGl1cyArIHRvbGVyYW5jZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpbmdsZVNlbGVjdG9yQm91bmNlKHNlbGVjdG9yLCBkaXYpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGlmICghcXVlcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZW07XG4gICAgICAgICAgICBjb25zdCBweFJhdGlvID0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgcG9zID0ge1xuICAgICAgICAgICAgICAgIHg6IChlbGVtLm9mZnNldExlZnQgKyBlbGVtLm9mZnNldFdpZHRoIC8gMikgKiBweFJhdGlvLFxuICAgICAgICAgICAgICAgIHk6IChlbGVtLm9mZnNldFRvcCArIGVsZW0ub2Zmc2V0SGVpZ2h0IC8gMikgKiBweFJhdGlvLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IChlbGVtLm9mZnNldFdpZHRoIC8gMikgKiBweFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gMTAgKiBweFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGRpdi50eXBlID09PSBFbnVtc18xLkRpdlR5cGUuY2lyY2xlXG4gICAgICAgICAgICAgICAgPyBuZXcgVXRpbHNfMS5DaXJjbGUocG9zLngsIHBvcy55LCByYWRpdXMgKyB0b2xlcmFuY2UpXG4gICAgICAgICAgICAgICAgOiBuZXcgVXRpbHNfMS5SZWN0YW5nbGUoZWxlbS5vZmZzZXRMZWZ0ICogcHhSYXRpbyAtIHRvbGVyYW5jZSwgZWxlbS5vZmZzZXRUb3AgKiBweFJhdGlvIC0gdG9sZXJhbmNlLCBlbGVtLm9mZnNldFdpZHRoICogcHhSYXRpbyArIHRvbGVyYW5jZSAqIDIsIGVsZW0ub2Zmc2V0SGVpZ2h0ICogcHhSYXRpbyArIHRvbGVyYW5jZSAqIDIpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQm91bmNlKHBvcywgcmFkaXVzLCBhcmVhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NCb3VuY2UocG9zaXRpb24sIHJhZGl1cywgYXJlYSkge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMuY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeShhcmVhKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKGFyZWEgaW5zdGFuY2VvZiBVdGlsc18xLkNpcmNsZSkge1xuICAgICAgICAgICAgICAgIFV0aWxzXzEuVXRpbHMuY2lyY2xlQm91bmNlKFV0aWxzXzEuVXRpbHMuY2lyY2xlQm91bmNlRGF0YUZyb21QYXJ0aWNsZShwYXJ0aWNsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgbWFzczogKE1hdGgucG93KHJhZGl1cywgMikgKiBNYXRoLlBJKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5OiBWZWN0b3JfMS5WZWN0b3IuY3JlYXRlKDAsIDApLFxuICAgICAgICAgICAgICAgICAgICBmYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZWEgaW5zdGFuY2VvZiBVdGlsc18xLlJlY3RhbmdsZSkge1xuICAgICAgICAgICAgICAgIFV0aWxzXzEuVXRpbHMucmVjdEJvdW5jZShwYXJ0aWNsZSwgVXRpbHNfMS5VdGlscy5jYWxjdWxhdGVCb3VuZHMocG9zaXRpb24sIHJhZGl1cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Cb3VuY2VyID0gQm91bmNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWJibGVyID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5mdW5jdGlvbiBjYWxjdWxhdGVCdWJibGVWYWx1ZShwYXJ0aWNsZVZhbHVlLCBtb2RlVmFsdWUsIG9wdGlvbnNWYWx1ZSwgcmF0aW8pIHtcbiAgICBpZiAobW9kZVZhbHVlID4gb3B0aW9uc1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJ0aWNsZVZhbHVlICsgKG1vZGVWYWx1ZSAtIG9wdGlvbnNWYWx1ZSkgKiByYXRpbztcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuTnVtYmVyVXRpbHMuY2xhbXAoc2l6ZSwgcGFydGljbGVWYWx1ZSwgbW9kZVZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9kZVZhbHVlIDwgb3B0aW9uc1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJ0aWNsZVZhbHVlIC0gKG9wdGlvbnNWYWx1ZSAtIG1vZGVWYWx1ZSkgKiByYXRpbztcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuTnVtYmVyVXRpbHMuY2xhbXAoc2l6ZSwgbW9kZVZhbHVlLCBwYXJ0aWNsZVZhbHVlKTtcbiAgICB9XG59XG5jbGFzcyBCdWJibGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgY29uc3QgZGl2cyA9IGV2ZW50cy5vbkRpdjtcbiAgICAgICAgY29uc3QgZGl2QnViYmxlID0gVXRpbHNfMS5VdGlscy5pc0Rpdk1vZGVFbmFibGVkKEVudW1zXzEuRGl2TW9kZS5idWJibGUsIGRpdnMpO1xuICAgICAgICBpZiAoIShkaXZCdWJibGUgfHwgKGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBtb3VzZS5wb3NpdGlvbikgfHwgKGV2ZW50cy5vbkNsaWNrLmVuYWJsZSAmJiBtb3VzZS5jbGlja1Bvc2l0aW9uKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBldmVudHMub25DbGljay5tb2RlO1xuICAgICAgICByZXR1cm4gKFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuSG92ZXJNb2RlLmJ1YmJsZSwgaG92ZXJNb2RlKSB8fCBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5idWJibGUsIGNsaWNrTW9kZSkgfHwgZGl2QnViYmxlKTtcbiAgICB9XG4gICAgcmVzZXQocGFydGljbGUsIGZvcmNlKSB7XG4gICAgICAgIGlmICghcGFydGljbGUuYnViYmxlLmluUmFuZ2UgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUuZGl2O1xuICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5O1xuICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5yYWRpdXM7XG4gICAgICAgICAgICBkZWxldGUgcGFydGljbGUuYnViYmxlLmNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludGVyYWN0KCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgY29uc3Qgb25Ib3ZlciA9IGV2ZW50cy5vbkhvdmVyO1xuICAgICAgICBjb25zdCBvbkNsaWNrID0gZXZlbnRzLm9uQ2xpY2s7XG4gICAgICAgIGNvbnN0IGhvdmVyRW5hYmxlZCA9IG9uSG92ZXIuZW5hYmxlO1xuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBvbkhvdmVyLm1vZGU7XG4gICAgICAgIGNvbnN0IGNsaWNrRW5hYmxlZCA9IG9uQ2xpY2suZW5hYmxlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBvbkNsaWNrLm1vZGU7XG4gICAgICAgIGNvbnN0IGRpdnMgPSBldmVudHMub25EaXY7XG4gICAgICAgIGlmIChob3ZlckVuYWJsZWQgJiYgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5Ib3Zlck1vZGUuYnViYmxlLCBob3Zlck1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyQnViYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpY2tFbmFibGVkICYmIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuQ2xpY2tNb2RlLmJ1YmJsZSwgY2xpY2tNb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5jbGlja0J1YmJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5kaXZNb2RlRXhlY3V0ZShFbnVtc18xLkRpdk1vZGUuYnViYmxlLCBkaXZzLCAoc2VsZWN0b3IsIGRpdikgPT4gdGhpcy5zaW5nbGVTZWxlY3RvckhvdmVyKHNlbGVjdG9yLCBkaXYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaW5nbGVTZWxlY3RvckhvdmVyKHNlbGVjdG9yLCBkaXYpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIXNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RvcnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZW07XG4gICAgICAgICAgICBjb25zdCBweFJhdGlvID0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgcG9zID0ge1xuICAgICAgICAgICAgICAgIHg6IChlbGVtLm9mZnNldExlZnQgKyBlbGVtLm9mZnNldFdpZHRoIC8gMikgKiBweFJhdGlvLFxuICAgICAgICAgICAgICAgIHk6IChlbGVtLm9mZnNldFRvcCArIGVsZW0ub2Zmc2V0SGVpZ2h0IC8gMikgKiBweFJhdGlvLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcHVsc2VSYWRpdXMgPSAoZWxlbS5vZmZzZXRXaWR0aCAvIDIpICogcHhSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBkaXYudHlwZSA9PT0gRW51bXNfMS5EaXZUeXBlLmNpcmNsZVxuICAgICAgICAgICAgICAgID8gbmV3IFV0aWxzXzEuQ2lyY2xlKHBvcy54LCBwb3MueSwgcmVwdWxzZVJhZGl1cylcbiAgICAgICAgICAgICAgICA6IG5ldyBVdGlsc18xLlJlY3RhbmdsZShlbGVtLm9mZnNldExlZnQgKiBweFJhdGlvLCBlbGVtLm9mZnNldFRvcCAqIHB4UmF0aW8sIGVsZW0ub2Zmc2V0V2lkdGggKiBweFJhdGlvLCBlbGVtLm9mZnNldEhlaWdodCAqIHB4UmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5KGFyZWEpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghYXJlYS5jb250YWlucyhwYXJ0aWNsZS5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLmluUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpdnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmJ1YmJsZS5kaXZzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpdkJ1YmJsZSA9IFV0aWxzXzEuVXRpbHMuZGl2TW9kZShkaXZzLCBlbGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnRpY2xlLmJ1YmJsZS5kaXYgfHwgcGFydGljbGUuYnViYmxlLmRpdiAhPT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHBhcnRpY2xlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLmRpdiA9IGVsZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGVTaXplKHBhcnRpY2xlLCAxLCBkaXZCdWJibGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGVPcGFjaXR5KHBhcnRpY2xlLCAxLCBkaXZCdWJibGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJCdWJibGVDb2xvcihwYXJ0aWNsZSwgZGl2QnViYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3MocGFydGljbGUsIGRpc3RNb3VzZSwgdGltZVNwZW50LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBidWJibGVQYXJhbSA9IGRhdGEuYnViYmxlT2JqLm9wdFZhbHVlO1xuICAgICAgICBpZiAoYnViYmxlUGFyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgYnViYmxlRHVyYXRpb24gPSBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYnViYmxlLmR1cmF0aW9uO1xuICAgICAgICBjb25zdCBidWJibGVEaXN0YW5jZSA9IGNvbnRhaW5lci5yZXRpbmEuYnViYmxlTW9kZURpc3RhbmNlO1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXNQYXJhbSA9IGRhdGEucGFydGljbGVzT2JqLm9wdFZhbHVlO1xuICAgICAgICBjb25zdCBwT2JqQnViYmxlID0gZGF0YS5idWJibGVPYmoudmFsdWU7XG4gICAgICAgIGNvbnN0IHBPYmogPSBkYXRhLnBhcnRpY2xlc09iai52YWx1ZSB8fCAwO1xuICAgICAgICBjb25zdCB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICBpZiAoYnViYmxlUGFyYW0gIT09IHBhcnRpY2xlc1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5idWJibGUuZHVyYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdE1vdXNlIDw9IGJ1YmJsZURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHBPYmpCdWJibGUgIT09IG51bGwgJiYgcE9iakJ1YmJsZSAhPT0gdm9pZCAwID8gcE9iakJ1YmJsZSA6IHBPYmo7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogIT09IGJ1YmJsZVBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBPYmogLSAodGltZVNwZW50ICogKHBPYmogLSBidWJibGVQYXJhbSkpIC8gYnViYmxlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRW51bXNfMS5Qcm9jZXNzQnViYmxlVHlwZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEVudW1zXzEuUHJvY2Vzc0J1YmJsZVR5cGUub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBFbnVtc18xLlByb2Nlc3NCdWJibGVUeXBlLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBFbnVtc18xLlByb2Nlc3NCdWJibGVUeXBlLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBPYmpCdWJibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRW51bXNfMS5Qcm9jZXNzQnViYmxlVHlwZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUucmFkaXVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gRW51bXNfMS5Qcm9jZXNzQnViYmxlVHlwZS5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xpY2tCdWJibGUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlQ2xpY2tQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICBpZiAobW91c2VDbGlja1BvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBjb250YWluZXIucmV0aW5hLmJ1YmJsZU1vZGVEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5Q2lyY2xlKG1vdXNlQ2xpY2tQb3MsIGRpc3RhbmNlKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuYnViYmxlLmNsaWNraW5nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZS5idWJibGUuaW5SYW5nZSA9ICFjb250YWluZXIuYnViYmxlLmR1cmF0aW9uRW5kO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gcGFydGljbGUuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RNb3VzZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zLCBtb3VzZUNsaWNrUG9zKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTcGVudCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIChjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1RpbWUgfHwgMCkpIC8gMTAwMDtcbiAgICAgICAgICAgIGlmICh0aW1lU3BlbnQgPiBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYnViYmxlLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmJ1YmJsZS5kdXJhdGlvbkVuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZVNwZW50ID4gb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmJ1YmJsZS5kdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYnViYmxlLmNsaWNraW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmJ1YmJsZS5kdXJhdGlvbkVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgYnViYmxlT2JqOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdFZhbHVlOiBjb250YWluZXIucmV0aW5hLmJ1YmJsZU1vZGVTaXplLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFydGljbGUuYnViYmxlLnJhZGl1cyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlc09iajoge1xuICAgICAgICAgICAgICAgICAgICBvcHRWYWx1ZTogVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZU1heChwYXJ0aWNsZS5vcHRpb25zLnNpemUudmFsdWUpICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFydGljbGUuc2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHR5cGU6IEVudW1zXzEuUHJvY2Vzc0J1YmJsZVR5cGUuc2l6ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3MocGFydGljbGUsIGRpc3RNb3VzZSwgdGltZVNwZW50LCBzaXplRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBidWJibGVPYmo6IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0VmFsdWU6IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5idWJibGUub3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnRpY2xlLmJ1YmJsZS5vcGFjaXR5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFydGljbGVzT2JqOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdFZhbHVlOiBVdGlsc18xLk51bWJlclV0aWxzLmdldFJhbmdlTWF4KHBhcnRpY2xlLm9wdGlvbnMub3BhY2l0eS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0aWNsZS5vcGFjaXR5LnZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogRW51bXNfMS5Qcm9jZXNzQnViYmxlVHlwZS5vcGFjaXR5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhwYXJ0aWNsZSwgZGlzdE1vdXNlLCB0aW1lU3BlbnQsIG9wYWNpdHlEYXRhKTtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLmJ1YmJsZS5kdXJhdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0TW91c2UgPD0gY29udGFpbmVyLnJldGluYS5idWJibGVNb2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3ZlckJ1YmJsZUNvbG9yKHBhcnRpY2xlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJ0aWNsZS5idWJibGUuY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpY2xlLmJ1YmJsZS5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBob3ZlckJ1YmJsZSgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgIGlmIChtb3VzZVBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBjb250YWluZXIucmV0aW5hLmJ1YmJsZU1vZGVEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5Q2lyY2xlKG1vdXNlUG9zLCBkaXN0YW5jZSk7XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIHBhcnRpY2xlLmJ1YmJsZS5pblJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludERpc3RhbmNlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MsIG1vdXNlUG9zKTtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gMSAtIHBvaW50RGlzdGFuY2UgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgIGlmIChwb2ludERpc3RhbmNlIDw9IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhdGlvID49IDAgJiYgY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBVdGlsc18xLkNvbnN0YW50cy5tb3VzZU1vdmVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyQnViYmxlU2l6ZShwYXJ0aWNsZSwgcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyQnViYmxlT3BhY2l0eShwYXJ0aWNsZSwgcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyQnViYmxlQ29sb3IocGFydGljbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQocGFydGljbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LnN0YXR1cyA9PT0gVXRpbHNfMS5Db25zdGFudHMubW91c2VMZWF2ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldChwYXJ0aWNsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaG92ZXJCdWJibGVTaXplKHBhcnRpY2xlLCByYXRpbywgZGl2QnViYmxlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBtb2RlU2l6ZSA9IChkaXZCdWJibGUgPT09IG51bGwgfHwgZGl2QnViYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXZCdWJibGUuc2l6ZSlcbiAgICAgICAgICAgID8gZGl2QnViYmxlLnNpemUgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW9cbiAgICAgICAgICAgIDogY29udGFpbmVyLnJldGluYS5idWJibGVNb2RlU2l6ZTtcbiAgICAgICAgaWYgKG1vZGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRTaXplID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXRSYW5nZU1heChwYXJ0aWNsZS5vcHRpb25zLnNpemUudmFsdWUpICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICBjb25zdCBwU2l6ZSA9IHBhcnRpY2xlLnNpemUudmFsdWU7XG4gICAgICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVCdWJibGVWYWx1ZShwU2l6ZSwgbW9kZVNpemUsIG9wdFNpemUsIHJhdGlvKTtcbiAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLnJhZGl1cyA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaG92ZXJCdWJibGVPcGFjaXR5KHBhcnRpY2xlLCByYXRpbywgZGl2QnViYmxlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vZGVPcGFjaXR5ID0gKF9hID0gZGl2QnViYmxlID09PSBudWxsIHx8IGRpdkJ1YmJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGl2QnViYmxlLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5idWJibGUub3BhY2l0eTtcbiAgICAgICAgaWYgKG1vZGVPcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRPcGFjaXR5ID0gcGFydGljbGUub3B0aW9ucy5vcGFjaXR5LnZhbHVlO1xuICAgICAgICBjb25zdCBwT3BhY2l0eSA9IHBhcnRpY2xlLm9wYWNpdHkudmFsdWU7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBjYWxjdWxhdGVCdWJibGVWYWx1ZShwT3BhY2l0eSwgbW9kZU9wYWNpdHksIFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0UmFuZ2VNYXgob3B0T3BhY2l0eSksIHJhdGlvKTtcbiAgICAgICAgaWYgKG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFydGljbGUuYnViYmxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhvdmVyQnViYmxlQ29sb3IocGFydGljbGUsIGRpdkJ1YmJsZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBpZiAocGFydGljbGUuYnViYmxlLmNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVDb2xvciA9IChfYSA9IGRpdkJ1YmJsZSA9PT0gbnVsbCB8fCBkaXZCdWJibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpdkJ1YmJsZS5jb2xvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmJ1YmJsZS5jb2xvcjtcbiAgICAgICAgICAgIGlmIChtb2RlQ29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1YmJsZUNvbG9yID0gbW9kZUNvbG9yIGluc3RhbmNlb2YgQXJyYXkgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkobW9kZUNvbG9yKSA6IG1vZGVDb2xvcjtcbiAgICAgICAgICAgIHBhcnRpY2xlLmJ1YmJsZS5jb2xvciA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvSHNsKGJ1YmJsZUNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQnViYmxlciA9IEJ1YmJsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdG9yID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IE1vZGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jbGFzcyBDb25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGlmICghKGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBtb3VzZS5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoTW9kZXNfMS5Ib3Zlck1vZGUuY29ubmVjdCwgaG92ZXJNb2RlKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5zdGF0dXMgPT09IFwibW91c2Vtb3ZlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgICAgICBpZiAoIW1vdXNlUG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhjb250YWluZXIucmV0aW5hLmNvbm5lY3RNb2RlUmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeUNpcmNsZShtb3VzZVBvcywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwMSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvczEgPSBwMS5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcDIgb2YgcXVlcnkuc2xpY2UoaSArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvczIgPSBwMi5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0TWF4ID0gTWF0aC5hYnMoY29udGFpbmVyLnJldGluYS5jb25uZWN0TW9kZURpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeERpZmYgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MyLngpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5RGlmZiA9IE1hdGguYWJzKHBvczEueSAtIHBvczIueSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4RGlmZiA8IGRpc3RNYXggJiYgeURpZmYgPCBkaXN0TWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmRyYXdDb25uZWN0TGluZShwMSwgcDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdG9yID0gQ29ubmVjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyYWJiZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNsYXNzIEdyYWJiZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGlmICghKGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBtb3VzZS5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoTW9kZXNfMS5Ib3Zlck1vZGUuZ3JhYiwgaG92ZXJNb2RlKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHkgPSBvcHRpb25zLmludGVyYWN0aXZpdHk7XG4gICAgICAgIGlmIChpbnRlcmFjdGl2aXR5LmV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5zdGF0dXMgPT09IFV0aWxzXzEuQ29uc3RhbnRzLm1vdXNlTW92ZUV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvcyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKG1vdXNlUG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbnRhaW5lci5yZXRpbmEuZ3JhYk1vZGVEaXN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeUNpcmNsZShtb3VzZVBvcywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnREaXN0YW5jZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zLCBtb3VzZVBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50RGlzdGFuY2UgPD0gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JhYkxpbmVPcHRpb25zID0gaW50ZXJhY3Rpdml0eS5tb2Rlcy5ncmFiLmxpbmtzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lT3BhY2l0eSA9IGdyYWJMaW5lT3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGFjaXR5TGluZSA9IGxpbmVPcGFjaXR5IC0gKHBvaW50RGlzdGFuY2UgKiBsaW5lT3BhY2l0eSkgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wYWNpdHlMaW5lID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0Q29sb3IgPSAoX2EgPSBncmFiTGluZU9wdGlvbnMuY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBhcnRpY2xlLm9wdGlvbnMubGlua3MuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5wYXJ0aWNsZXMuZ3JhYkxpbmVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtzT3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuZ3JhYi5saW5rcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLmdyYWJMaW5lQ29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0TGlua1JhbmRvbUNvbG9yKG9wdENvbG9yLCBsaW5rc09wdGlvbnMuYmxpbmssIGxpbmtzT3B0aW9ucy5jb25zZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yTGluZSA9IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRMaW5rQ29sb3IocGFydGljbGUsIHVuZGVmaW5lZCwgY29udGFpbmVyLnBhcnRpY2xlcy5ncmFiTGluZUNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYW52YXMuZHJhd0dyYWJMaW5lKHBhcnRpY2xlLCBjb2xvckxpbmUsIG9wYWNpdHlMaW5lLCBtb3VzZVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdyYWJiZXIgPSBHcmFiYmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZ2h0ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNsYXNzIExpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uSG92ZXIuZW5hYmxlICYmIGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LnN0YXR1cyA9PT0gXCJtb3VzZW1vdmVcIikge1xuICAgICAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICghbW91c2VQb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmRyYXdMaWdodChtb3VzZVBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGlmICghKGV2ZW50cy5vbkhvdmVyLmVuYWJsZSAmJiBtb3VzZS5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3Zlck1vZGUgPSBldmVudHMub25Ib3Zlci5tb2RlO1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoTW9kZXNfMS5Ib3Zlck1vZGUubGlnaHQsIGhvdmVyTW9kZSk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbn1cbmV4cG9ydHMuTGlnaHRlciA9IExpZ2h0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVwdWxzZXIgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IFZlY3Rvcl8xID0gcmVxdWlyZShcIi4uLy4uL0NvcmUvUGFydGljbGUvVmVjdG9yXCIpO1xuY2xhc3MgUmVwdWxzZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBtb3VzZSA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlO1xuICAgICAgICBjb25zdCBldmVudHMgPSBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBjb25zdCBkaXZzID0gZXZlbnRzLm9uRGl2O1xuICAgICAgICBjb25zdCBkaXZSZXB1bHNlID0gVXRpbHNfMS5VdGlscy5pc0Rpdk1vZGVFbmFibGVkKEVudW1zXzEuRGl2TW9kZS5yZXB1bHNlLCBkaXZzKTtcbiAgICAgICAgaWYgKCEoZGl2UmVwdWxzZSB8fCAoZXZlbnRzLm9uSG92ZXIuZW5hYmxlICYmIG1vdXNlLnBvc2l0aW9uKSB8fCAoZXZlbnRzLm9uQ2xpY2suZW5hYmxlICYmIG1vdXNlLmNsaWNrUG9zaXRpb24pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyTW9kZSA9IGV2ZW50cy5vbkhvdmVyLm1vZGU7XG4gICAgICAgIGNvbnN0IGNsaWNrTW9kZSA9IGV2ZW50cy5vbkNsaWNrLm1vZGU7XG4gICAgICAgIHJldHVybiAoVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5Ib3Zlck1vZGUucmVwdWxzZSwgaG92ZXJNb2RlKSB8fCBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5yZXB1bHNlLCBjbGlja01vZGUpIHx8IGRpdlJlcHVsc2UpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vdXNlTW92ZVN0YXR1cyA9IGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LnN0YXR1cyA9PT0gVXRpbHNfMS5Db25zdGFudHMubW91c2VNb3ZlRXZlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHM7XG4gICAgICAgIGNvbnN0IGhvdmVyRW5hYmxlZCA9IGV2ZW50cy5vbkhvdmVyLmVuYWJsZTtcbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgY29uc3QgY2xpY2tFbmFibGVkID0gZXZlbnRzLm9uQ2xpY2suZW5hYmxlO1xuICAgICAgICBjb25zdCBjbGlja01vZGUgPSBldmVudHMub25DbGljay5tb2RlO1xuICAgICAgICBjb25zdCBkaXZzID0gZXZlbnRzLm9uRGl2O1xuICAgICAgICBpZiAobW91c2VNb3ZlU3RhdHVzICYmIGhvdmVyRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkhvdmVyTW9kZS5yZXB1bHNlLCBob3Zlck1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyUmVwdWxzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsaWNrRW5hYmxlZCAmJiBVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLkNsaWNrTW9kZS5yZXB1bHNlLCBjbGlja01vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrUmVwdWxzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5kaXZNb2RlRXhlY3V0ZShFbnVtc18xLkRpdk1vZGUucmVwdWxzZSwgZGl2cywgKHNlbGVjdG9yLCBkaXYpID0+IHRoaXMuc2luZ2xlU2VsZWN0b3JSZXB1bHNlKHNlbGVjdG9yLCBkaXYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaW5nbGVTZWxlY3RvclJlcHVsc2Uoc2VsZWN0b3IsIGRpdikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCFxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogKGVsZW0ub2Zmc2V0TGVmdCArIGVsZW0ub2Zmc2V0V2lkdGggLyAyKSAqIHB4UmF0aW8sXG4gICAgICAgICAgICAgICAgeTogKGVsZW0ub2Zmc2V0VG9wICsgZWxlbS5vZmZzZXRIZWlnaHQgLyAyKSAqIHB4UmF0aW8sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVwdWxzZVJhZGl1cyA9IChlbGVtLm9mZnNldFdpZHRoIC8gMikgKiBweFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGRpdi50eXBlID09PSBFbnVtc18xLkRpdlR5cGUuY2lyY2xlXG4gICAgICAgICAgICAgICAgPyBuZXcgVXRpbHNfMS5DaXJjbGUocG9zLngsIHBvcy55LCByZXB1bHNlUmFkaXVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFV0aWxzXzEuUmVjdGFuZ2xlKGVsZW0ub2Zmc2V0TGVmdCAqIHB4UmF0aW8sIGVsZW0ub2Zmc2V0VG9wICogcHhSYXRpbywgZWxlbS5vZmZzZXRXaWR0aCAqIHB4UmF0aW8sIGVsZW0ub2Zmc2V0SGVpZ2h0ICogcHhSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBkaXZzID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5yZXB1bHNlLmRpdnM7XG4gICAgICAgICAgICBjb25zdCBkaXZSZXB1bHNlID0gVXRpbHNfMS5VdGlscy5kaXZNb2RlKGRpdnMsIGVsZW0pO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUmVwdWxzZShwb3MsIHJlcHVsc2VSYWRpdXMsIGFyZWEsIGRpdlJlcHVsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaG92ZXJSZXB1bHNlKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbW91c2VQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKCFtb3VzZVBvcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcHVsc2VSYWRpdXMgPSBjb250YWluZXIucmV0aW5hLnJlcHVsc2VNb2RlRGlzdGFuY2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JlcHVsc2UobW91c2VQb3MsIHJlcHVsc2VSYWRpdXMsIG5ldyBVdGlsc18xLkNpcmNsZShtb3VzZVBvcy54LCBtb3VzZVBvcy55LCByZXB1bHNlUmFkaXVzKSk7XG4gICAgfVxuICAgIHByb2Nlc3NSZXB1bHNlKHBvc2l0aW9uLCByZXB1bHNlUmFkaXVzLCBhcmVhLCBkaXZSZXB1bHNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeShhcmVhKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNsZSBvZiBxdWVyeSkge1xuICAgICAgICAgICAgY29uc3QgeyBkeCwgZHksIGRpc3RhbmNlIH0gPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlcyhwYXJ0aWNsZS5wb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3Qgbm9ybVZlYyA9IHtcbiAgICAgICAgICAgICAgICB4OiBkeCAvIGRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIHk6IGR5IC8gZGlzdGFuY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdmVsb2NpdHkgPSAoKF9hID0gZGl2UmVwdWxzZSA9PT0gbnVsbCB8fCBkaXZSZXB1bHNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXZSZXB1bHNlLnNwZWVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250YWluZXIuYWN0dWFsT3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLnJlcHVsc2Uuc3BlZWQpICogMTAwO1xuICAgICAgICAgICAgY29uc3QgcmVwdWxzZUZhY3RvciA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuY2xhbXAoKDEgLSBNYXRoLnBvdyhkaXN0YW5jZSAvIHJlcHVsc2VSYWRpdXMsIDIpKSAqIHZlbG9jaXR5LCAwLCA1MCk7XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi54ICs9IG5vcm1WZWMueCAqIHJlcHVsc2VGYWN0b3I7XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ICs9IG5vcm1WZWMueSAqIHJlcHVsc2VGYWN0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xpY2tSZXB1bHNlKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFjb250YWluZXIucmVwdWxzZS5maW5pc2gpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLnJlcHVsc2UuY291bnQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5jb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5jb3VudCsrO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5yZXB1bHNlLmNvdW50ID09PSBjb250YWluZXIucGFydGljbGVzLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlcHVsc2UuZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLnJlcHVsc2UuY2xpY2tpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcHVsc2VEaXN0YW5jZSA9IGNvbnRhaW5lci5yZXRpbmEucmVwdWxzZU1vZGVEaXN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IHJlcHVsc2VSYWRpdXMgPSBNYXRoLnBvdyhyZXB1bHNlRGlzdGFuY2UgLyA2LCAzKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlQ2xpY2tQb3MgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKG1vdXNlQ2xpY2tQb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IFV0aWxzXzEuQ2lyY2xlKG1vdXNlQ2xpY2tQb3MueCwgbW91c2VDbGlja1Bvcy55LCByZXB1bHNlUmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeShyYW5nZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkeCwgZHksIGRpc3RhbmNlIH0gPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlcyhtb3VzZUNsaWNrUG9zLCBwYXJ0aWNsZS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlICogZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKGQgPD0gcmVwdWxzZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5wYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5yZXB1bHNlLnNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gVmVjdG9yXzEuVmVjdG9yLmNyZWF0ZShkeCwgZHkpO1xuICAgICAgICAgICAgICAgICAgICB2Lmxlbmd0aCA9ICgtcmVwdWxzZVJhZGl1cyAqIHZlbG9jaXR5KSAvIGQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnNldFRvKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXIucmVwdWxzZS5jbGlja2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgY29udGFpbmVyLnJlcHVsc2UucGFydGljbGVzKSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkuc2V0VG8ocGFydGljbGUuaW5pdGlhbFZlbG9jaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLnBhcnRpY2xlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXB1bHNlciA9IFJlcHVsc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWlsTWFrZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNsYXNzIFRyYWlsTWFrZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5kZWxheSA9IDA7XG4gICAgfVxuICAgIGludGVyYWN0KGRlbHRhKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHRyYWlsT3B0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy50cmFpbDtcbiAgICAgICAgY29uc3Qgb3B0RGVsYXkgPSAodHJhaWxPcHRpb25zLmRlbGF5ICogMTAwMCkgLyB0aGlzLmNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICBpZiAodGhpcy5kZWxheSA8IG9wdERlbGF5KSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ICs9IGRlbHRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ID49IG9wdERlbGF5KSB7XG4gICAgICAgICAgICBjb250YWluZXIucGFydGljbGVzLnB1c2godHJhaWxPcHRpb25zLnF1YW50aXR5LCBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZSwgdHJhaWxPcHRpb25zLnBhcnRpY2xlcyk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5IC09IG9wdERlbGF5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gb3B0aW9ucy5pbnRlcmFjdGl2aXR5LmV2ZW50cztcbiAgICAgICAgcmV0dXJuICgobW91c2UuY2xpY2tpbmcgJiZcbiAgICAgICAgICAgIG1vdXNlLmluc2lkZSAmJlxuICAgICAgICAgICAgISFtb3VzZS5wb3NpdGlvbiAmJlxuICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoTW9kZXNfMS5DbGlja01vZGUudHJhaWwsIGV2ZW50cy5vbkNsaWNrLm1vZGUpKSB8fFxuICAgICAgICAgICAgKG1vdXNlLmluc2lkZSAmJiAhIW1vdXNlLnBvc2l0aW9uICYmIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuSG92ZXJNb2RlLnRyYWlsLCBldmVudHMub25Ib3Zlci5tb2RlKSkpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG59XG5leHBvcnRzLlRyYWlsTWFrZXIgPSBUcmFpbE1ha2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJhY3RvciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBBdHRyYWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaW50ZXJhY3QocDEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAoX2EgPSBwMS5saW5rc0Rpc3RhbmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250YWluZXIucmV0aW5hLmxpbmtzRGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHBvczEgPSBwMS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGNvbnRhaW5lci5wYXJ0aWNsZXMucXVhZFRyZWUucXVlcnlDaXJjbGUocG9zMSwgZGlzdGFuY2UpO1xuICAgICAgICBmb3IgKGNvbnN0IHAyIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocDEgPT09IHAyIHx8ICFwMi5vcHRpb25zLm1vdmUuYXR0cmFjdC5lbmFibGUgfHwgcDIuZGVzdHJveWVkIHx8IHAyLnNwYXduaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3MyID0gcDIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZHgsIGR5IH0gPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlcyhwb3MxLCBwb3MyKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdGF0ZSA9IHAxLm9wdGlvbnMubW92ZS5hdHRyYWN0LnJvdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gZHggLyAocm90YXRlLnggKiAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gZHkgLyAocm90YXRlLnkgKiAxMDAwKTtcbiAgICAgICAgICAgIHAxLnZlbG9jaXR5LnggLT0gYXg7XG4gICAgICAgICAgICBwMS52ZWxvY2l0eS55IC09IGF5O1xuICAgICAgICAgICAgcDIudmVsb2NpdHkueCArPSBheDtcbiAgICAgICAgICAgIHAyLnZlbG9jaXR5LnkgKz0gYXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFbmFibGVkKHBhcnRpY2xlKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWNsZS5vcHRpb25zLm1vdmUuYXR0cmFjdC5lbmFibGU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbn1cbmV4cG9ydHMuQXR0cmFjdG9yID0gQXR0cmFjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbGxpZGVyID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5mdW5jdGlvbiBib3VuY2UocDEsIHAyKSB7XG4gICAgVXRpbHNfMS5VdGlscy5jaXJjbGVCb3VuY2UoVXRpbHNfMS5VdGlscy5jaXJjbGVCb3VuY2VEYXRhRnJvbVBhcnRpY2xlKHAxKSwgVXRpbHNfMS5VdGlscy5jaXJjbGVCb3VuY2VEYXRhRnJvbVBhcnRpY2xlKHAyKSk7XG59XG5mdW5jdGlvbiBkZXN0cm95KHAxLCBwMikge1xuICAgIGlmIChwMS5nZXRSYWRpdXMoKSA9PT0gdW5kZWZpbmVkICYmIHAyLmdldFJhZGl1cygpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcDEuZGVzdHJveSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwMS5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkICYmIHAyLmdldFJhZGl1cygpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcDIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwMS5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkICYmIHAyLmdldFJhZGl1cygpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHAxLmdldFJhZGl1cygpID49IHAyLmdldFJhZGl1cygpKSB7XG4gICAgICAgICAgICBwMi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwMS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDb2xsaWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICBpc0VuYWJsZWQocGFydGljbGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRpY2xlLm9wdGlvbnMuY29sbGlzaW9ucy5lbmFibGU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgIH1cbiAgICBpbnRlcmFjdChwMSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcG9zMSA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeUNpcmNsZShwb3MxLCBwMS5nZXRSYWRpdXMoKSAqIDIpO1xuICAgICAgICBmb3IgKGNvbnN0IHAyIG9mIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocDEgPT09IHAyIHx8XG4gICAgICAgICAgICAgICAgIXAyLm9wdGlvbnMuY29sbGlzaW9ucy5lbmFibGUgfHxcbiAgICAgICAgICAgICAgICBwMS5vcHRpb25zLmNvbGxpc2lvbnMubW9kZSAhPT0gcDIub3B0aW9ucy5jb2xsaXNpb25zLm1vZGUgfHxcbiAgICAgICAgICAgICAgICBwMi5kZXN0cm95ZWQgfHxcbiAgICAgICAgICAgICAgICBwMi5zcGF3bmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zMiA9IHAyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MxLCBwb3MyKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1czEgPSBwMS5nZXRSYWRpdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1czIgPSBwMi5nZXRSYWRpdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RQID0gcmFkaXVzMSArIHJhZGl1czI7XG4gICAgICAgICAgICBpZiAoZGlzdCA8PSBkaXN0UCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwMSwgcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVDb2xsaXNpb24ocDEsIHAyKSB7XG4gICAgICAgIHN3aXRjaCAocDEub3B0aW9ucy5jb2xsaXNpb25zLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Db2xsaXNpb25Nb2RlLmFic29yYjoge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJzb3JiKHAxLCBwMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuQ29sbGlzaW9uTW9kZS5ib3VuY2U6IHtcbiAgICAgICAgICAgICAgICBib3VuY2UocDEsIHAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5Db2xsaXNpb25Nb2RlLmRlc3Ryb3k6IHtcbiAgICAgICAgICAgICAgICBkZXN0cm95KHAxLCBwMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJzb3JiKHAxLCBwMikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZnBzID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuZnBzTGltaXQgLyAxMDAwO1xuICAgICAgICBpZiAocDEuZ2V0UmFkaXVzKCkgPT09IHVuZGVmaW5lZCAmJiBwMi5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwMS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocDEuZ2V0UmFkaXVzKCkgIT09IHVuZGVmaW5lZCAmJiBwMi5nZXRSYWRpdXMoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwMi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocDEuZ2V0UmFkaXVzKCkgIT09IHVuZGVmaW5lZCAmJiBwMi5nZXRSYWRpdXMoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocDEuZ2V0UmFkaXVzKCkgPj0gcDIuZ2V0UmFkaXVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3IgPSBVdGlsc18xLk51bWJlclV0aWxzLmNsYW1wKHAxLmdldFJhZGl1cygpIC8gcDIuZ2V0UmFkaXVzKCksIDAsIHAyLmdldFJhZGl1cygpKSAqIGZwcztcbiAgICAgICAgICAgICAgICBwMS5zaXplLnZhbHVlICs9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICBwMi5zaXplLnZhbHVlIC09IGZhY3RvcjtcbiAgICAgICAgICAgICAgICBpZiAocDIuZ2V0UmFkaXVzKCkgPD0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHAyLnNpemUudmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwMi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gVXRpbHNfMS5OdW1iZXJVdGlscy5jbGFtcChwMi5nZXRSYWRpdXMoKSAvIHAxLmdldFJhZGl1cygpLCAwLCBwMS5nZXRSYWRpdXMoKSkgKiBmcHM7XG4gICAgICAgICAgICAgICAgcDEuc2l6ZS52YWx1ZSAtPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgcDIuc2l6ZS52YWx1ZSArPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKHAxLmdldFJhZGl1cygpIDw9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgICAgICAgICBwMS5zaXplLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcDEuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29sbGlkZXIgPSBDb2xsaWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmZlY3RlciA9IHZvaWQgMDtcbmNsYXNzIEluZmVjdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmFjdHVhbE9wdGlvbnMuaW5mZWN0aW9uLmVuYWJsZTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KHAxLCBkZWx0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbmZlY3RlcjEgPSBwMS5pbmZlY3RlcjtcbiAgICAgICAgaW5mZWN0ZXIxLnVwZGF0ZUluZmVjdGlvbihkZWx0YS52YWx1ZSk7XG4gICAgICAgIGlmIChpbmZlY3RlcjEuaW5mZWN0aW9uU3RhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZmVjdGlvbk9wdGlvbnMgPSBvcHRpb25zLmluZmVjdGlvbjtcbiAgICAgICAgaWYgKCFpbmZlY3Rpb25PcHRpb25zLmVuYWJsZSB8fCBpbmZlY3Rpb25PcHRpb25zLnN0YWdlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mZWN0aW9uU3RhZ2UxID0gaW5mZWN0aW9uT3B0aW9ucy5zdGFnZXNbaW5mZWN0ZXIxLmluZmVjdGlvblN0YWdlXTtcbiAgICAgICAgY29uc3QgcHhSYXRpbyA9IGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgY29uc3QgcmFkaXVzID0gcDEuZ2V0UmFkaXVzKCkgKiAyICsgaW5mZWN0aW9uU3RhZ2UxLnJhZGl1cyAqIHB4UmF0aW87XG4gICAgICAgIGNvbnN0IHBvcyA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGluZmVjdGVkU3RhZ2UxID0gKF9hID0gaW5mZWN0aW9uU3RhZ2UxLmluZmVjdGVkU3RhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGluZmVjdGVyMS5pbmZlY3Rpb25TdGFnZTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb250YWluZXIucGFydGljbGVzLnF1YWRUcmVlLnF1ZXJ5Q2lyY2xlKHBvcywgcmFkaXVzKTtcbiAgICAgICAgY29uc3QgaW5mZWN0aW9ucyA9IGluZmVjdGlvblN0YWdlMS5yYXRlO1xuICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBxdWVyeS5sZW5ndGg7XG4gICAgICAgIGZvciAoY29uc3QgcDIgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChwMiA9PT0gcDEgfHxcbiAgICAgICAgICAgICAgICBwMi5kZXN0cm95ZWQgfHxcbiAgICAgICAgICAgICAgICBwMi5zcGF3bmluZyB8fFxuICAgICAgICAgICAgICAgICEocDIuaW5mZWN0ZXIuaW5mZWN0aW9uU3RhZ2UgPT09IHVuZGVmaW5lZCB8fCBwMi5pbmZlY3Rlci5pbmZlY3Rpb25TdGFnZSAhPT0gaW5mZWN0ZXIxLmluZmVjdGlvblN0YWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5mZWN0ZXIyID0gcDIuaW5mZWN0ZXI7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IGluZmVjdGlvbnMgLyBuZWlnaGJvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mZWN0ZXIyLmluZmVjdGlvblN0YWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mZWN0ZXIyLnN0YXJ0SW5mZWN0aW9uKGluZmVjdGVkU3RhZ2UxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5mZWN0ZXIyLmluZmVjdGlvblN0YWdlIDwgaW5mZWN0ZXIxLmluZmVjdGlvblN0YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZmVjdGVyMi51cGRhdGVJbmZlY3Rpb25TdGFnZShpbmZlY3RlZFN0YWdlMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZmVjdGVyMi5pbmZlY3Rpb25TdGFnZSA+IGluZmVjdGVyMS5pbmZlY3Rpb25TdGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZlY3Rpb25TdGFnZTIgPSBpbmZlY3Rpb25PcHRpb25zLnN0YWdlc1tpbmZlY3RlcjIuaW5mZWN0aW9uU3RhZ2VdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZlY3RlZFN0YWdlMiA9IChfYiA9IGluZmVjdGlvblN0YWdlMiA9PT0gbnVsbCB8fCBpbmZlY3Rpb25TdGFnZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZmVjdGlvblN0YWdlMi5pbmZlY3RlZFN0YWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbmZlY3RlcjIuaW5mZWN0aW9uU3RhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGluZmVjdGVyMS51cGRhdGVJbmZlY3Rpb25TdGFnZShpbmZlY3RlZFN0YWdlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbmZlY3RlciA9IEluZmVjdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZ2h0ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNsYXNzIExpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaW50ZXJhY3QocGFydGljbGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25Ib3Zlci5lbmFibGUgJiYgY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID09PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZVBvcyA9IHRoaXMuY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgICAgICBpZiAobW91c2VQb3MpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmRyYXdQYXJ0aWNsZVNoYWRvdyhwYXJ0aWNsZSwgbW91c2VQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzO1xuICAgICAgICBpZiAoIShldmVudHMub25Ib3Zlci5lbmFibGUgJiYgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJNb2RlID0gZXZlbnRzLm9uSG92ZXIubW9kZTtcbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KE1vZGVzXzEuSG92ZXJNb2RlLmxpZ2h0LCBob3Zlck1vZGUpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0ZXIgPSBMaWdodGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpbmtlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBMaW5rZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgaXNFbmFibGVkKHBhcnRpY2xlKSB7XG4gICAgICAgIHJldHVybiBwYXJ0aWNsZS5vcHRpb25zLmxpbmtzLmVuYWJsZTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KHAxKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGxpbmtPcHQxID0gcDEub3B0aW9ucy5saW5rcztcbiAgICAgICAgY29uc3Qgb3B0T3BhY2l0eSA9IGxpbmtPcHQxLm9wYWNpdHk7XG4gICAgICAgIGNvbnN0IG9wdERpc3RhbmNlID0gKF9hID0gcDEubGlua3NEaXN0YW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGFpbmVyLnJldGluYS5saW5rc0Rpc3RhbmNlO1xuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICBjb25zdCB3YXJwID0gbGlua09wdDEud2FycDtcbiAgICAgICAgY29uc3QgcG9zMSA9IHAxLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gd2FycFxuICAgICAgICAgICAgPyBuZXcgVXRpbHNfMS5DaXJjbGVXYXJwKHBvczEueCwgcG9zMS55LCBvcHREaXN0YW5jZSwgY2FudmFzU2l6ZSlcbiAgICAgICAgICAgIDogbmV3IFV0aWxzXzEuQ2lyY2xlKHBvczEueCwgcG9zMS55LCBvcHREaXN0YW5jZSk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY29udGFpbmVyLnBhcnRpY2xlcy5xdWFkVHJlZS5xdWVyeShyYW5nZSk7XG4gICAgICAgIGZvciAoY29uc3QgcDIgb2YgcXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtPcHQyID0gcDIub3B0aW9ucy5saW5rcztcbiAgICAgICAgICAgIGlmIChwMSA9PT0gcDIgfHwgIWxpbmtPcHQyLmVuYWJsZSB8fCBsaW5rT3B0MS5pZCAhPT0gbGlua09wdDIuaWQgfHwgcDIuc3Bhd25pbmcgfHwgcDIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3MyID0gcDIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UocG9zMSwgcG9zMik7XG4gICAgICAgICAgICBpZiAod2FycCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG9wdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvczJORSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvczIueCAtIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MyLnksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MxLCBwb3MyTkUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBvcHREaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zMlNFID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvczIueCAtIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcG9zMi55IC0gY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBvczEsIHBvczJTRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBvcHREaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvczJTVyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zMi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb3MyLnkgLSBjYW52YXNTaXplLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwb3MxLCBwb3MyU1cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gb3B0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5TGluZSA9ICgxIC0gZGlzdGFuY2UgLyBvcHREaXN0YW5jZSkgKiBvcHRPcGFjaXR5O1xuICAgICAgICAgICAgY29uc3QgbGlua3NPcHRpb25zID0gcDEub3B0aW9ucy5saW5rcztcbiAgICAgICAgICAgIGxldCBsaW5rQ29sb3IgPSBsaW5rc09wdGlvbnMuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9ycy5nZXQobGlua3NPcHRpb25zLmlkKVxuICAgICAgICAgICAgICAgIDogY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9yO1xuICAgICAgICAgICAgaWYgKCFsaW5rQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRDb2xvciA9IGxpbmtzT3B0aW9ucy5jb2xvcjtcbiAgICAgICAgICAgICAgICBsaW5rQ29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0TGlua1JhbmRvbUNvbG9yKG9wdENvbG9yLCBsaW5rc09wdGlvbnMuYmxpbmssIGxpbmtzT3B0aW9ucy5jb25zZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobGlua3NPcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9ycy5zZXQobGlua3NPcHRpb25zLmlkLCBsaW5rQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5saW5rc0NvbG9yID0gbGlua0NvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwMi5saW5rcy5tYXAoKHQpID0+IHQuZGVzdGluYXRpb24pLmluZGV4T2YocDEpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIHAxLmxpbmtzLm1hcCgodCkgPT4gdC5kZXN0aW5hdGlvbikuaW5kZXhPZihwMikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcDEubGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBwMixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eUxpbmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtlciA9IExpbmtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmltYXRpb25PcHRpb25zID0gdm9pZCAwO1xuY2xhc3MgQW5pbWF0aW9uT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNwZWVkID0gMTtcbiAgICAgICAgdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gZGF0YS5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQW5pbWF0aW9uT3B0aW9ucyA9IEFuaW1hdGlvbk9wdGlvbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFja2dyb3VuZCA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIEJhY2tncm91bmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvcigpO1xuICAgICAgICB0aGlzLmNvbG9yLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5pbWFnZSA9IFwiXCI7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBcIlwiO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGRhdGEuaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGRhdGEucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0ID0gZGF0YS5yZXBlYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhY2tncm91bmQgPSBCYWNrZ3JvdW5kO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhY2tncm91bmRNYXNrID0gdm9pZCAwO1xuY29uc3QgQmFja2dyb3VuZE1hc2tDb3Zlcl8xID0gcmVxdWlyZShcIi4vQmFja2dyb3VuZE1hc2tDb3ZlclwiKTtcbmNsYXNzIEJhY2tncm91bmRNYXNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb21wb3NpdGUgPSBcImRlc3RpbmF0aW9uLW91dFwiO1xuICAgICAgICB0aGlzLmNvdmVyID0gbmV3IEJhY2tncm91bmRNYXNrQ292ZXJfMS5CYWNrZ3JvdW5kTWFza0NvdmVyKCk7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29tcG9zaXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRlID0gZGF0YS5jb21wb3NpdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY292ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY292ZXIgPSBkYXRhLmNvdmVyO1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSAodHlwZW9mIGRhdGEuY292ZXIgPT09IFwic3RyaW5nXCIgPyB7IGNvbG9yOiBkYXRhLmNvdmVyIH0gOiBkYXRhLmNvdmVyKTtcbiAgICAgICAgICAgIHRoaXMuY292ZXIubG9hZChjb3Zlci5jb2xvciAhPT0gdW5kZWZpbmVkID8gY292ZXIgOiB7IGNvbG9yOiBjb2xvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFja2dyb3VuZE1hc2sgPSBCYWNrZ3JvdW5kTWFzaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrZ3JvdW5kTWFza0NvdmVyID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgQmFja2dyb3VuZE1hc2tDb3ZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhY2tncm91bmRNYXNrQ292ZXIgPSBCYWNrZ3JvdW5kTWFza0NvdmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbG9yQW5pbWF0aW9uID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNsYXNzIENvbG9yQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgICAgIHRoaXMuc3luYyA9IHRydWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGRhdGEuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKGRhdGEub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29sb3JBbmltYXRpb24gPSBDb2xvckFuaW1hdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GdWxsU2NyZWVuID0gdm9pZCAwO1xuY2xhc3MgRnVsbFNjcmVlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuekluZGV4ID0gLTE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS56SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy56SW5kZXggPSBkYXRhLnpJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRnVsbFNjcmVlbiA9IEZ1bGxTY3JlZW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgSW5mZWN0aW9uU3RhZ2VfMSA9IHJlcXVpcmUoXCIuL0luZmVjdGlvblN0YWdlXCIpO1xuY2xhc3MgSW5mZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jdXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZmVjdGlvbnMgPSAwO1xuICAgICAgICB0aGlzLnN0YWdlcyA9IFtdO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmN1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJlID0gZGF0YS5jdXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBkYXRhLmRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmluZmVjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbmZlY3Rpb25zID0gZGF0YS5pbmZlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN0YWdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFnZXMgPSBkYXRhLnN0YWdlcy5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBuZXcgSW5mZWN0aW9uU3RhZ2VfMS5JbmZlY3Rpb25TdGFnZSgpO1xuICAgICAgICAgICAgcy5sb2FkKHQpO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5mZWN0aW9uID0gSW5mZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluZmVjdGlvblN0YWdlID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgSW5mZWN0aW9uU3RhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvcigpO1xuICAgICAgICB0aGlzLmNvbG9yLnZhbHVlID0gXCIjZmYwMDAwXCI7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMDtcbiAgICAgICAgdGhpcy5yYXRlID0gMTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5pbmZlY3RlZFN0YWdlID0gZGF0YS5pbmZlY3RlZFN0YWdlO1xuICAgICAgICBpZiAoZGF0YS5yYWRpdXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBkYXRhLnJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5yYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmF0ZSA9IGRhdGEucmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW5mZWN0aW9uU3RhZ2UgPSBJbmZlY3Rpb25TdGFnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGlja0V2ZW50ID0gdm9pZCAwO1xuY2xhc3MgQ2xpY2tFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW9kZSA9IFtdO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gZGF0YS5tb2RlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DbGlja0V2ZW50ID0gQ2xpY2tFdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXZFdmVudCA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vRW51bXNcIik7XG5jbGFzcyBEaXZFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gW107XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW9kZSA9IFtdO1xuICAgICAgICB0aGlzLnR5cGUgPSBFbnVtc18xLkRpdlR5cGUuY2lyY2xlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHM7XG4gICAgfVxuICAgIHNldCBlbGVtZW50SWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pZHMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50SWQ7XG4gICAgfVxuICAgIHNldCBlbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RvcnMgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgPyB0aGlzLnNlbGVjdG9ycy5tYXAoKHQpID0+IHQucmVwbGFjZShcIiNcIiwgXCJcIikpXG4gICAgICAgICAgICA6IHRoaXMuc2VsZWN0b3JzLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICAgIH1cbiAgICBzZXQgaWRzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gdmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHZhbHVlLm1hcCgodCkgPT4gYCMke3R9YCkgOiBgIyR7dmFsdWV9YDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHMgPSAoX2IgPSAoX2EgPSBkYXRhLmlkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5lbGVtZW50SWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGEuZWw7XG4gICAgICAgIGlmIChpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZHMgPSBpZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2VsZWN0b3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gZGF0YS5zZWxlY3RvcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRpdkV2ZW50ID0gRGl2RXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXZlbnRzID0gdm9pZCAwO1xuY29uc3QgQ2xpY2tFdmVudF8xID0gcmVxdWlyZShcIi4vQ2xpY2tFdmVudFwiKTtcbmNvbnN0IERpdkV2ZW50XzEgPSByZXF1aXJlKFwiLi9EaXZFdmVudFwiKTtcbmNvbnN0IEhvdmVyRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0hvdmVyRXZlbnRcIik7XG5jbGFzcyBFdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSBuZXcgQ2xpY2tFdmVudF8xLkNsaWNrRXZlbnQoKTtcbiAgICAgICAgdGhpcy5vbkRpdiA9IG5ldyBEaXZFdmVudF8xLkRpdkV2ZW50KCk7XG4gICAgICAgIHRoaXMub25Ib3ZlciA9IG5ldyBIb3ZlckV2ZW50XzEuSG92ZXJFdmVudCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZSA9IHRydWU7XG4gICAgfVxuICAgIGdldCBvbmNsaWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkNsaWNrO1xuICAgIH1cbiAgICBzZXQgb25jbGljayh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG9uZGl2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkRpdjtcbiAgICB9XG4gICAgc2V0IG9uZGl2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMub25EaXYgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG9uaG92ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uSG92ZXI7XG4gICAgfVxuICAgIHNldCBvbmhvdmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub25Ib3ZlciA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2xpY2subG9hZCgoX2EgPSBkYXRhLm9uQ2xpY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEub25jbGljayk7XG4gICAgICAgIGNvbnN0IG9uRGl2ID0gKF9iID0gZGF0YS5vbkRpdikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YS5vbmRpdjtcbiAgICAgICAgaWYgKG9uRGl2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChvbkRpdiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpdiA9IG9uRGl2Lm1hcCgoZGl2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBEaXZFdmVudF8xLkRpdkV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKGRpdik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGl2ID0gbmV3IERpdkV2ZW50XzEuRGl2RXZlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGl2LmxvYWQob25EaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Ib3Zlci5sb2FkKChfYyA9IGRhdGEub25Ib3ZlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGF0YS5vbmhvdmVyKTtcbiAgICAgICAgaWYgKGRhdGEucmVzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplID0gZGF0YS5yZXNpemU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkV2ZW50cyA9IEV2ZW50cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ib3ZlckV2ZW50ID0gdm9pZCAwO1xuY29uc3QgUGFyYWxsYXhfMSA9IHJlcXVpcmUoXCIuL1BhcmFsbGF4XCIpO1xuY2xhc3MgSG92ZXJFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW9kZSA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFsbGF4ID0gbmV3IFBhcmFsbGF4XzEuUGFyYWxsYXgoKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGRhdGEubW9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmFsbGF4LmxvYWQoZGF0YS5wYXJhbGxheCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ib3ZlckV2ZW50ID0gSG92ZXJFdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJhbGxheCA9IHZvaWQgMDtcbmNsYXNzIFBhcmFsbGF4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JjZSA9IDI7XG4gICAgICAgIHRoaXMuc21vb3RoID0gMTA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZm9yY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mb3JjZSA9IGRhdGEuZm9yY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc21vb3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc21vb3RoID0gZGF0YS5zbW9vdGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhcmFsbGF4ID0gUGFyYWxsYXg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJhY3Rpdml0eSA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRW51bXNcIik7XG5jb25zdCBFdmVudHNfMSA9IHJlcXVpcmUoXCIuL0V2ZW50cy9FdmVudHNcIik7XG5jb25zdCBNb2Rlc18xID0gcmVxdWlyZShcIi4vTW9kZXMvTW9kZXNcIik7XG5jbGFzcyBJbnRlcmFjdGl2aXR5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZXRlY3RzT24gPSBFbnVtc18xLkludGVyYWN0aXZpdHlEZXRlY3QuY2FudmFzO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudHNfMS5FdmVudHMoKTtcbiAgICAgICAgdGhpcy5tb2RlcyA9IG5ldyBNb2Rlc18xLk1vZGVzKCk7XG4gICAgfVxuICAgIGdldCBkZXRlY3Rfb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdHNPbjtcbiAgICB9XG4gICAgc2V0IGRldGVjdF9vbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmRldGVjdHNPbiA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXRlY3RzT24gPSAoX2EgPSBkYXRhLmRldGVjdHNPbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5kZXRlY3Rfb247XG4gICAgICAgIGlmIChkZXRlY3RzT24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RzT24gPSBkZXRlY3RzT247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMubG9hZChkYXRhLmV2ZW50cyk7XG4gICAgICAgIHRoaXMubW9kZXMubG9hZChkYXRhLm1vZGVzKTtcbiAgICAgICAgaWYgKCgoX2MgPSAoX2IgPSBkYXRhLm1vZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xvdykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjdGl2ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbkhvdmVyLm1vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5vbkhvdmVyLm1vZGUuaW5kZXhPZihFbnVtc18xLkhvdmVyTW9kZS5zbG93KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25Ib3Zlci5tb2RlLnB1c2goRW51bXNfMS5Ib3Zlck1vZGUuc2xvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5ldmVudHMub25Ib3Zlci5tb2RlICE9PSBFbnVtc18xLkhvdmVyTW9kZS5zbG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub25Ib3Zlci5tb2RlID0gW3RoaXMuZXZlbnRzLm9uSG92ZXIubW9kZSwgRW51bXNfMS5Ib3Zlck1vZGUuc2xvd107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkludGVyYWN0aXZpdHkgPSBJbnRlcmFjdGl2aXR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJhY3QgPSB2b2lkIDA7XG5jbGFzcyBBdHRyYWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDIwMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDAuNDtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc3BlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGRhdGEuc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF0dHJhY3QgPSBBdHRyYWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvdW5jZSA9IHZvaWQgMDtcbmNsYXNzIEJvdW5jZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAyMDA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGF0YS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQm91bmNlID0gQm91bmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1YmJsZSA9IHZvaWQgMDtcbmNvbnN0IEJ1YmJsZURpdl8xID0gcmVxdWlyZShcIi4vQnViYmxlRGl2XCIpO1xuY29uc3QgQnViYmxlQmFzZV8xID0gcmVxdWlyZShcIi4vQnViYmxlQmFzZVwiKTtcbmNsYXNzIEJ1YmJsZSBleHRlbmRzIEJ1YmJsZUJhc2VfMS5CdWJibGVCYXNlIHtcbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKCEoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZGl2cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpdnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5kaXZzID0gZGF0YS5kaXZzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBCdWJibGVEaXZfMS5CdWJibGVEaXYoKTtcbiAgICAgICAgICAgICAgICB0bXAubG9hZChzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXZzIGluc3RhbmNlb2YgQXJyYXkgfHwgIXRoaXMuZGl2cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2cyA9IG5ldyBCdWJibGVEaXZfMS5CdWJibGVEaXYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGl2cy5sb2FkKGRhdGEuZGl2cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ1YmJsZSA9IEJ1YmJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWJibGVCYXNlID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgQnViYmxlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAyMDA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjQ7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEuY29sb3IgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yLm1hcCgocykgPT4gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh1bmRlZmluZWQsIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ1YmJsZUJhc2UgPSBCdWJibGVCYXNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1YmJsZURpdiA9IHZvaWQgMDtcbmNvbnN0IEJ1YmJsZUJhc2VfMSA9IHJlcXVpcmUoXCIuL0J1YmJsZUJhc2VcIik7XG5jbGFzcyBCdWJibGVEaXYgZXh0ZW5kcyBCdWJibGVCYXNlXzEuQnViYmxlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gW107XG4gICAgfVxuICAgIGdldCBpZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycyBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/IHRoaXMuc2VsZWN0b3JzLm1hcCgodCkgPT4gdC5yZXBsYWNlKFwiI1wiLCBcIlwiKSlcbiAgICAgICAgICAgIDogdGhpcy5zZWxlY3RvcnMucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gICAgfVxuICAgIHNldCBpZHModmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUubWFwKCh0KSA9PiBgIyR7dH1gKSA6IGAjJHt2YWx1ZX1gO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmlkcyA9IGRhdGEuaWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNlbGVjdG9ycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IGRhdGEuc2VsZWN0b3JzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CdWJibGVEaXYgPSBCdWJibGVEaXY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdCA9IHZvaWQgMDtcbmNvbnN0IENvbm5lY3RMaW5rc18xID0gcmVxdWlyZShcIi4vQ29ubmVjdExpbmtzXCIpO1xuY2xhc3MgQ29ubmVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSA4MDtcbiAgICAgICAgdGhpcy5saW5rcyA9IG5ldyBDb25uZWN0TGlua3NfMS5Db25uZWN0TGlua3MoKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSA2MDtcbiAgICB9XG4gICAgZ2V0IGxpbmVfbGlua2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5rcztcbiAgICB9XG4gICAgc2V0IGxpbmVfbGlua2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlua3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxpbmVMaW5rZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xuICAgIH1cbiAgICBzZXQgbGluZUxpbmtlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmxpbmtzID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rcy5sb2FkKChfYiA9IChfYSA9IGRhdGEubGlua3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEubGluZUxpbmtlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YS5saW5lX2xpbmtlZCk7XG4gICAgICAgIGlmIChkYXRhLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0ID0gQ29ubmVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0TGlua3MgPSB2b2lkIDA7XG5jbGFzcyBDb25uZWN0TGlua3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAwLjU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdExpbmtzID0gQ29ubmVjdExpbmtzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyYWIgPSB2b2lkIDA7XG5jb25zdCBHcmFiTGlua3NfMSA9IHJlcXVpcmUoXCIuL0dyYWJMaW5rc1wiKTtcbmNsYXNzIEdyYWIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMTAwO1xuICAgICAgICB0aGlzLmxpbmtzID0gbmV3IEdyYWJMaW5rc18xLkdyYWJMaW5rcygpO1xuICAgIH1cbiAgICBnZXQgbGluZV9saW5rZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xuICAgIH1cbiAgICBzZXQgbGluZV9saW5rZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5saW5rcyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGluZUxpbmtlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlua3M7XG4gICAgfVxuICAgIHNldCBsaW5lTGlua2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlua3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGF0YS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtzLmxvYWQoKF9iID0gKF9hID0gZGF0YS5saW5rcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5saW5lTGlua2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkYXRhLmxpbmVfbGlua2VkKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYWIgPSBHcmFiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyYWJMaW5rcyA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIEdyYWJMaW5rcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmxpbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYmxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ibGluayA9IGRhdGEuYmxpbms7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29uc2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlbnQgPSBkYXRhLmNvbnNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdyYWJMaW5rcyA9IEdyYWJMaW5rcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodCA9IHZvaWQgMDtcbmNvbnN0IExpZ2h0QXJlYV8xID0gcmVxdWlyZShcIi4vTGlnaHRBcmVhXCIpO1xuY29uc3QgTGlnaHRTaGFkb3dfMSA9IHJlcXVpcmUoXCIuL0xpZ2h0U2hhZG93XCIpO1xuY2xhc3MgTGlnaHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFyZWEgPSBuZXcgTGlnaHRBcmVhXzEuTGlnaHRBcmVhKCk7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbmV3IExpZ2h0U2hhZG93XzEuTGlnaHRTaGFkb3coKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFyZWEubG9hZChkYXRhLmFyZWEpO1xuICAgICAgICB0aGlzLnNoYWRvdy5sb2FkKGRhdGEuc2hhZG93KTtcbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0ID0gTGlnaHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlnaHRBcmVhID0gdm9pZCAwO1xuY29uc3QgTGlnaHRHcmFkaWVudF8xID0gcmVxdWlyZShcIi4vTGlnaHRHcmFkaWVudFwiKTtcbmNsYXNzIExpZ2h0QXJlYSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBuZXcgTGlnaHRHcmFkaWVudF8xLkxpZ2h0R3JhZGllbnQoKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAxMDAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhZGllbnQubG9hZChkYXRhLmdyYWRpZW50KTtcbiAgICAgICAgaWYgKGRhdGEucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZGF0YS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpZ2h0QXJlYSA9IExpZ2h0QXJlYTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodEdyYWRpZW50ID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgTGlnaHRHcmFkaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuc3RvcCA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5zdGFydC52YWx1ZSA9IFwiI2ZmZmZmZlwiO1xuICAgICAgICB0aGlzLnN0b3AudmFsdWUgPSBcIiMwMDAwMDBcIjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLnN0YXJ0LCBkYXRhLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5zdG9wID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLnN0b3AsIGRhdGEuc3RvcCk7XG4gICAgfVxufVxuZXhwb3J0cy5MaWdodEdyYWRpZW50ID0gTGlnaHRHcmFkaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaWdodFNoYWRvdyA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIExpZ2h0U2hhZG93IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5jb2xvci52YWx1ZSA9IFwiIzAwMDAwMFwiO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDIwMDA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaWdodFNoYWRvdyA9IExpZ2h0U2hhZG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGVzID0gdm9pZCAwO1xuY29uc3QgQnViYmxlXzEgPSByZXF1aXJlKFwiLi9CdWJibGVcIik7XG5jb25zdCBDb25uZWN0XzEgPSByZXF1aXJlKFwiLi9Db25uZWN0XCIpO1xuY29uc3QgR3JhYl8xID0gcmVxdWlyZShcIi4vR3JhYlwiKTtcbmNvbnN0IFJlbW92ZV8xID0gcmVxdWlyZShcIi4vUmVtb3ZlXCIpO1xuY29uc3QgUHVzaF8xID0gcmVxdWlyZShcIi4vUHVzaFwiKTtcbmNvbnN0IFJlcHVsc2VfMSA9IHJlcXVpcmUoXCIuL1JlcHVsc2VcIik7XG5jb25zdCBTbG93XzEgPSByZXF1aXJlKFwiLi9TbG93XCIpO1xuY29uc3QgVHJhaWxfMSA9IHJlcXVpcmUoXCIuL1RyYWlsXCIpO1xuY29uc3QgQXR0cmFjdF8xID0gcmVxdWlyZShcIi4vQXR0cmFjdFwiKTtcbmNvbnN0IExpZ2h0XzEgPSByZXF1aXJlKFwiLi9MaWdodFwiKTtcbmNvbnN0IEJvdW5jZV8xID0gcmVxdWlyZShcIi4vQm91bmNlXCIpO1xuY2xhc3MgTW9kZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmF0dHJhY3QgPSBuZXcgQXR0cmFjdF8xLkF0dHJhY3QoKTtcbiAgICAgICAgdGhpcy5ib3VuY2UgPSBuZXcgQm91bmNlXzEuQm91bmNlKCk7XG4gICAgICAgIHRoaXMuYnViYmxlID0gbmV3IEJ1YmJsZV8xLkJ1YmJsZSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBuZXcgQ29ubmVjdF8xLkNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5ncmFiID0gbmV3IEdyYWJfMS5HcmFiKCk7XG4gICAgICAgIHRoaXMubGlnaHQgPSBuZXcgTGlnaHRfMS5MaWdodCgpO1xuICAgICAgICB0aGlzLnB1c2ggPSBuZXcgUHVzaF8xLlB1c2goKTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSBuZXcgUmVtb3ZlXzEuUmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucmVwdWxzZSA9IG5ldyBSZXB1bHNlXzEuUmVwdWxzZSgpO1xuICAgICAgICB0aGlzLnNsb3cgPSBuZXcgU2xvd18xLlNsb3coKTtcbiAgICAgICAgdGhpcy50cmFpbCA9IG5ldyBUcmFpbF8xLlRyYWlsKCk7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyYWN0LmxvYWQoZGF0YS5hdHRyYWN0KTtcbiAgICAgICAgdGhpcy5idWJibGUubG9hZChkYXRhLmJ1YmJsZSk7XG4gICAgICAgIHRoaXMuY29ubmVjdC5sb2FkKGRhdGEuY29ubmVjdCk7XG4gICAgICAgIHRoaXMuZ3JhYi5sb2FkKGRhdGEuZ3JhYik7XG4gICAgICAgIHRoaXMubGlnaHQubG9hZChkYXRhLmxpZ2h0KTtcbiAgICAgICAgdGhpcy5wdXNoLmxvYWQoZGF0YS5wdXNoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUubG9hZChkYXRhLnJlbW92ZSk7XG4gICAgICAgIHRoaXMucmVwdWxzZS5sb2FkKGRhdGEucmVwdWxzZSk7XG4gICAgICAgIHRoaXMuc2xvdy5sb2FkKGRhdGEuc2xvdyk7XG4gICAgICAgIHRoaXMudHJhaWwubG9hZChkYXRhLnRyYWlsKTtcbiAgICB9XG59XG5leHBvcnRzLk1vZGVzID0gTW9kZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVzaCA9IHZvaWQgMDtcbmNsYXNzIFB1c2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnF1YW50aXR5ID0gNDtcbiAgICB9XG4gICAgZ2V0IHBhcnRpY2xlc19uYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhbnRpdHk7XG4gICAgfVxuICAgIHNldCBwYXJ0aWNsZXNfbmIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVhbnRpdHkgPSAoX2EgPSBkYXRhLnF1YW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLnBhcnRpY2xlc19uYjtcbiAgICAgICAgaWYgKHF1YW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpdHkgPSBxdWFudGl0eTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHVzaCA9IFB1c2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3ZlID0gdm9pZCAwO1xuY2xhc3MgUmVtb3ZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IDI7XG4gICAgfVxuICAgIGdldCBwYXJ0aWNsZXNfbmIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YW50aXR5O1xuICAgIH1cbiAgICBzZXQgcGFydGljbGVzX25iKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1YW50aXR5ID0gKF9hID0gZGF0YS5xdWFudGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5wYXJ0aWNsZXNfbmI7XG4gICAgICAgIGlmIChxdWFudGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnF1YW50aXR5ID0gcXVhbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlbW92ZSA9IFJlbW92ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXB1bHNlID0gdm9pZCAwO1xuY29uc3QgUmVwdWxzZURpdl8xID0gcmVxdWlyZShcIi4vUmVwdWxzZURpdlwiKTtcbmNvbnN0IFJlcHVsc2VCYXNlXzEgPSByZXF1aXJlKFwiLi9SZXB1bHNlQmFzZVwiKTtcbmNsYXNzIFJlcHVsc2UgZXh0ZW5kcyBSZXB1bHNlQmFzZV8xLlJlcHVsc2VCYXNlIHtcbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuZGl2cykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpdnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5kaXZzID0gZGF0YS5kaXZzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBSZXB1bHNlRGl2XzEuUmVwdWxzZURpdigpO1xuICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdnMgaW5zdGFuY2VvZiBBcnJheSB8fCAhdGhpcy5kaXZzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXZzID0gbmV3IFJlcHVsc2VEaXZfMS5SZXB1bHNlRGl2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpdnMubG9hZChkYXRhLmRpdnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXB1bHNlID0gUmVwdWxzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXB1bHNlQmFzZSA9IHZvaWQgMDtcbmNsYXNzIFJlcHVsc2VCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDIwMDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDAuNDtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc3BlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGRhdGEuc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlcHVsc2VCYXNlID0gUmVwdWxzZUJhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVwdWxzZURpdiA9IHZvaWQgMDtcbmNvbnN0IFJlcHVsc2VCYXNlXzEgPSByZXF1aXJlKFwiLi9SZXB1bHNlQmFzZVwiKTtcbmNsYXNzIFJlcHVsc2VEaXYgZXh0ZW5kcyBSZXB1bHNlQmFzZV8xLlJlcHVsc2VCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGlkcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycy5tYXAoKHQpID0+IHQucmVwbGFjZShcIiNcIiwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JzLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBpZHModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gdmFsdWUubWFwKCgpID0+IGAjJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gYCMke3ZhbHVlfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5pZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZHMgPSBkYXRhLmlkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zZWxlY3RvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBkYXRhLnNlbGVjdG9ycztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVwdWxzZURpdiA9IFJlcHVsc2VEaXY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2xvdyA9IHZvaWQgMDtcbmNsYXNzIFNsb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZhY3RvciA9IDM7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMjAwO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCBhY3RpdmUoX3ZhbHVlKSB7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZmFjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yID0gZGF0YS5mYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZGF0YS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNsb3cgPSBTbG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWlsID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNsYXNzIFRyYWlsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IDE7XG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSAxO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBkYXRhLmRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnF1YW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpdHkgPSBkYXRhLnF1YW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnBhcnRpY2xlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgZGF0YS5wYXJ0aWNsZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmFpbCA9IFRyYWlsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hbnVhbFBhcnRpY2xlID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNsYXNzIE1hbnVhbFBhcnRpY2xlIHtcbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiAoX2EgPSBkYXRhLnBvc2l0aW9uLngpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDUwLFxuICAgICAgICAgICAgICAgIHk6IChfYiA9IGRhdGEucG9zaXRpb24ueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogNTAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NYW51YWxQYXJ0aWNsZSA9IE1hbnVhbFBhcnRpY2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdGlvbiA9IHZvaWQgMDtcbmNvbnN0IE1vdGlvblJlZHVjZV8xID0gcmVxdWlyZShcIi4vTW90aW9uUmVkdWNlXCIpO1xuY2xhc3MgTW90aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVkdWNlID0gbmV3IE1vdGlvblJlZHVjZV8xLk1vdGlvblJlZHVjZSgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlzYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUgPSBkYXRhLmRpc2FibGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWR1Y2UubG9hZChkYXRhLnJlZHVjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb3Rpb24gPSBNb3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW90aW9uUmVkdWNlID0gdm9pZCAwO1xuY2xhc3MgTW90aW9uUmVkdWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mYWN0b3IgPSA0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmZhY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvciA9IGRhdGEuZmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb3Rpb25SZWR1Y2UgPSBNb3Rpb25SZWR1Y2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEludGVyYWN0aXZpdHlfMSA9IHJlcXVpcmUoXCIuL0ludGVyYWN0aXZpdHkvSW50ZXJhY3Rpdml0eVwiKTtcbmNvbnN0IFBhcnRpY2xlc09wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlcy9QYXJ0aWNsZXNPcHRpb25zXCIpO1xuY29uc3QgQmFja2dyb3VuZE1hc2tfMSA9IHJlcXVpcmUoXCIuL0JhY2tncm91bmRNYXNrL0JhY2tncm91bmRNYXNrXCIpO1xuY29uc3QgQmFja2dyb3VuZF8xID0gcmVxdWlyZShcIi4vQmFja2dyb3VuZC9CYWNrZ3JvdW5kXCIpO1xuY29uc3QgSW5mZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9JbmZlY3Rpb24vSW5mZWN0aW9uXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IFRoZW1lXzEgPSByZXF1aXJlKFwiLi9UaGVtZS9UaGVtZVwiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBGdWxsU2NyZWVuXzEgPSByZXF1aXJlKFwiLi9GdWxsU2NyZWVuL0Z1bGxTY3JlZW5cIik7XG5jb25zdCBNb3Rpb25fMSA9IHJlcXVpcmUoXCIuL01vdGlvbi9Nb3Rpb25cIik7XG5jb25zdCBNYW51YWxQYXJ0aWNsZV8xID0gcmVxdWlyZShcIi4vTWFudWFsUGFydGljbGVcIik7XG5jb25zdCBSZXNwb25zaXZlXzEgPSByZXF1aXJlKFwiLi9SZXNwb25zaXZlXCIpO1xuY2xhc3MgT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYXV0b1BsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZF8xLkJhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IG5ldyBCYWNrZ3JvdW5kTWFza18xLkJhY2tncm91bmRNYXNrKCk7XG4gICAgICAgIHRoaXMuZnVsbFNjcmVlbiA9IG5ldyBGdWxsU2NyZWVuXzEuRnVsbFNjcmVlbigpO1xuICAgICAgICB0aGlzLmRldGVjdFJldGluYSA9IHRydWU7XG4gICAgICAgIHRoaXMuZnBzTGltaXQgPSA2MDtcbiAgICAgICAgdGhpcy5pbmZlY3Rpb24gPSBuZXcgSW5mZWN0aW9uXzEuSW5mZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpdml0eSA9IG5ldyBJbnRlcmFjdGl2aXR5XzEuSW50ZXJhY3Rpdml0eSgpO1xuICAgICAgICB0aGlzLm1hbnVhbFBhcnRpY2xlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vdGlvbiA9IG5ldyBNb3Rpb25fMS5Nb3Rpb24oKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBuZXcgUGFydGljbGVzT3B0aW9uc18xLlBhcnRpY2xlc09wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5wYXVzZU9uQmx1ciA9IHRydWU7XG4gICAgICAgIHRoaXMucGF1c2VPbk91dHNpZGVWaWV3cG9ydCA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZSA9IFtdO1xuICAgICAgICB0aGlzLnRoZW1lcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgZnBzX2xpbWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcHNMaW1pdDtcbiAgICB9XG4gICAgc2V0IGZwc19saW1pdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZwc0xpbWl0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCByZXRpbmFfZGV0ZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RSZXRpbmE7XG4gICAgfVxuICAgIHNldCByZXRpbmFfZGV0ZWN0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGV0ZWN0UmV0aW5hID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBiYWNrZ3JvdW5kTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFNjcmVlbjtcbiAgICB9XG4gICAgc2V0IGJhY2tncm91bmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnVsbFNjcmVlbi5sb2FkKHZhbHVlKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucHJlc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnByZXNldCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmVzZXQgb2YgZGF0YS5wcmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRQcmVzZXQocHJlc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFByZXNldChkYXRhLnByZXNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYXV0b1BsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvUGxheSA9IGRhdGEuYXV0b1BsYXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV0ZWN0UmV0aW5hID0gKF9hID0gZGF0YS5kZXRlY3RSZXRpbmEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEucmV0aW5hX2RldGVjdDtcbiAgICAgICAgaWYgKGRldGVjdFJldGluYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRldGVjdFJldGluYSA9IGRldGVjdFJldGluYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcHNMaW1pdCA9IChfYiA9IGRhdGEuZnBzTGltaXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGEuZnBzX2xpbWl0O1xuICAgICAgICBpZiAoZnBzTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mcHNMaW1pdCA9IGZwc0xpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnBhdXNlT25CbHVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2VPbkJsdXIgPSBkYXRhLnBhdXNlT25CbHVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnBhdXNlT25PdXRzaWRlVmlld3BvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZU9uT3V0c2lkZVZpZXdwb3J0ID0gZGF0YS5wYXVzZU9uT3V0c2lkZVZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5sb2FkKGRhdGEuYmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuZnVsbFNjcmVlbi5sb2FkKChfYyA9IGRhdGEuZnVsbFNjcmVlbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGF0YS5iYWNrZ3JvdW5kTW9kZSk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2subG9hZChkYXRhLmJhY2tncm91bmRNYXNrKTtcbiAgICAgICAgdGhpcy5pbmZlY3Rpb24ubG9hZChkYXRhLmluZmVjdGlvbik7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpdml0eS5sb2FkKGRhdGEuaW50ZXJhY3Rpdml0eSk7XG4gICAgICAgIGlmIChkYXRhLm1hbnVhbFBhcnRpY2xlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1hbnVhbFBhcnRpY2xlcyA9IGRhdGEubWFudWFsUGFydGljbGVzLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBNYW51YWxQYXJ0aWNsZV8xLk1hbnVhbFBhcnRpY2xlKCk7XG4gICAgICAgICAgICAgICAgdG1wLmxvYWQodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW90aW9uLmxvYWQoZGF0YS5tb3Rpb24pO1xuICAgICAgICB0aGlzLnBhcnRpY2xlcy5sb2FkKGRhdGEucGFydGljbGVzKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmxvYWRPcHRpb25zKHRoaXMsIGRhdGEpO1xuICAgICAgICBpZiAoZGF0YS5yZXNwb25zaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzcG9uc2l2ZSBvZiBkYXRhLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRSZXNwb25zaXZlID0gbmV3IFJlc3BvbnNpdmVfMS5SZXNwb25zaXZlKCk7XG4gICAgICAgICAgICAgICAgb3B0UmVzcG9uc2l2ZS5sb2FkKHJlc3BvbnNpdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2l2ZS5wdXNoKG9wdFJlc3BvbnNpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZS5zb3J0KChhLCBiKSA9PiBhLm1heFdpZHRoIC0gYi5tYXhXaWR0aCk7XG4gICAgICAgIGlmIChkYXRhLnRoZW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRoZW1lIG9mIGRhdGEudGhlbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0VGhlbWUgPSBuZXcgVGhlbWVfMS5UaGVtZSgpO1xuICAgICAgICAgICAgICAgIG9wdFRoZW1lLmxvYWQodGhlbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudGhlbWVzLnB1c2gob3B0VGhlbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFRoZW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNob3NlblRoZW1lID0gdGhpcy50aGVtZXMuZmluZCgodGhlbWUpID0+IHRoZW1lLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNob3NlblRoZW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkKGNob3NlblRoZW1lLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50RGFya01vZGUgPSB0eXBlb2YgbWF0Y2hNZWRpYSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzO1xuICAgICAgICAgICAgbGV0IGRlZmF1bHRUaGVtZSA9IHRoaXMudGhlbWVzLmZpbmQoKHRoZW1lKSA9PiB0aGVtZS5kZWZhdWx0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgKCh0aGVtZS5kZWZhdWx0Lm1vZGUgPT09IEVudW1zXzEuVGhlbWVNb2RlLmRhcmsgJiYgY2xpZW50RGFya01vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGVtZS5kZWZhdWx0Lm1vZGUgPT09IEVudW1zXzEuVGhlbWVNb2RlLmxpZ2h0ICYmICFjbGllbnREYXJrTW9kZSkpKTtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFRoZW1lKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFRoZW1lID0gdGhpcy50aGVtZXMuZmluZCgodGhlbWUpID0+IHRoZW1lLmRlZmF1bHQudmFsdWUgJiYgdGhlbWUuZGVmYXVsdC5tb2RlID09PSBFbnVtc18xLlRoZW1lTW9kZS5hbnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmF1bHRUaGVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChkZWZhdWx0VGhlbWUub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW1wb3J0UHJlc2V0KHByZXNldCkge1xuICAgICAgICB0aGlzLmxvYWQoVXRpbHNfMS5QbHVnaW5zLmdldFByZXNldChwcmVzZXQpKTtcbiAgICB9XG4gICAgc2V0UmVzcG9uc2l2ZSh3aWR0aCwgcHhSYXRpbywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxvYWQoZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvYWQoKF9hID0gdGhpcy5yZXNwb25zaXZlLmZpbmQoKHQpID0+IHQubWF4V2lkdGggKiBweFJhdGlvID4gd2lkdGgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcHRpb25zQ29sb3IgPSB2b2lkIDA7XG5jbGFzcyBPcHRpb25zQ29sb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCIjZmZmXCI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoc291cmNlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gc291cmNlICE9PSBudWxsICYmIHNvdXJjZSAhPT0gdm9pZCAwID8gc291cmNlIDogbmV3IE9wdGlvbnNDb2xvcigpO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2xvci5sb2FkKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8geyB2YWx1ZTogZGF0YSB9IDogZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudmFsdWUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLk9wdGlvbnNDb2xvciA9IE9wdGlvbnNDb2xvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmltYXRhYmxlQ29sb3IgPSB2b2lkIDA7XG5jb25zdCBPcHRpb25zQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi9PcHRpb25zQ29sb3JcIik7XG5jb25zdCBIc2xBbmltYXRpb25fMSA9IHJlcXVpcmUoXCIuL0hzbEFuaW1hdGlvblwiKTtcbmNsYXNzIEFuaW1hdGFibGVDb2xvciBleHRlbmRzIE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEhzbEFuaW1hdGlvbl8xLkhzbEFuaW1hdGlvbigpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHNvdXJjZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjb2xvciA9IHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UgIT09IHZvaWQgMCA/IHNvdXJjZSA6IG5ldyBBbmltYXRhYmxlQ29sb3IoKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29sb3IubG9hZCh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHsgdmFsdWU6IGRhdGEgfSA6IGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbG9yQW5pbWF0aW9uID0gZGF0YS5hbmltYXRpb247XG4gICAgICAgIGlmIChjb2xvckFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JBbmltYXRpb24uZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5oLmxvYWQoY29sb3JBbmltYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24ubG9hZChkYXRhLmFuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFuaW1hdGFibGVDb2xvciA9IEFuaW1hdGFibGVDb2xvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Cb3VuY2UgPSB2b2lkIDA7XG5jb25zdCBCb3VuY2VGYWN0b3JfMSA9IHJlcXVpcmUoXCIuL0JvdW5jZUZhY3RvclwiKTtcbmNsYXNzIEJvdW5jZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IG5ldyBCb3VuY2VGYWN0b3JfMS5Cb3VuY2VGYWN0b3IoKTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IG5ldyBCb3VuY2VGYWN0b3JfMS5Cb3VuY2VGYWN0b3IoKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbC5sb2FkKGRhdGEuaG9yaXpvbnRhbCk7XG4gICAgICAgIHRoaXMudmVydGljYWwubG9hZChkYXRhLnZlcnRpY2FsKTtcbiAgICB9XG59XG5leHBvcnRzLkJvdW5jZSA9IEJvdW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Cb3VuY2VGYWN0b3IgPSB2b2lkIDA7XG5jb25zdCBWYWx1ZVdpdGhSYW5kb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9WYWx1ZVdpdGhSYW5kb21cIik7XG5jbGFzcyBCb3VuY2VGYWN0b3IgZXh0ZW5kcyBWYWx1ZVdpdGhSYW5kb21fMS5WYWx1ZVdpdGhSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJhbmRvbS5taW5pbXVtVmFsdWUgPSAwLjE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQm91bmNlRmFjdG9yID0gQm91bmNlRmFjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbGxpc2lvbnMgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgQm91bmNlXzEgPSByZXF1aXJlKFwiLi4vQm91bmNlL0JvdW5jZVwiKTtcbmNvbnN0IENvbGxpc2lvbnNPdmVybGFwXzEgPSByZXF1aXJlKFwiLi9Db2xsaXNpb25zT3ZlcmxhcFwiKTtcbmNsYXNzIENvbGxpc2lvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJvdW5jZSA9IG5ldyBCb3VuY2VfMS5Cb3VuY2UoKTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2RlID0gRW51bXNfMS5Db2xsaXNpb25Nb2RlLmJvdW5jZTtcbiAgICAgICAgdGhpcy5vdmVybGFwID0gbmV3IENvbGxpc2lvbnNPdmVybGFwXzEuQ29sbGlzaW9uc092ZXJsYXAoKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5jZS5sb2FkKGRhdGEuYm91bmNlKTtcbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGFwLmxvYWQoZGF0YS5vdmVybGFwKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbGxpc2lvbnMgPSBDb2xsaXNpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbGxpc2lvbnNPdmVybGFwID0gdm9pZCAwO1xuY2xhc3MgQ29sbGlzaW9uc092ZXJsYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IDA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5yZXRyaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cmllcyA9IGRhdGEucmV0cmllcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29sbGlzaW9uc092ZXJsYXAgPSBDb2xsaXNpb25zT3ZlcmxhcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZXN0cm95ID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9FbnVtc1wiKTtcbmNvbnN0IFNwbGl0XzEgPSByZXF1aXJlKFwiLi9TcGxpdFwiKTtcbmNsYXNzIERlc3Ryb3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBFbnVtc18xLkRlc3Ryb3lNb2RlLm5vbmU7XG4gICAgICAgIHRoaXMuc3BsaXQgPSBuZXcgU3BsaXRfMS5TcGxpdCgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGxpdC5sb2FkKGRhdGEuc3BsaXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVzdHJveSA9IERlc3Ryb3k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3BsaXQgPSB2b2lkIDA7XG5jb25zdCBTcGxpdEZhY3Rvcl8xID0gcmVxdWlyZShcIi4vU3BsaXRGYWN0b3JcIik7XG5jb25zdCBTcGxpdFJhdGVfMSA9IHJlcXVpcmUoXCIuL1NwbGl0UmF0ZVwiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBTcGxpdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICB0aGlzLmZhY3RvciA9IG5ldyBTcGxpdEZhY3Rvcl8xLlNwbGl0RmFjdG9yKCk7XG4gICAgICAgIHRoaXMucmF0ZSA9IG5ldyBTcGxpdFJhdGVfMS5TcGxpdFJhdGUoKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBkYXRhLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFjdG9yLmxvYWQoZGF0YS5mYWN0b3IpO1xuICAgICAgICB0aGlzLnJhdGUubG9hZChkYXRhLnJhdGUpO1xuICAgICAgICBpZiAoZGF0YS5wYXJ0aWNsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIGRhdGEucGFydGljbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3BsaXQgPSBTcGxpdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TcGxpdEZhY3RvciA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIFNwbGl0RmFjdG9yIGV4dGVuZHMgVmFsdWVXaXRoUmFuZG9tXzEuVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IDM7XG4gICAgfVxufVxuZXhwb3J0cy5TcGxpdEZhY3RvciA9IFNwbGl0RmFjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNwbGl0UmF0ZSA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIFNwbGl0UmF0ZSBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB7IG1pbjogNCwgbWF4OiA5IH07XG4gICAgfVxufVxuZXhwb3J0cy5TcGxpdFJhdGUgPSBTcGxpdFJhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHNsQW5pbWF0aW9uID0gdm9pZCAwO1xuY29uc3QgQ29sb3JBbmltYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9Db2xvckFuaW1hdGlvblwiKTtcbmNsYXNzIEhzbEFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaCA9IG5ldyBDb2xvckFuaW1hdGlvbl8xLkNvbG9yQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMucyA9IG5ldyBDb2xvckFuaW1hdGlvbl8xLkNvbG9yQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMubCA9IG5ldyBDb2xvckFuaW1hdGlvbl8xLkNvbG9yQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmgubG9hZChkYXRhLmgpO1xuICAgICAgICB0aGlzLnMubG9hZChkYXRhLnMpO1xuICAgICAgICB0aGlzLmwubG9hZChkYXRhLmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuSHNsQW5pbWF0aW9uID0gSHNsQW5pbWF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZmUgPSB2b2lkIDA7XG5jb25zdCBMaWZlRGVsYXlfMSA9IHJlcXVpcmUoXCIuL0xpZmVEZWxheVwiKTtcbmNvbnN0IExpZmVEdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vTGlmZUR1cmF0aW9uXCIpO1xuY2xhc3MgTGlmZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmRlbGF5ID0gbmV3IExpZmVEZWxheV8xLkxpZmVEZWxheSgpO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IExpZmVEdXJhdGlvbl8xLkxpZmVEdXJhdGlvbigpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBkYXRhLmNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkubG9hZChkYXRhLmRlbGF5KTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbi5sb2FkKGRhdGEuZHVyYXRpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlmZSA9IExpZmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlmZURlbGF5ID0gdm9pZCAwO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vVmFsdWVXaXRoUmFuZG9tXCIpO1xuY2xhc3MgTGlmZURlbGF5IGV4dGVuZHMgVmFsdWVXaXRoUmFuZG9tXzEuVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGlmZURlbGF5ID0gTGlmZURlbGF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpZmVEdXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIExpZmVEdXJhdGlvbiBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmFuZG9tLm1pbmltdW1WYWx1ZSA9IDAuMDAwMTtcbiAgICAgICAgdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEuc3luYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmMgPSBkYXRhLnN5bmM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpZmVEdXJhdGlvbiA9IExpZmVEdXJhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaW5rcyA9IHZvaWQgMDtcbmNvbnN0IExpbmtzU2hhZG93XzEgPSByZXF1aXJlKFwiLi9MaW5rc1NoYWRvd1wiKTtcbmNvbnN0IExpbmtzVHJpYW5nbGVfMSA9IHJlcXVpcmUoXCIuL0xpbmtzVHJpYW5nbGVcIik7XG5jb25zdCBPcHRpb25zQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBMaW5rcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmxpbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5jb25zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAxMDA7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gMTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBuZXcgTGlua3NTaGFkb3dfMS5MaW5rc1NoYWRvdygpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlcyA9IG5ldyBMaW5rc1RyaWFuZ2xlXzEuTGlua3NUcmlhbmdsZSgpO1xuICAgICAgICB0aGlzLndpZHRoID0gMTtcbiAgICAgICAgdGhpcy53YXJwID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYmxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ibGluayA9IGRhdGEuYmxpbms7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIGlmIChkYXRhLmNvbnNlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb25zZW50ID0gZGF0YS5jb25zZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkYXRhLmRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmZyZXF1ZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IGRhdGEuZnJlcXVlbmN5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhZG93LmxvYWQoZGF0YS5zaGFkb3cpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlcy5sb2FkKGRhdGEudHJpYW5nbGVzKTtcbiAgICAgICAgaWYgKGRhdGEud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEud2FycCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLndhcnAgPSBkYXRhLndhcnA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtzID0gTGlua3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlua3NTaGFkb3cgPSB2b2lkIDA7XG5jb25zdCBPcHRpb25zQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBMaW5rc1NoYWRvdyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmx1ciA9IDU7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sb3IudmFsdWUgPSBcIiMwMGZmMDBcIjtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5ibHVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmx1ciA9IGRhdGEuYmx1cjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtzU2hhZG93ID0gTGlua3NTaGFkb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlua3NUcmlhbmdsZSA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIExpbmtzVHJpYW5nbGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZnJlcXVlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gZGF0YS5mcmVxdWVuY3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpbmtzVHJpYW5nbGUgPSBMaW5rc1RyaWFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJhY3QgPSB2b2lkIDA7XG5jbGFzcyBBdHRyYWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3RhdGUgPSB7XG4gICAgICAgICAgICB4OiAzMDAwLFxuICAgICAgICAgICAgeTogMzAwMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHJvdGF0ZVgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZS54O1xuICAgIH1cbiAgICBzZXQgcm90YXRlWCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJvdGF0ZS54ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCByb3RhdGVZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGUueTtcbiAgICB9XG4gICAgc2V0IHJvdGF0ZVkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yb3RhdGUueSA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm90YXRlWCA9IChfYiA9IChfYSA9IGRhdGEucm90YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YS5yb3RhdGVYO1xuICAgICAgICBpZiAocm90YXRlWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZS54ID0gcm90YXRlWDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3RhdGVZID0gKF9kID0gKF9jID0gZGF0YS5yb3RhdGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy55KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkYXRhLnJvdGF0ZVk7XG4gICAgICAgIGlmIChyb3RhdGVZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRlLnkgPSByb3RhdGVZO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BdHRyYWN0ID0gQXR0cmFjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nb3ZlID0gdm9pZCAwO1xuY29uc3QgQXR0cmFjdF8xID0gcmVxdWlyZShcIi4vQXR0cmFjdFwiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vRW51bXNcIik7XG5jb25zdCBUcmFpbF8xID0gcmVxdWlyZShcIi4vVHJhaWxcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoL1BhdGhcIik7XG5jb25zdCBNb3ZlQW5nbGVfMSA9IHJlcXVpcmUoXCIuL01vdmVBbmdsZVwiKTtcbmNvbnN0IE1vdmVHcmF2aXR5XzEgPSByZXF1aXJlKFwiLi9Nb3ZlR3Jhdml0eVwiKTtcbmNvbnN0IE91dE1vZGVzXzEgPSByZXF1aXJlKFwiLi9PdXRNb2Rlc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBNb3ZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG5ldyBNb3ZlQW5nbGVfMS5Nb3ZlQW5nbGUoKTtcbiAgICAgICAgdGhpcy5hdHRyYWN0ID0gbmV3IEF0dHJhY3RfMS5BdHRyYWN0KCk7XG4gICAgICAgIHRoaXMuZGVjYXkgPSAwO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBFbnVtc18xLk1vdmVEaXJlY3Rpb24ubm9uZTtcbiAgICAgICAgdGhpcy5kcmlmdCA9IDA7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ3Jhdml0eSA9IG5ldyBNb3ZlR3Jhdml0eV8xLk1vdmVHcmF2aXR5KCk7XG4gICAgICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoXzEuUGF0aCgpO1xuICAgICAgICB0aGlzLm91dE1vZGVzID0gbmV3IE91dE1vZGVzXzEuT3V0TW9kZXMoKTtcbiAgICAgICAgdGhpcy5yYW5kb20gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3BlZWQgPSAyO1xuICAgICAgICB0aGlzLnN0cmFpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWwgPSBuZXcgVHJhaWxfMS5UcmFpbCgpO1xuICAgICAgICB0aGlzLnZpYnJhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YXJwID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjb2xsaXNpb25zKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldCBjb2xsaXNpb25zKHZhbHVlKSB7XG4gICAgfVxuICAgIGdldCBib3VuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbnM7XG4gICAgfVxuICAgIHNldCBib3VuY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25zID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvdXRfbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0TW9kZTtcbiAgICB9XG4gICAgc2V0IG91dF9tb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3V0TW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb3V0TW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0TW9kZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgc2V0IG91dE1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vdXRNb2Rlcy5kZWZhdWx0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBub2lzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9XG4gICAgc2V0IG5vaXNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuYW5nbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlLnZhbHVlID0gZGF0YS5hbmdsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUubG9hZChkYXRhLmFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJhY3QubG9hZChkYXRhLmF0dHJhY3QpO1xuICAgICAgICBpZiAoZGF0YS5kZWNheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2F5ID0gZGF0YS5kZWNheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkYXRhLmRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGF0YS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kcmlmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyaWZ0ID0gVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKGRhdGEuZHJpZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3Jhdml0eS5sb2FkKGRhdGEuZ3Jhdml0eSk7XG4gICAgICAgIGNvbnN0IG91dE1vZGUgPSAoX2EgPSBkYXRhLm91dE1vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEub3V0X21vZGU7XG4gICAgICAgIGlmIChkYXRhLm91dE1vZGVzICE9PSB1bmRlZmluZWQgfHwgb3V0TW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEub3V0TW9kZXMgPT09IFwic3RyaW5nXCIgfHwgKGRhdGEub3V0TW9kZXMgPT09IHVuZGVmaW5lZCAmJiBvdXRNb2RlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRNb2Rlcy5sb2FkKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogKF9iID0gZGF0YS5vdXRNb2RlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogb3V0TW9kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0TW9kZXMubG9hZChkYXRhLm91dE1vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGgubG9hZCgoX2MgPSBkYXRhLnBhdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRhdGEubm9pc2UpO1xuICAgICAgICBpZiAoZGF0YS5yYW5kb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yYW5kb20gPSBkYXRhLnJhbmRvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKGRhdGEuc3BlZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN0cmFpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyYWlnaHQgPSBkYXRhLnN0cmFpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhaWwubG9hZChkYXRhLnRyYWlsKTtcbiAgICAgICAgaWYgKGRhdGEudmlicmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpYnJhdGUgPSBkYXRhLnZpYnJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEud2FycCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLndhcnAgPSBkYXRhLndhcnA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk1vdmUgPSBNb3ZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdmVBbmdsZSA9IHZvaWQgMDtcbmNsYXNzIE1vdmVBbmdsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gNDU7XG4gICAgICAgIHRoaXMudmFsdWUgPSA5MDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBkYXRhLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTW92ZUFuZ2xlID0gTW92ZUFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vdmVHcmF2aXR5ID0gdm9pZCAwO1xuY2xhc3MgTW92ZUdyYXZpdHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IDkuODE7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4U3BlZWQgPSA1MDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmFjY2VsZXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGRhdGEuYWNjZWxlcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1heFNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U3BlZWQgPSBkYXRhLm1heFNwZWVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb3ZlR3Jhdml0eSA9IE1vdmVHcmF2aXR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk91dE1vZGVzID0gdm9pZCAwO1xuY29uc3QgTW9kZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9FbnVtcy9Nb2Rlc1wiKTtcbmNsYXNzIE91dE1vZGVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gTW9kZXNfMS5PdXRNb2RlLm91dDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHQgPSBkYXRhLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3R0b20gPSAoX2EgPSBkYXRhLmJvdHRvbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5kZWZhdWx0O1xuICAgICAgICB0aGlzLmxlZnQgPSAoX2IgPSBkYXRhLmxlZnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IChfYyA9IGRhdGEucmlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRhdGEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy50b3AgPSAoX2QgPSBkYXRhLnRvcCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGF0YS5kZWZhdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0TW9kZXMgPSBPdXRNb2RlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoID0gdm9pZCAwO1xuY29uc3QgUGF0aERlbGF5XzEgPSByZXF1aXJlKFwiLi9QYXRoRGVsYXlcIik7XG5jbGFzcyBQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jbGFtcCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBuZXcgUGF0aERlbGF5XzEuUGF0aERlbGF5KCk7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY2xhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jbGFtcCA9IGRhdGEuY2xhbXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxheS5sb2FkKGRhdGEuZGVsYXkpO1xuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGRhdGEuZ2VuZXJhdG9yO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aCA9IFBhdGg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF0aERlbGF5ID0gdm9pZCAwO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVmFsdWVXaXRoUmFuZG9tXCIpO1xuY2xhc3MgUGF0aERlbGF5IGV4dGVuZHMgVmFsdWVXaXRoUmFuZG9tXzEuVmFsdWVXaXRoUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhEZWxheSA9IFBhdGhEZWxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFpbCA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIFRyYWlsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuZmlsbENvbG9yLnZhbHVlID0gXCIjMDAwMDAwXCI7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuZmlsbENvbG9yLCBkYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmFpbCA9IFRyYWlsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlbnNpdHkgPSB2b2lkIDA7XG5jbGFzcyBEZW5zaXR5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcmVhID0gODAwO1xuICAgICAgICB0aGlzLmZhY3RvciA9IDEwMDA7XG4gICAgfVxuICAgIGdldCB2YWx1ZV9hcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xuICAgIH1cbiAgICBzZXQgdmFsdWVfYXJlYSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFyZWEgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZWEgPSAoX2EgPSBkYXRhLmFyZWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGEudmFsdWVfYXJlYTtcbiAgICAgICAgaWYgKGFyZWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5mYWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3IgPSBkYXRhLmZhY3RvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVuc2l0eSA9IERlbnNpdHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGljbGVzTnVtYmVyID0gdm9pZCAwO1xuY29uc3QgRGVuc2l0eV8xID0gcmVxdWlyZShcIi4vRGVuc2l0eVwiKTtcbmNsYXNzIFBhcnRpY2xlc051bWJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGVuc2l0eSA9IG5ldyBEZW5zaXR5XzEuRGVuc2l0eSgpO1xuICAgICAgICB0aGlzLmxpbWl0ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IDEwMDtcbiAgICB9XG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQ7XG4gICAgfVxuICAgIHNldCBtYXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5saW1pdCA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZW5zaXR5LmxvYWQoZGF0YS5kZW5zaXR5KTtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoX2EgPSBkYXRhLmxpbWl0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLm1heDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGltaXQgPSBsaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUGFydGljbGVzTnVtYmVyID0gUGFydGljbGVzTnVtYmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9wYWNpdHkgPSB2b2lkIDA7XG5jb25zdCBPcGFjaXR5QW5pbWF0aW9uXzEgPSByZXF1aXJlKFwiLi9PcGFjaXR5QW5pbWF0aW9uXCIpO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vVmFsdWVXaXRoUmFuZG9tXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNsYXNzIE9wYWNpdHkgZXh0ZW5kcyBWYWx1ZVdpdGhSYW5kb21fMS5WYWx1ZVdpdGhSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBPcGFjaXR5QW5pbWF0aW9uXzEuT3BhY2l0eUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnJhbmRvbS5taW5pbXVtVmFsdWUgPSAwLjE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAxO1xuICAgIH1cbiAgICBnZXQgYW5pbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICBzZXQgYW5pbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSAoX2EgPSBkYXRhLmFuaW1hdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5hbmltO1xuICAgICAgICBpZiAoYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmxvYWQoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUodGhpcy52YWx1ZSwgdGhpcy5hbmltYXRpb24uZW5hYmxlID8gdGhpcy5hbmltYXRpb24ubWluaW11bVZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT3BhY2l0eSA9IE9wYWNpdHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3BhY2l0eUFuaW1hdGlvbiA9IHZvaWQgMDtcbmNvbnN0IFR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vRW51bXMvVHlwZXNcIik7XG5jb25zdCBBbmltYXRpb25PcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vQW5pbWF0aW9uT3B0aW9uc1wiKTtcbmNsYXNzIE9wYWNpdHlBbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb25PcHRpb25zXzEuQW5pbWF0aW9uT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IFR5cGVzXzEuRGVzdHJveVR5cGUubm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taW5pbXVtVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLnNwZWVkID0gMjtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gVHlwZXNfMS5TdGFydFZhbHVlVHlwZS5yYW5kb207XG4gICAgICAgIHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgb3BhY2l0eV9taW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1WYWx1ZTtcbiAgICB9XG4gICAgc2V0IG9wYWNpdHlfbWluKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWluaW11bVZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBpZiAoZGF0YS5kZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGRhdGEuZGVzdHJveTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5pbXVtVmFsdWUgPSAoX2EgPSBkYXRhLm1pbmltdW1WYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5vcGFjaXR5X21pbjtcbiAgICAgICAgaWYgKG1pbmltdW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1pbmltdW1WYWx1ZSA9IG1pbmltdW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zdGFydFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IGRhdGEuc3RhcnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT3BhY2l0eUFuaW1hdGlvbiA9IE9wYWNpdHlBbmltYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGljbGVzT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IExpbmtzXzEgPSByZXF1aXJlKFwiLi9MaW5rcy9MaW5rc1wiKTtcbmNvbnN0IE1vdmVfMSA9IHJlcXVpcmUoXCIuL01vdmUvTW92ZVwiKTtcbmNvbnN0IFBhcnRpY2xlc051bWJlcl8xID0gcmVxdWlyZShcIi4vTnVtYmVyL1BhcnRpY2xlc051bWJlclwiKTtcbmNvbnN0IE9wYWNpdHlfMSA9IHJlcXVpcmUoXCIuL09wYWNpdHkvT3BhY2l0eVwiKTtcbmNvbnN0IFNoYXBlXzEgPSByZXF1aXJlKFwiLi9TaGFwZS9TaGFwZVwiKTtcbmNvbnN0IFNpemVfMSA9IHJlcXVpcmUoXCIuL1NpemUvU2l6ZVwiKTtcbmNvbnN0IFJvdGF0ZV8xID0gcmVxdWlyZShcIi4vUm90YXRlL1JvdGF0ZVwiKTtcbmNvbnN0IFNoYWRvd18xID0gcmVxdWlyZShcIi4vU2hhZG93XCIpO1xuY29uc3QgU3Ryb2tlXzEgPSByZXF1aXJlKFwiLi9TdHJva2VcIik7XG5jb25zdCBDb2xsaXNpb25zXzEgPSByZXF1aXJlKFwiLi9Db2xsaXNpb25zL0NvbGxpc2lvbnNcIik7XG5jb25zdCBUd2lua2xlXzEgPSByZXF1aXJlKFwiLi9Ud2lua2xlL1R3aW5rbGVcIik7XG5jb25zdCBBbmltYXRhYmxlQ29sb3JfMSA9IHJlcXVpcmUoXCIuL0FuaW1hdGFibGVDb2xvclwiKTtcbmNvbnN0IExpZmVfMSA9IHJlcXVpcmUoXCIuL0xpZmUvTGlmZVwiKTtcbmNvbnN0IEJvdW5jZV8xID0gcmVxdWlyZShcIi4vQm91bmNlL0JvdW5jZVwiKTtcbmNvbnN0IERlc3Ryb3lfMSA9IHJlcXVpcmUoXCIuL0Rlc3Ryb3kvRGVzdHJveVwiKTtcbmNsYXNzIFBhcnRpY2xlc09wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJvdW5jZSA9IG5ldyBCb3VuY2VfMS5Cb3VuY2UoKTtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25zID0gbmV3IENvbGxpc2lvbnNfMS5Db2xsaXNpb25zKCk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgQW5pbWF0YWJsZUNvbG9yXzEuQW5pbWF0YWJsZUNvbG9yKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IG5ldyBEZXN0cm95XzEuRGVzdHJveSgpO1xuICAgICAgICB0aGlzLmxpZmUgPSBuZXcgTGlmZV8xLkxpZmUoKTtcbiAgICAgICAgdGhpcy5saW5rcyA9IG5ldyBMaW5rc18xLkxpbmtzKCk7XG4gICAgICAgIHRoaXMubW92ZSA9IG5ldyBNb3ZlXzEuTW92ZSgpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG5ldyBQYXJ0aWNsZXNOdW1iZXJfMS5QYXJ0aWNsZXNOdW1iZXIoKTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gbmV3IE9wYWNpdHlfMS5PcGFjaXR5KCk7XG4gICAgICAgIHRoaXMucmVkdWNlRHVwbGljYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdGF0ZSA9IG5ldyBSb3RhdGVfMS5Sb3RhdGUoKTtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBuZXcgU2hhZG93XzEuU2hhZG93KCk7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgU2hhcGVfMS5TaGFwZSgpO1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgU2l6ZV8xLlNpemUoKTtcbiAgICAgICAgdGhpcy5zdHJva2UgPSBuZXcgU3Ryb2tlXzEuU3Ryb2tlKCk7XG4gICAgICAgIHRoaXMudHdpbmtsZSA9IG5ldyBUd2lua2xlXzEuVHdpbmtsZSgpO1xuICAgIH1cbiAgICBnZXQgbGluZV9saW5rZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xuICAgIH1cbiAgICBzZXQgbGluZV9saW5rZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5saW5rcyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGluZUxpbmtlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlua3M7XG4gICAgfVxuICAgIHNldCBsaW5lTGlua2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlua3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmNlLmxvYWQoZGF0YS5ib3VuY2UpO1xuICAgICAgICB0aGlzLmNvbG9yID0gQW5pbWF0YWJsZUNvbG9yXzEuQW5pbWF0YWJsZUNvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgdGhpcy5kZXN0cm95LmxvYWQoZGF0YS5kZXN0cm95KTtcbiAgICAgICAgdGhpcy5saWZlLmxvYWQoZGF0YS5saWZlKTtcbiAgICAgICAgY29uc3QgbGlua3MgPSAoX2IgPSAoX2EgPSBkYXRhLmxpbmtzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLmxpbmVMaW5rZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGEubGluZV9saW5rZWQ7XG4gICAgICAgIGlmIChsaW5rcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzLmxvYWQobGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZS5sb2FkKGRhdGEubW92ZSk7XG4gICAgICAgIHRoaXMubnVtYmVyLmxvYWQoZGF0YS5udW1iZXIpO1xuICAgICAgICB0aGlzLm9wYWNpdHkubG9hZChkYXRhLm9wYWNpdHkpO1xuICAgICAgICBpZiAoZGF0YS5yZWR1Y2VEdXBsaWNhdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlRHVwbGljYXRlcyA9IGRhdGEucmVkdWNlRHVwbGljYXRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvdGF0ZS5sb2FkKGRhdGEucm90YXRlKTtcbiAgICAgICAgdGhpcy5zaGFwZS5sb2FkKGRhdGEuc2hhcGUpO1xuICAgICAgICB0aGlzLnNpemUubG9hZChkYXRhLnNpemUpO1xuICAgICAgICB0aGlzLnNoYWRvdy5sb2FkKGRhdGEuc2hhZG93KTtcbiAgICAgICAgdGhpcy50d2lua2xlLmxvYWQoZGF0YS50d2lua2xlKTtcbiAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9IChfZCA9IChfYyA9IGRhdGEubW92ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNvbGxpc2lvbnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChfZSA9IGRhdGEubW92ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJvdW5jZTtcbiAgICAgICAgaWYgKGNvbGxpc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25zLmVuYWJsZSA9IGNvbGxpc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsaXNpb25zLmxvYWQoZGF0YS5jb2xsaXNpb25zKTtcbiAgICAgICAgY29uc3Qgc3Ryb2tlVG9Mb2FkID0gKF9mID0gZGF0YS5zdHJva2UpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IChfZyA9IGRhdGEuc2hhcGUpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5zdHJva2U7XG4gICAgICAgIGlmIChzdHJva2VUb0xvYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2VUb0xvYWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBzdHJva2VUb0xvYWQubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFN0cm9rZV8xLlN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cm9rZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSBuZXcgU3Ryb2tlXzEuU3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cm9rZS5sb2FkKHN0cm9rZVRvTG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhcnRpY2xlc09wdGlvbnMgPSBQYXJ0aWNsZXNPcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJvdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IFJvdGF0ZUFuaW1hdGlvbl8xID0gcmVxdWlyZShcIi4vUm90YXRlQW5pbWF0aW9uXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9FbnVtc1wiKTtcbmNvbnN0IFZhbHVlV2l0aFJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIFJvdGF0ZSBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IFJvdGF0ZUFuaW1hdGlvbl8xLlJvdGF0ZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IEVudW1zXzEuUm90YXRlRGlyZWN0aW9uLmNsb2Nrd2lzZTtcbiAgICAgICAgdGhpcy5wYXRoID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubG9hZChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGF0YS5kaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb24ubG9hZChkYXRhLmFuaW1hdGlvbik7XG4gICAgICAgIGlmIChkYXRhLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gZGF0YS5wYXRoO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Sb3RhdGUgPSBSb3RhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm90YXRlQW5pbWF0aW9uID0gdm9pZCAwO1xuY2xhc3MgUm90YXRlQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDA7XG4gICAgICAgIHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNwZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBkYXRhLnNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN5bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zeW5jID0gZGF0YS5zeW5jO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Sb3RhdGVBbmltYXRpb24gPSBSb3RhdGVBbmltYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2hhZG93ID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vT3B0aW9uc0NvbG9yXCIpO1xuY2xhc3MgU2hhZG93IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ibHVyID0gMDtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb2xvci52YWx1ZSA9IFwiIzAwMDAwMFwiO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmJsdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ibHVyID0gZGF0YS5ibHVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9mZnNldC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0LnggPSBkYXRhLm9mZnNldC54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9mZnNldC55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0LnkgPSBkYXRhLm9mZnNldC55O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TaGFkb3cgPSBTaGFkb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2hhcGUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNsYXNzIFNoYXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMudHlwZSA9IEVudW1zXzEuU2hhcGVUeXBlLmNpcmNsZTtcbiAgICB9XG4gICAgZ2V0IGltYWdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmltYWdlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmltYWdlc10pO1xuICAgIH1cbiAgICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmltYWdlXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuaW1hZ2VzXSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgY3VzdG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICBzZXQgY3VzdG9tKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaW1hZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5pbWFnZSA6IFt0aGlzLmltYWdlXTtcbiAgICB9XG4gICAgc2V0IGltYWdlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmltYWdlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzdHJva2UoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc2V0IHN0cm9rZShfdmFsdWUpIHtcbiAgICB9XG4gICAgZ2V0IGNoYXJhY3RlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5jaGFyYWN0ZXJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuY2hhcl0pO1xuICAgIH1cbiAgICBzZXQgY2hhcmFjdGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5jaGFyYWN0ZXJdID0gdmFsdWU7XG4gICAgICAgIHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5jaGFyXSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcG9seWdvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5wb2x5Z29uXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLnN0YXJdKTtcbiAgICB9XG4gICAgc2V0IHBvbHlnb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLnBvbHlnb25dID0gdmFsdWU7XG4gICAgICAgIHRoaXMub3B0aW9uc1tFbnVtc18xLlNoYXBlVHlwZS5zdGFyXSA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gKF9hID0gZGF0YS5vcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhLmN1c3RvbTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzaGFwZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG9wdGlvbnNbc2hhcGVdO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW3NoYXBlXSA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCgoX2IgPSB0aGlzLm9wdGlvbnNbc2hhcGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZFNoYXBlKGRhdGEuY2hhcmFjdGVyLCBFbnVtc18xLlNoYXBlVHlwZS5jaGFyYWN0ZXIsIEVudW1zXzEuU2hhcGVUeXBlLmNoYXIsIHRydWUpO1xuICAgICAgICB0aGlzLmxvYWRTaGFwZShkYXRhLnBvbHlnb24sIEVudW1zXzEuU2hhcGVUeXBlLnBvbHlnb24sIEVudW1zXzEuU2hhcGVUeXBlLnN0YXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5sb2FkU2hhcGUoKF9jID0gZGF0YS5pbWFnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGF0YS5pbWFnZXMsIEVudW1zXzEuU2hhcGVUeXBlLmltYWdlLCBFbnVtc18xLlNoYXBlVHlwZS5pbWFnZXMsIHRydWUpO1xuICAgICAgICBpZiAoZGF0YS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkU2hhcGUoaXRlbSwgbWFpbktleSwgYWx0S2V5LCBhbHRPdmVycmlkZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnNbbWFpbktleV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbbWFpbktleV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uc1thbHRLZXldIHx8IGFsdE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1thbHRLZXldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW21haW5LZXldID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKChfYSA9IHRoaXMub3B0aW9uc1ttYWluS2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNbYWx0S2V5XSB8fCBhbHRPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1thbHRLZXldID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKChfYiA9IHRoaXMub3B0aW9uc1thbHRLZXldKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW21haW5LZXldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbbWFpbktleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uc1thbHRLZXldIHx8IGFsdE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1thbHRLZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW21haW5LZXldID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKChfYyA9IHRoaXMub3B0aW9uc1ttYWluS2V5XSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIGl0ZW0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNbYWx0S2V5XSB8fCBhbHRPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1thbHRLZXldID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKChfZCA9IHRoaXMub3B0aW9uc1thbHRLZXldKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNoYXBlID0gU2hhcGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l6ZSA9IHZvaWQgMDtcbmNvbnN0IFNpemVBbmltYXRpb25fMSA9IHJlcXVpcmUoXCIuL1NpemVBbmltYXRpb25cIik7XG5jb25zdCBWYWx1ZVdpdGhSYW5kb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9WYWx1ZVdpdGhSYW5kb21cIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL1V0aWxzXCIpO1xuY2xhc3MgU2l6ZSBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IFNpemVBbmltYXRpb25fMS5TaXplQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMucmFuZG9tLm1pbmltdW1WYWx1ZSA9IDE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAzO1xuICAgIH1cbiAgICBnZXQgYW5pbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICBzZXQgYW5pbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSAoX2EgPSBkYXRhLmFuaW1hdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5hbmltO1xuICAgICAgICBpZiAoYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmxvYWQoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUodGhpcy52YWx1ZSwgdGhpcy5hbmltYXRpb24uZW5hYmxlID8gdGhpcy5hbmltYXRpb24ubWluaW11bVZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZSA9IFNpemU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l6ZUFuaW1hdGlvbiA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vRW51bXNcIik7XG5jb25zdCBBbmltYXRpb25PcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vLi4vQW5pbWF0aW9uT3B0aW9uc1wiKTtcbmNsYXNzIFNpemVBbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb25PcHRpb25zXzEuQW5pbWF0aW9uT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IEVudW1zXzEuRGVzdHJveVR5cGUubm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taW5pbXVtVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLnNwZWVkID0gNTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gRW51bXNfMS5TdGFydFZhbHVlVHlwZS5yYW5kb207XG4gICAgICAgIHRoaXMuc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgc2l6ZV9taW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltdW1WYWx1ZTtcbiAgICB9XG4gICAgc2V0IHNpemVfbWluKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWluaW11bVZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5sb2FkKGRhdGEpO1xuICAgICAgICBpZiAoZGF0YS5kZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGRhdGEuZGVzdHJveTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSBkYXRhLmVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5pbXVtVmFsdWUgPSAoX2EgPSBkYXRhLm1pbmltdW1WYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YS5zaXplX21pbjtcbiAgICAgICAgaWYgKG1pbmltdW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1pbmltdW1WYWx1ZSA9IG1pbmltdW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zcGVlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gZGF0YS5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zdGFydFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IGRhdGEuc3RhcnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zeW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luYyA9IGRhdGEuc3luYztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZUFuaW1hdGlvbiA9IFNpemVBbmltYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Ryb2tlID0gdm9pZCAwO1xuY29uc3QgQW5pbWF0YWJsZUNvbG9yXzEgPSByZXF1aXJlKFwiLi9BbmltYXRhYmxlQ29sb3JcIik7XG5jbGFzcyBTdHJva2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gQW5pbWF0YWJsZUNvbG9yXzEuQW5pbWF0YWJsZUNvbG9yLmNyZWF0ZSh0aGlzLmNvbG9yLCBkYXRhLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3Ryb2tlID0gU3Ryb2tlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR3aW5rbGUgPSB2b2lkIDA7XG5jb25zdCBUd2lua2xlVmFsdWVzXzEgPSByZXF1aXJlKFwiLi9Ud2lua2xlVmFsdWVzXCIpO1xuY2xhc3MgVHdpbmtsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBuZXcgVHdpbmtsZVZhbHVlc18xLlR3aW5rbGVWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBuZXcgVHdpbmtsZVZhbHVlc18xLlR3aW5rbGVWYWx1ZXMoKTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmVzLmxvYWQoZGF0YS5saW5lcyk7XG4gICAgICAgIHRoaXMucGFydGljbGVzLmxvYWQoZGF0YS5wYXJ0aWNsZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHdpbmtsZSA9IFR3aW5rbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHdpbmtsZVZhbHVlcyA9IHZvaWQgMDtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIFR3aW5rbGVWYWx1ZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IDAuMDU7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZnJlcXVlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gZGF0YS5mcmVxdWVuY3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlR3aW5rbGVWYWx1ZXMgPSBUd2lua2xlVmFsdWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmRvbSA9IHZvaWQgMDtcbmNsYXNzIFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWluaW11bVZhbHVlID0gMDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IGRhdGEuZW5hYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1pbmltdW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1pbmltdW1WYWx1ZSA9IGRhdGEubWluaW11bVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SYW5kb20gPSBSYW5kb207XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzcG9uc2l2ZSA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBSZXNwb25zaXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1heFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWF4V2lkdGggPSBkYXRhLm1heFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXNwb25zaXZlID0gUmVzcG9uc2l2ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaGVtZSA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVXRpbHNcIik7XG5jb25zdCBUaGVtZURlZmF1bHRfMSA9IHJlcXVpcmUoXCIuL1RoZW1lRGVmYXVsdFwiKTtcbmNsYXNzIFRoZW1lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gbmV3IFRoZW1lRGVmYXVsdF8xLlRoZW1lRGVmYXVsdCgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmYXVsdC5sb2FkKGRhdGEuZGVmYXVsdCk7XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UaGVtZSA9IFRoZW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRoZW1lRGVmYXVsdCA9IHZvaWQgMDtcbmNvbnN0IE1vZGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vRW51bXMvTW9kZXNcIik7XG5jbGFzcyBUaGVtZURlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBNb2Rlc18xLlRoZW1lTW9kZS5hbnk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGRhdGEubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGhlbWVEZWZhdWx0ID0gVGhlbWVEZWZhdWx0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlV2l0aFJhbmRvbSA9IHZvaWQgMDtcbmNvbnN0IFJhbmRvbV8xID0gcmVxdWlyZShcIi4vUmFuZG9tXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNsYXNzIFZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmFuZG9tID0gbmV3IFJhbmRvbV8xLlJhbmRvbSgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5yYW5kb20gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmRvbS5lbmFibGUgPSBkYXRhLnJhbmRvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFuZG9tLmxvYWQoZGF0YS5yYW5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBVdGlsc18xLk51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUoZGF0YS52YWx1ZSwgdGhpcy5yYW5kb20uZW5hYmxlID8gdGhpcy5yYW5kb20ubWluaW11bVZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVXaXRoUmFuZG9tID0gVmFsdWVXaXRoUmFuZG9tO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic29yYmVySW5zdGFuY2UgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgVmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vQ29yZS9QYXJ0aWNsZS9WZWN0b3JcIik7XG5jbGFzcyBBYnNvcmJlckluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihhYnNvcmJlcnMsIGNvbnRhaW5lciwgb3B0aW9ucywgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuYWJzb3JiZXJzID0gYWJzb3JiZXJzO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5pbml0aWFsUG9zaXRpb24gPSBwb3NpdGlvbiA/IFZlY3Rvcl8xLlZlY3Rvci5jcmVhdGUocG9zaXRpb24ueCwgcG9zaXRpb24ueSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICB0aGlzLnNpemUgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKG9wdGlvbnMuc2l6ZSkgKiBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMubWFzcyA9IHRoaXMuc2l6ZSAqIG9wdGlvbnMuc2l6ZS5kZW5zaXR5ICogY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3I7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5zaXplLmxpbWl0O1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQgIT09IHVuZGVmaW5lZCA/IGxpbWl0ICogY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvICogY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3IgOiBsaW1pdDtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0eXBlb2Ygb3B0aW9ucy5jb2xvciA9PT0gXCJzdHJpbmdcIiA/IHsgdmFsdWU6IG9wdGlvbnMuY29sb3IgfSA6IG9wdGlvbnMuY29sb3I7XG4gICAgICAgIHRoaXMuY29sb3IgPSAoX2EgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihjb2xvcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICBnOiAwLFxuICAgICAgICAgICAgcjogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IChfYyA9IChfYiA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29weSgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmNhbGNQb3NpdGlvbigpO1xuICAgIH1cbiAgICBhdHRyYWN0KHBhcnRpY2xlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgbW91c2UgPSB0aGlzLmNvbnRhaW5lci5pbnRlcmFjdGl2aXR5Lm1vdXNlO1xuICAgICAgICAgICAgaWYgKG1vdXNlLmNsaWNraW5nICYmIG1vdXNlLmRvd25Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlRGlzdCA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2UodGhpcy5wb3NpdGlvbiwgbW91c2UuZG93blBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAobW91c2VEaXN0IDw9IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyAmJiBtb3VzZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gbW91c2UucG9zaXRpb24ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3MgPSBwYXJ0aWNsZS5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCB7IGR4LCBkeSwgZGlzdGFuY2UgfSA9IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKHRoaXMucG9zaXRpb24sIHBvcyk7XG4gICAgICAgIGNvbnN0IHYgPSBWZWN0b3JfMS5WZWN0b3IuY3JlYXRlKGR4LCBkeSk7XG4gICAgICAgIHYubGVuZ3RoID0gKHRoaXMubWFzcyAvIE1hdGgucG93KGRpc3RhbmNlLCAyKSkgKiB0aGlzLmNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLnNpemUgKyBwYXJ0aWNsZS5nZXRSYWRpdXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZUZhY3RvciA9IHBhcnRpY2xlLmdldFJhZGl1cygpICogMC4wMzMgKiB0aGlzLmNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemUgPiBwYXJ0aWNsZS5nZXRSYWRpdXMoKSAmJiBkaXN0YW5jZSA8IHRoaXMuc2l6ZSAtIHBhcnRpY2xlLmdldFJhZGl1cygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5uZWVkc05ld1Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYXJ0aWNsZVBvc2l0aW9uKHBhcnRpY2xlLCB2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnNpemUudmFsdWUgLT0gc2l6ZUZhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYXJ0aWNsZVBvc2l0aW9uKHBhcnRpY2xlLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbWl0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5zaXplIDwgdGhpcy5saW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBzaXplRmFjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXNzICs9IHNpemVGYWN0b3IgKiB0aGlzLm9wdGlvbnMuc2l6ZS5kZW5zaXR5ICogdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFydGljbGVQb3NpdGlvbihwYXJ0aWNsZSwgdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9XG4gICAgICAgICAgICBpbml0aWFsUG9zaXRpb24gJiYgVXRpbHNfMS5VdGlscy5pc1BvaW50SW5zaWRlKGluaXRpYWxQb3NpdGlvbiwgdGhpcy5jb250YWluZXIuY2FudmFzLnNpemUpXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsUG9zaXRpb25cbiAgICAgICAgICAgICAgICA6IHRoaXMuY2FsY1Bvc2l0aW9uKCk7XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuc2l6ZSwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKHRoaXMuY29sb3IsIHRoaXMub3BhY2l0eSk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBjYWxjUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBwZXJjZW50UG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIHJldHVybiBWZWN0b3JfMS5WZWN0b3IuY3JlYXRlKCgoKF9hID0gcGVyY2VudFBvc2l0aW9uID09PSBudWxsIHx8IHBlcmNlbnRQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyY2VudFBvc2l0aW9uLngpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1hdGgucmFuZG9tKCkgKiAxMDApIC8gMTAwKSAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCwgKCgoX2IgPSBwZXJjZW50UG9zaXRpb24gPT09IG51bGwgfHwgcGVyY2VudFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJjZW50UG9zaXRpb24ueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTWF0aC5yYW5kb20oKSAqIDEwMCkgLyAxMDApICogY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCk7XG4gICAgfVxuICAgIHVwZGF0ZVBhcnRpY2xlUG9zaXRpb24ocGFydGljbGUsIHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGFydGljbGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IHRoaXMuY29udGFpbmVyLmNhbnZhcy5zaXplO1xuICAgICAgICBpZiAocGFydGljbGUubmVlZHNOZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcFNpemUgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKTtcbiAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhc1NpemUud2lkdGggLSBwU2l6ZSAqIDIpICsgcFNpemU7XG4gICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi55ID0gTWF0aC5yYW5kb20oKSAqIChjYW52YXNTaXplLmhlaWdodCAtIHBTaXplICogMikgKyBwU2l6ZTtcbiAgICAgICAgICAgIHBhcnRpY2xlLm5lZWRzTmV3UG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9yYml0cykge1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLm9yYml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcmJpdCA9IFZlY3Rvcl8xLlZlY3Rvci5jcmVhdGUoMCwgMCk7XG4gICAgICAgICAgICAgICAgcGFydGljbGUub3JiaXQubGVuZ3RoID0gVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZShwYXJ0aWNsZS5nZXRQb3NpdGlvbigpLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5vcmJpdC5hbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0aWNsZS5vcmJpdC5sZW5ndGggPD0gdGhpcy5zaXplICYmICF0aGlzLm9wdGlvbnMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLm9yYml0Lmxlbmd0aCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLm1heChjYW52YXNTaXplLndpZHRoLCBjYW52YXNTaXplLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS54ID0gMDtcbiAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnkgPSAwO1xuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24uc2V0VG8ocGFydGljbGUub3JiaXQuYWRkKHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgICAgIHBhcnRpY2xlLm9yYml0Lmxlbmd0aCAtPSB2Lmxlbmd0aDtcbiAgICAgICAgICAgIHBhcnRpY2xlLm9yYml0LmFuZ2xlICs9XG4gICAgICAgICAgICAgICAgKCgoX2EgPSBwYXJ0aWNsZS5tb3ZlU3BlZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0UmFuZ2VWYWx1ZShwYXJ0aWNsZS5vcHRpb25zLm1vdmUuc3BlZWQpICogdGhpcy5jb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW8pIC9cbiAgICAgICAgICAgICAgICAgICAgMTAwKSAqXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJldGluYS5yZWR1Y2VGYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5hZGRUbyh2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzb3JiZXJJbnN0YW5jZSA9IEFic29yYmVySW5zdGFuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzb3JiZXJzID0gdm9pZCAwO1xuY29uc3QgQWJzb3JiZXJJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vQWJzb3JiZXJJbnN0YW5jZVwiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBBYnNvcmJlcl8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0Fic29yYmVyXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY2xhc3MgQWJzb3JiZXJzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5hYnNvcmJlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2aXR5QWJzb3JiZXJzID0gW107XG4gICAgICAgIGNvbnN0IG92ZXJyaWRhYmxlQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBvdmVycmlkYWJsZUNvbnRhaW5lci5hZGRBYnNvcmJlciA9IChvcHRpb25zLCBwb3NpdGlvbikgPT4gdGhpcy5hZGRBYnNvcmJlcihvcHRpb25zLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hYnNvcmJlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFic29yYmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYnNvcmJlcnMgPSBvcHRpb25zLmFic29yYmVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEFic29yYmVyXzEuQWJzb3JiZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFic29yYmVycyA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWJzb3JiZXJzLmxvYWQob3B0aW9ucy5hYnNvcmJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFic29yYmVycztcbiAgICAgICAgaWYgKGludGVyYWN0aXZpdHlBYnNvcmJlcnMpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2aXR5QWJzb3JiZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSBpbnRlcmFjdGl2aXR5QWJzb3JiZXJzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgQWJzb3JiZXJfMS5BYnNvcmJlcigpO1xuICAgICAgICAgICAgICAgICAgICB0bXAubG9hZChzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSBuZXcgQWJzb3JiZXJfMS5BYnNvcmJlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlBYnNvcmJlcnMubG9hZChpbnRlcmFjdGl2aXR5QWJzb3JiZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhYnNvcmJlck9wdGlvbnMgb2YgdGhpcy5hYnNvcmJlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFic29yYmVyKGFic29yYmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFic29yYmVyKHRoaXMuYWJzb3JiZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNsZVVwZGF0ZShwYXJ0aWNsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGFic29yYmVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGFic29yYmVyLmF0dHJhY3QocGFydGljbGUpO1xuICAgICAgICAgICAgaWYgKHBhcnRpY2xlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IGFic29yYmVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgYWJzb3JiZXIuZHJhdyhjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGFic29yYmVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGFic29yYmVyLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsaWNrTW9kZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBhYnNvcmJlck9wdGlvbnMgPSB0aGlzLmFic29yYmVycztcbiAgICAgICAgY29uc3QgbW9kZUFic29yYmVycyA9IHRoaXMuaW50ZXJhY3Rpdml0eUFic29yYmVycztcbiAgICAgICAgaWYgKG1vZGUgPT09IEVudW1zXzEuQWJzb3JiZXJDbGlja01vZGUuYWJzb3JiZXIpIHtcbiAgICAgICAgICAgIGxldCBhYnNvcmJlcnNNb2RlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChtb2RlQWJzb3JiZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZUFic29yYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFic29yYmVyc01vZGVPcHRpb25zID0gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KG1vZGVBYnNvcmJlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFic29yYmVyc01vZGVPcHRpb25zID0gbW9kZUFic29yYmVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFic29yYmVyc09wdGlvbnMgPSBhYnNvcmJlcnNNb2RlT3B0aW9ucyAhPT0gbnVsbCAmJiBhYnNvcmJlcnNNb2RlT3B0aW9ucyAhPT0gdm9pZCAwID8gYWJzb3JiZXJzTW9kZU9wdGlvbnMgOiAoYWJzb3JiZXJPcHRpb25zIGluc3RhbmNlb2YgQXJyYXkgPyBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkoYWJzb3JiZXJPcHRpb25zKSA6IGFic29yYmVyT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBhUG9zaXRpb24gPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5hZGRBYnNvcmJlcihhYnNvcmJlcnNPcHRpb25zLCBhUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFic29yYmVyKG9wdGlvbnMsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFic29yYmVyID0gbmV3IEFic29yYmVySW5zdGFuY2VfMS5BYnNvcmJlckluc3RhbmNlKHRoaXMsIHRoaXMuY29udGFpbmVyLCBvcHRpb25zLCBwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYXJyYXkucHVzaChhYnNvcmJlcik7XG4gICAgICAgIHJldHVybiBhYnNvcmJlcjtcbiAgICB9XG4gICAgcmVtb3ZlQWJzb3JiZXIoYWJzb3JiZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFycmF5LmluZGV4T2YoYWJzb3JiZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnNvcmJlcnMgPSBBYnNvcmJlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnNvcmJlcnNQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBBYnNvcmJlcnNfMSA9IHJlcXVpcmUoXCIuL0Fic29yYmVyc1wiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbHNcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG5jb25zdCBBYnNvcmJlcl8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0Fic29yYmVyXCIpO1xuY2xhc3MgQWJzb3JiZXJzUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pZCA9IFwiYWJzb3JiZXJzXCI7XG4gICAgfVxuICAgIGdldFBsdWdpbihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBYnNvcmJlcnNfMS5BYnNvcmJlcnMoY29udGFpbmVyKTtcbiAgICB9XG4gICAgbmVlZHNQbHVnaW4ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29yYmVycyA9IG9wdGlvbnMuYWJzb3JiZXJzO1xuICAgICAgICBsZXQgbG9hZEFic29yYmVycyA9IGZhbHNlO1xuICAgICAgICBpZiAoYWJzb3JiZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChhYnNvcmJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9hZEFic29yYmVycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWJzb3JiZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvYWRBYnNvcmJlcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubW9kZSkgJiZcbiAgICAgICAgICAgIFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuQWJzb3JiZXJDbGlja01vZGUuYWJzb3JiZXIsIG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5tb2RlKSkge1xuICAgICAgICAgICAgbG9hZEFic29yYmVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRBYnNvcmJlcnM7XG4gICAgfVxuICAgIGxvYWRPcHRpb25zKG9wdGlvbnMsIHNvdXJjZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMubmVlZHNQbHVnaW4ob3B0aW9ucykgJiYgIXRoaXMubmVlZHNQbHVnaW4oc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnNDYXN0ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5hYnNvcmJlcnMpIHtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmFic29yYmVycykgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNDYXN0LmFic29yYmVycyA9IHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5hYnNvcmJlcnMubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGFic29yYmVyT3B0aW9ucyA9IG9wdGlvbnNDYXN0LmFic29yYmVycztcbiAgICAgICAgICAgICAgICBpZiAoKGFic29yYmVyT3B0aW9ucyA9PT0gbnVsbCB8fCBhYnNvcmJlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFic29yYmVyT3B0aW9ucy5sb2FkKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNDYXN0LmFic29yYmVycyA9IGFic29yYmVyT3B0aW9ucyA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFic29yYmVyT3B0aW9ucy5sb2FkKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5hYnNvcmJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZpdHlBYnNvcmJlcnMgPSAoX2IgPSAoX2EgPSBzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuaW50ZXJhY3Rpdml0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJzb3JiZXJzO1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUFic29yYmVycykge1xuICAgICAgICAgICAgaWYgKGludGVyYWN0aXZpdHlBYnNvcmJlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNDYXN0LmludGVyYWN0aXZpdHkubW9kZXMuYWJzb3JiZXJzID0gaW50ZXJhY3Rpdml0eUFic29yYmVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEFic29yYmVyXzEuQWJzb3JiZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYWJzb3JiZXJPcHRpb25zID0gb3B0aW9uc0Nhc3QuaW50ZXJhY3Rpdml0eS5tb2Rlcy5hYnNvcmJlcnM7XG4gICAgICAgICAgICAgICAgaWYgKChhYnNvcmJlck9wdGlvbnMgPT09IG51bGwgfHwgYWJzb3JiZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYnNvcmJlck9wdGlvbnMubG9hZCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zQ2FzdC5pbnRlcmFjdGl2aXR5Lm1vZGVzLmFic29yYmVycyA9IGFic29yYmVyT3B0aW9ucyA9IG5ldyBBYnNvcmJlcl8xLkFic29yYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFic29yYmVyT3B0aW9ucy5sb2FkKGludGVyYWN0aXZpdHlBYnNvcmJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgcGx1Z2luID0gbmV3IEFic29yYmVyc1BsdWdpbigpO1xuZXhwb3J0cy5BYnNvcmJlcnNQbHVnaW4gPSBwbHVnaW47XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRW51bXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic29yYmVyQ2xpY2tNb2RlID0gdm9pZCAwO1xudmFyIEFic29yYmVyQ2xpY2tNb2RlO1xuKGZ1bmN0aW9uIChBYnNvcmJlckNsaWNrTW9kZSkge1xuICAgIEFic29yYmVyQ2xpY2tNb2RlW1wiYWJzb3JiZXJcIl0gPSBcImFic29yYmVyXCI7XG59KShBYnNvcmJlckNsaWNrTW9kZSA9IGV4cG9ydHMuQWJzb3JiZXJDbGlja01vZGUgfHwgKGV4cG9ydHMuQWJzb3JiZXJDbGlja01vZGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9BYnNvcmJlckNsaWNrTW9kZVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzb3JiZXIgPSB2b2lkIDA7XG5jb25zdCBBYnNvcmJlclNpemVfMSA9IHJlcXVpcmUoXCIuL0Fic29yYmVyU2l6ZVwiKTtcbmNvbnN0IE9wdGlvbnNDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL09wdGlvbnMvQ2xhc3Nlcy9PcHRpb25zQ29sb3JcIik7XG5jbGFzcyBBYnNvcmJlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yKCk7XG4gICAgICAgIHRoaXMuY29sb3IudmFsdWUgPSBcIiMwMDAwMDBcIjtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcmJpdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEFic29yYmVyU2l6ZV8xLkFic29yYmVyU2l6ZSgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IuY3JlYXRlKHRoaXMuY29sb3IsIGRhdGEuY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRyYWdnYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGRhdGEuZHJhZ2dhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBkYXRhLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogZGF0YS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5sb2FkKGRhdGEuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSBkYXRhLmRlc3Ryb3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEub3JiaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3JiaXRzID0gZGF0YS5vcmJpdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic29yYmVyID0gQWJzb3JiZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzb3JiZXJTaXplID0gdm9pZCAwO1xuY29uc3QgVmFsdWVXaXRoUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vT3B0aW9ucy9DbGFzc2VzL1ZhbHVlV2l0aFJhbmRvbVwiKTtcbmNsYXNzIEFic29yYmVyU2l6ZSBleHRlbmRzIFZhbHVlV2l0aFJhbmRvbV8xLlZhbHVlV2l0aFJhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVuc2l0eSA9IDU7XG4gICAgICAgIHRoaXMucmFuZG9tLm1pbmltdW1WYWx1ZSA9IDE7XG4gICAgICAgIHRoaXMudmFsdWUgPSA1MDtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmxvYWQoZGF0YSk7XG4gICAgICAgIGlmIChkYXRhLmRlbnNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZW5zaXR5ID0gZGF0YS5kZW5zaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGltaXQgPSBkYXRhLmxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGltaXQgPSBkYXRhLmxpbWl0O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnNvcmJlclNpemUgPSBBYnNvcmJlclNpemU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlckluc3RhbmNlID0gdm9pZCAwO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBFbWl0dGVyU2l6ZV8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0VtaXR0ZXJTaXplXCIpO1xuZnVuY3Rpb24gcmFuZG9tQ29vcmRpbmF0ZShwb3NpdGlvbiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uICsgb2Zmc2V0ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xufVxuZnVuY3Rpb24gcmFuZG9tUG9zaXRpb24ocG9zaXRpb24sIG9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJhbmRvbUNvb3JkaW5hdGUocG9zaXRpb24ueCwgb2Zmc2V0LngpLFxuICAgICAgICB5OiByYW5kb21Db29yZGluYXRlKHBvc2l0aW9uLnksIG9mZnNldC55KSxcbiAgICB9O1xufVxuY2xhc3MgRW1pdHRlckluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVycywgY29udGFpbmVyLCBlbWl0dGVyT3B0aW9ucywgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLmVtaXR0ZXJzID0gZW1pdHRlcnM7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmZpcnN0U3Bhd24gPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnJlbnREdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudEVtaXREZWxheSA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFNwYXduRGVsYXkgPSAwO1xuICAgICAgICB0aGlzLmluaXRpYWxQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmVtaXR0ZXJPcHRpb25zID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBlbWl0dGVyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3Bhd25EZWxheSA9ICgoKF9hID0gdGhpcy5lbWl0dGVyT3B0aW9ucy5saWZlLmRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAqIDEwMDApIC8gdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IChfYiA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNhbGNQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlbWl0dGVyT3B0aW9ucy5uYW1lO1xuICAgICAgICBsZXQgcGFydGljbGVzT3B0aW9ucyA9IFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgdGhpcy5lbWl0dGVyT3B0aW9ucy5wYXJ0aWNsZXMpO1xuICAgICAgICBpZiAocGFydGljbGVzT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZXNPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpY2xlc09wdGlvbnMubW92ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZXNPcHRpb25zLm1vdmUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljbGVzT3B0aW9ucy5tb3ZlLmRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZXNPcHRpb25zLm1vdmUuZGlyZWN0aW9uID0gdGhpcy5lbWl0dGVyT3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1pdHRlck9wdGlvbnMuc3Bhd25Db2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwYXduQ29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb0hzbCh0aGlzLmVtaXR0ZXJPcHRpb25zLnNwYXduQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF1c2VkID0gIXRoaXMuZW1pdHRlck9wdGlvbnMuYXV0b1BsYXk7XG4gICAgICAgIHRoaXMucGFydGljbGVzT3B0aW9ucyA9IHBhcnRpY2xlc09wdGlvbnM7XG4gICAgICAgIHRoaXMuc2l6ZSA9XG4gICAgICAgICAgICAoX2MgPSB0aGlzLmVtaXR0ZXJPcHRpb25zLnNpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IG5ldyBFbWl0dGVyU2l6ZV8xLkVtaXR0ZXJTaXplKCk7XG4gICAgICAgICAgICAgICAgc2l6ZS5sb2FkKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBFbnVtc18xLlNpemVNb2RlLnBlcmNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5saWZlQ291bnQgPSAoX2QgPSB0aGlzLmVtaXR0ZXJPcHRpb25zLmxpZmUuY291bnQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IC0xO1xuICAgICAgICB0aGlzLmltbW9ydGFsID0gdGhpcy5saWZlQ291bnQgPD0gMDtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIGV4dGVybmFsUGxheSgpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIGV4dGVybmFsUGF1c2UoKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvciAmJlxuICAgICAgICAgICAgKHRoaXMubGlmZUNvdW50ID4gMCB8fCB0aGlzLmltbW9ydGFsIHx8ICF0aGlzLmVtaXR0ZXJPcHRpb25zLmxpZmUuY291bnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbWl0RGVsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdERlbGF5ID0gKDEwMDAgKiB0aGlzLmVtaXR0ZXJPcHRpb25zLnJhdGUuZGVsYXkpIC8gdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpZmVDb3VudCA+IDAgfHwgdGhpcy5pbW1vcnRhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZVRvRGllKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVtaXREZWxheTtcbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9XG4gICAgICAgICAgICBpbml0aWFsUG9zaXRpb24gJiYgVXRpbHNfMS5VdGlscy5pc1BvaW50SW5zaWRlKGluaXRpYWxQb3NpdGlvbiwgdGhpcy5jb250YWluZXIuY2FudmFzLnNpemUpXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsUG9zaXRpb25cbiAgICAgICAgICAgICAgICA6IHRoaXMuY2FsY1Bvc2l0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlyc3RTcGF3bikge1xuICAgICAgICAgICAgdGhpcy5maXJzdFNwYXduID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTcGF3bkRlbGF5ID0gKF9hID0gdGhpcy5zcGF3bkRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RW1pdERlbGF5ID0gKF9iID0gdGhpcy5lbWl0RGVsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgICAgICBkZWx0YS52YWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHVyYXRpb24gKz0gZGVsdGEudmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHVyYXRpb24gPj0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGF3bkRlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3Bhd25EZWxheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmltbW9ydGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlmZUNvdW50LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpZmVDb3VudCA+IDAgfHwgdGhpcy5pbW1vcnRhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5jYWxjUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGF3bkRlbGF5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICgoKF9jID0gdGhpcy5lbWl0dGVyT3B0aW9ucy5saWZlLmRlbGF5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSAqIDEwMDApIC8gdGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREdXJhdGlvbiAtPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNwYXduRGVsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3Bhd25EZWxheSArPSBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTcGF3bkRlbGF5ID49IHRoaXMuc3Bhd25EZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNwYXduRGVsYXkgLT0gdGhpcy5jdXJyZW50U3Bhd25EZWxheTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zcGF3bkRlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtaXREZWxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFbWl0RGVsYXkgKz0gZGVsdGEudmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RW1pdERlbGF5ID49IHRoaXMuZW1pdERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RW1pdERlbGF5IC09IHRoaXMuZW1pdERlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVUb0RpZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IChfYSA9IHRoaXMuZW1pdHRlck9wdGlvbnMubGlmZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmR1cmF0aW9uO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIucmV0aW5hLnJlZHVjZUZhY3RvciAmJlxuICAgICAgICAgICAgKHRoaXMubGlmZUNvdW50ID4gMCB8fCB0aGlzLmltbW9ydGFsKSAmJlxuICAgICAgICAgICAgZHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcnMucmVtb3ZlRW1pdHRlcih0aGlzKTtcbiAgICB9XG4gICAgY2FsY1Bvc2l0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgcGVyY2VudFBvc2l0aW9uID0gdGhpcy5lbWl0dGVyT3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6ICgoKF9hID0gcGVyY2VudFBvc2l0aW9uID09PSBudWxsIHx8IHBlcmNlbnRQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyY2VudFBvc2l0aW9uLngpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1hdGgucmFuZG9tKCkgKiAxMDApIC8gMTAwKSAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHk6ICgoKF9iID0gcGVyY2VudFBvc2l0aW9uID09PSBudWxsIHx8IHBlcmNlbnRQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyY2VudFBvc2l0aW9uLnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1hdGgucmFuZG9tKCkgKiAxMDApIC8gMTAwKSAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVtaXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogdGhpcy5zaXplLm1vZGUgPT09IEVudW1zXzEuU2l6ZU1vZGUucGVyY2VudFxuICAgICAgICAgICAgICAgID8gKGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCAqIHRoaXMuc2l6ZS53aWR0aCkgLyAxMDBcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHk6IHRoaXMuc2l6ZS5tb2RlID09PSBFbnVtc18xLlNpemVNb2RlLnBlcmNlbnRcbiAgICAgICAgICAgICAgICA/IChjb250YWluZXIuY2FudmFzLnNpemUuaGVpZ2h0ICogdGhpcy5zaXplLmhlaWdodCkgLyAxMDBcbiAgICAgICAgICAgICAgICA6IHRoaXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbWl0dGVyT3B0aW9ucy5yYXRlLnF1YW50aXR5OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlc09wdGlvbnMgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIHRoaXMucGFydGljbGVzT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGF3bkNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckFuaW1hdGlvbiA9IChfYSA9IHRoaXMuZW1pdHRlck9wdGlvbnMuc3Bhd25Db2xvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHVlQW5pbWF0aW9uID0gY29sb3JBbmltYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChodWVBbmltYXRpb24uZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduQ29sb3IuaCA9IHRoaXMuc2V0Q29sb3JBbmltYXRpb24oaHVlQW5pbWF0aW9uLCB0aGlzLnNwYXduQ29sb3IuaCwgMzYwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhzbEFuaW1hdGlvbiA9IGNvbG9yQW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGF3bkNvbG9yLmggPSB0aGlzLnNldENvbG9yQW5pbWF0aW9uKGhzbEFuaW1hdGlvbi5oLCB0aGlzLnNwYXduQ29sb3IuaCwgMzYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25Db2xvci5zID0gdGhpcy5zZXRDb2xvckFuaW1hdGlvbihoc2xBbmltYXRpb24ucywgdGhpcy5zcGF3bkNvbG9yLnMsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduQ29sb3IubCA9IHRoaXMuc2V0Q29sb3JBbmltYXRpb24oaHNsQW5pbWF0aW9uLmwsIHRoaXMuc3Bhd25Db2xvci5sLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFydGljbGVzT3B0aW9ucy5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZXNPcHRpb25zLmNvbG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3Bhd25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlc09wdGlvbnMuY29sb3IudmFsdWUgPSB0aGlzLnNwYXduQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5hZGRQYXJ0aWNsZShyYW5kb21Qb3NpdGlvbihwb3NpdGlvbiwgb2Zmc2V0KSwgcGFydGljbGVzT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q29sb3JBbmltYXRpb24oYW5pbWF0aW9uLCBpbml0VmFsdWUsIG1heFZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICghYW5pbWF0aW9uLmVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvck9mZnNldCA9IFV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZShhbmltYXRpb24ub2Zmc2V0KTtcbiAgICAgICAgY29uc3QgZW1pdEZhY3RvciA9ICgxMDAwICogdGhpcy5lbWl0dGVyT3B0aW9ucy5yYXRlLmRlbGF5KSAvIGNvbnRhaW5lci5yZXRpbmEucmVkdWNlRmFjdG9yO1xuICAgICAgICBjb25zdCBjb2xvclNwZWVkID0gKF9hID0gYW5pbWF0aW9uLnNwZWVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICByZXR1cm4gKGluaXRWYWx1ZSArIChjb2xvclNwZWVkICogY29udGFpbmVyLmZwc0xpbWl0KSAvIGVtaXRGYWN0b3IgKyBjb2xvck9mZnNldCAqIDMuNikgJSBtYXhWYWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXJJbnN0YW5jZSA9IEVtaXR0ZXJJbnN0YW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWl0dGVycyA9IHZvaWQgMDtcbmNvbnN0IEVtaXR0ZXJJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vRW1pdHRlckluc3RhbmNlXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL09wdGlvbnMvQ2xhc3Nlcy9FbWl0dGVyXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY2xhc3MgRW1pdHRlcnMge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5hcnJheSA9IFtdO1xuICAgICAgICB0aGlzLmVtaXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpdml0eUVtaXR0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IG92ZXJyaWRhYmxlQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBvdmVycmlkYWJsZUNvbnRhaW5lci5hZGRFbWl0dGVyID0gKG9wdGlvbnMsIHBvc2l0aW9uKSA9PiB0aGlzLmFkZEVtaXR0ZXIob3B0aW9ucywgcG9zaXRpb24pO1xuICAgICAgICBvdmVycmlkYWJsZUNvbnRhaW5lci5wbGF5RW1pdHRlciA9IChpZHhPck5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBpZHhPck5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaWR4T3JOYW1lID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgPyB0aGlzLmFycmF5W2lkeE9yTmFtZSB8fCAwXVxuICAgICAgICAgICAgICAgIDogdGhpcy5hcnJheS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGlkeE9yTmFtZSk7XG4gICAgICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZXh0ZXJuYWxQbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG92ZXJyaWRhYmxlQ29udGFpbmVyLnBhdXNlRW1pdHRlciA9IChpZHhPck5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBpZHhPck5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaWR4T3JOYW1lID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgPyB0aGlzLmFycmF5W2lkeE9yTmFtZSB8fCAwXVxuICAgICAgICAgICAgICAgIDogdGhpcy5hcnJheS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGlkeE9yTmFtZSk7XG4gICAgICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZXh0ZXJuYWxQYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW1pdHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXJzID0gb3B0aW9ucy5lbWl0dGVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW1pdHRlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXJzID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlcnMubG9hZChvcHRpb25zLmVtaXR0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5RW1pdHRlcnMgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXR0ZXJzO1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aXZpdHlFbWl0dGVycyA9IGludGVyYWN0aXZpdHlFbWl0dGVycy5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sb2FkKHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3Rpdml0eUVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2aXR5RW1pdHRlcnMgPSBuZXcgRW1pdHRlcl8xLkVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGl2aXR5RW1pdHRlcnMubG9hZChpbnRlcmFjdGl2aXR5RW1pdHRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW1pdHRlck9wdGlvbnMgb2YgdGhpcy5lbWl0dGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRW1pdHRlcihlbWl0dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVtaXR0ZXIodGhpcy5lbWl0dGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxheSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbWl0dGVyIG9mIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVtaXR0ZXIgb2YgdGhpcy5hcnJheSkge1xuICAgICAgICAgICAgZW1pdHRlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW1pdHRlciBvZiB0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICBlbWl0dGVyLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2xpY2tNb2RlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXJPcHRpb25zID0gdGhpcy5lbWl0dGVycztcbiAgICAgICAgY29uc3QgbW9kZUVtaXR0ZXJzID0gdGhpcy5pbnRlcmFjdGl2aXR5RW1pdHRlcnM7XG4gICAgICAgIGlmIChtb2RlID09PSBFbnVtc18xLkVtaXR0ZXJDbGlja01vZGUuZW1pdHRlcikge1xuICAgICAgICAgICAgbGV0IGVtaXR0ZXJNb2RlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChtb2RlRW1pdHRlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlRW1pdHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyTW9kZU9wdGlvbnMgPSBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkobW9kZUVtaXR0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyTW9kZU9wdGlvbnMgPSBtb2RlRW1pdHRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyc09wdGlvbnMgPSBlbWl0dGVyTW9kZU9wdGlvbnMgIT09IG51bGwgJiYgZW1pdHRlck1vZGVPcHRpb25zICE9PSB2b2lkIDAgPyBlbWl0dGVyTW9kZU9wdGlvbnMgOiAoZW1pdHRlck9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSA/IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShlbWl0dGVyT3B0aW9ucykgOiBlbWl0dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBlUG9zaXRpb24gPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5hZGRFbWl0dGVyKFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgZW1pdHRlcnNPcHRpb25zKSwgZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW1pdHRlciBvZiB0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICBlbWl0dGVyLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVtaXR0ZXIob3B0aW9ucywgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVySW5zdGFuY2VfMS5FbWl0dGVySW5zdGFuY2UodGhpcywgdGhpcy5jb250YWluZXIsIG9wdGlvbnMsIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5hcnJheS5wdXNoKGVtaXR0ZXIpO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgcmVtb3ZlRW1pdHRlcihlbWl0dGVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5hcnJheS5pbmRleE9mKGVtaXR0ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5hcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVycyA9IEVtaXR0ZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlcnNQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgRW1pdHRlcnNfMSA9IHJlcXVpcmUoXCIuL0VtaXR0ZXJzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuY29uc3QgRW1pdHRlcl8xID0gcmVxdWlyZShcIi4vT3B0aW9ucy9DbGFzc2VzL0VtaXR0ZXJcIik7XG5jbGFzcyBFbWl0dGVyc1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWQgPSBcImVtaXR0ZXJzXCI7XG4gICAgfVxuICAgIGdldFBsdWdpbihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbWl0dGVyc18xLkVtaXR0ZXJzKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIG5lZWRzUGx1Z2luKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVycyA9IG9wdGlvbnMuZW1pdHRlcnM7XG4gICAgICAgIGxldCBsb2FkRW1pdHRlcnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChlbWl0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2FkRW1pdHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVtaXR0ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvYWRFbWl0dGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uQ2xpY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tb2RlKSAmJlxuICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5FbWl0dGVyQ2xpY2tNb2RlLmVtaXR0ZXIsIG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5tb2RlKSkge1xuICAgICAgICAgICAgbG9hZEVtaXR0ZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9hZEVtaXR0ZXJzO1xuICAgIH1cbiAgICBsb2FkT3B0aW9ucyhvcHRpb25zLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLm5lZWRzUGx1Z2luKG9wdGlvbnMpICYmICF0aGlzLm5lZWRzUGx1Z2luKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zQ2FzdCA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuZW1pdHRlcnMpIHtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmVtaXR0ZXJzKSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc0Nhc3QuZW1pdHRlcnMgPSBzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuZW1pdHRlcnMubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IG5ldyBFbWl0dGVyXzEuRW1pdHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0bXAubG9hZChzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbWl0dGVyT3B0aW9ucyA9IG9wdGlvbnNDYXN0LmVtaXR0ZXJzO1xuICAgICAgICAgICAgICAgIGlmICgoZW1pdHRlck9wdGlvbnMgPT09IG51bGwgfHwgZW1pdHRlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVtaXR0ZXJPcHRpb25zLmxvYWQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0Nhc3QuZW1pdHRlcnMgPSBlbWl0dGVyT3B0aW9ucyA9IG5ldyBFbWl0dGVyXzEuRW1pdHRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbWl0dGVyT3B0aW9ucy5sb2FkKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5lbWl0dGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpdml0eUVtaXR0ZXJzID0gKF9iID0gKF9hID0gc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmludGVyYWN0aXZpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXR0ZXJzO1xuICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zQ2FzdC5pbnRlcmFjdGl2aXR5Lm1vZGVzLmVtaXR0ZXJzID0gaW50ZXJhY3Rpdml0eUVtaXR0ZXJzLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgRW1pdHRlcl8xLkVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmxvYWQocyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW1pdHRlck9wdGlvbnMgPSBvcHRpb25zQ2FzdC5pbnRlcmFjdGl2aXR5Lm1vZGVzLmVtaXR0ZXJzO1xuICAgICAgICAgICAgICAgIGlmICgoZW1pdHRlck9wdGlvbnMgPT09IG51bGwgfHwgZW1pdHRlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVtaXR0ZXJPcHRpb25zLmxvYWQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0Nhc3QuaW50ZXJhY3Rpdml0eS5tb2Rlcy5lbWl0dGVycyA9IGVtaXR0ZXJPcHRpb25zID0gbmV3IEVtaXR0ZXJfMS5FbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXJPcHRpb25zLmxvYWQoaW50ZXJhY3Rpdml0eUVtaXR0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHBsdWdpbiA9IG5ldyBFbWl0dGVyc1BsdWdpbigpO1xuZXhwb3J0cy5FbWl0dGVyc1BsdWdpbiA9IHBsdWdpbjtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FbnVtc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlckNsaWNrTW9kZSA9IHZvaWQgMDtcbnZhciBFbWl0dGVyQ2xpY2tNb2RlO1xuKGZ1bmN0aW9uIChFbWl0dGVyQ2xpY2tNb2RlKSB7XG4gICAgRW1pdHRlckNsaWNrTW9kZVtcImVtaXR0ZXJcIl0gPSBcImVtaXR0ZXJcIjtcbn0pKEVtaXR0ZXJDbGlja01vZGUgPSBleHBvcnRzLkVtaXR0ZXJDbGlja01vZGUgfHwgKGV4cG9ydHMuRW1pdHRlckNsaWNrTW9kZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0VtaXR0ZXJDbGlja01vZGVcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY29uc3QgRW1pdHRlclJhdGVfMSA9IHJlcXVpcmUoXCIuL0VtaXR0ZXJSYXRlXCIpO1xuY29uc3QgRW1pdHRlckxpZmVfMSA9IHJlcXVpcmUoXCIuL0VtaXR0ZXJMaWZlXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNvbnN0IEVtaXR0ZXJTaXplXzEgPSByZXF1aXJlKFwiLi9FbWl0dGVyU2l6ZVwiKTtcbmNvbnN0IEFuaW1hdGFibGVDb2xvcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL09wdGlvbnMvQ2xhc3Nlcy9QYXJ0aWNsZXMvQW5pbWF0YWJsZUNvbG9yXCIpO1xuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYXV0b1BsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IEVudW1zXzEuTW92ZURpcmVjdGlvbi5ub25lO1xuICAgICAgICB0aGlzLmxpZmUgPSBuZXcgRW1pdHRlckxpZmVfMS5FbWl0dGVyTGlmZSgpO1xuICAgICAgICB0aGlzLnJhdGUgPSBuZXcgRW1pdHRlclJhdGVfMS5FbWl0dGVyUmF0ZSgpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmF1dG9QbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b1BsYXkgPSBkYXRhLmF1dG9QbGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gbmV3IEVtaXR0ZXJTaXplXzEuRW1pdHRlclNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZS5sb2FkKGRhdGEuc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGF0YS5kaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saWZlLmxvYWQoZGF0YS5saWZlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICBpZiAoZGF0YS5wYXJ0aWNsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBVdGlsc18xLlV0aWxzLmRlZXBFeHRlbmQoe30sIGRhdGEucGFydGljbGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdGUubG9hZChkYXRhLnJhdGUpO1xuICAgICAgICBpZiAoZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IGRhdGEucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBkYXRhLnBvc2l0aW9uLnksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNwYXduQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3Bhd25Db2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGF3bkNvbG9yID0gbmV3IEFuaW1hdGFibGVDb2xvcl8xLkFuaW1hdGFibGVDb2xvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcGF3bkNvbG9yLmxvYWQoZGF0YS5zcGF3bkNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlckxpZmUgPSB2b2lkIDA7XG5jbGFzcyBFbWl0dGVyTGlmZSB7XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gZGF0YS5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kZWxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gZGF0YS5kZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlckxpZmUgPSBFbWl0dGVyTGlmZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWl0dGVyUmF0ZSA9IHZvaWQgMDtcbmNsYXNzIEVtaXR0ZXJSYXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IDE7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwLjE7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEucXVhbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5xdWFudGl0eSA9IGRhdGEucXVhbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGVsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxheSA9IGRhdGEuZGVsYXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXJSYXRlID0gRW1pdHRlclJhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlclNpemUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0VudW1zXCIpO1xuY2xhc3MgRW1pdHRlclNpemUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBFbnVtc18xLlNpemVNb2RlLnBlcmNlbnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBkYXRhLm1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXJTaXplID0gRW1pdHRlclNpemU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5saW5lQXJyYW5nZW1lbnQgPSB2b2lkIDA7XG52YXIgSW5saW5lQXJyYW5nZW1lbnQ7XG4oZnVuY3Rpb24gKElubGluZUFycmFuZ2VtZW50KSB7XG4gICAgSW5saW5lQXJyYW5nZW1lbnRbXCJlcXVpZGlzdGFudFwiXSA9IFwiZXF1aWRpc3RhbnRcIjtcbiAgICBJbmxpbmVBcnJhbmdlbWVudFtcIm9uZVBlclBvaW50XCJdID0gXCJvbmUtcGVyLXBvaW50XCI7XG4gICAgSW5saW5lQXJyYW5nZW1lbnRbXCJwZXJQb2ludFwiXSA9IFwicGVyLXBvaW50XCI7XG4gICAgSW5saW5lQXJyYW5nZW1lbnRbXCJyYW5kb21MZW5ndGhcIl0gPSBcInJhbmRvbS1sZW5ndGhcIjtcbiAgICBJbmxpbmVBcnJhbmdlbWVudFtcInJhbmRvbVBvaW50XCJdID0gXCJyYW5kb20tcG9pbnRcIjtcbn0pKElubGluZUFycmFuZ2VtZW50ID0gZXhwb3J0cy5JbmxpbmVBcnJhbmdlbWVudCB8fCAoZXhwb3J0cy5JbmxpbmVBcnJhbmdlbWVudCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZVR5cGUgPSB2b2lkIDA7XG52YXIgTW92ZVR5cGU7XG4oZnVuY3Rpb24gKE1vdmVUeXBlKSB7XG4gICAgTW92ZVR5cGVbXCJwYXRoXCJdID0gXCJwYXRoXCI7XG4gICAgTW92ZVR5cGVbXCJyYWRpdXNcIl0gPSBcInJhZGl1c1wiO1xufSkoTW92ZVR5cGUgPSBleHBvcnRzLk1vdmVUeXBlIHx8IChleHBvcnRzLk1vdmVUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlID0gdm9pZCAwO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1wiaW5saW5lXCJdID0gXCJpbmxpbmVcIjtcbiAgICBUeXBlW1wiaW5zaWRlXCJdID0gXCJpbnNpZGVcIjtcbiAgICBUeXBlW1wib3V0c2lkZVwiXSA9IFwib3V0c2lkZVwiO1xuICAgIFR5cGVbXCJub25lXCJdID0gXCJub25lXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbmxpbmVBcnJhbmdlbWVudFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTW92ZVR5cGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1R5cGVcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRyYXcgPSB2b2lkIDA7XG5jb25zdCBEcmF3U3Ryb2tlXzEgPSByZXF1aXJlKFwiLi9EcmF3U3Ryb2tlXCIpO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNDb2xvclwiKTtcbmNsYXNzIERyYXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cm9rZSA9IG5ldyBEcmF3U3Ryb2tlXzEuRHJhd1N0cm9rZSgpO1xuICAgIH1cbiAgICBnZXQgbGluZVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2Uud2lkdGg7XG4gICAgfVxuICAgIHNldCBsaW5lV2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJva2Uud2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlLmNvbG9yO1xuICAgIH1cbiAgICBzZXQgbGluZUNvbG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlLmNvbG9yID0gT3B0aW9uc0NvbG9yXzEuT3B0aW9uc0NvbG9yLmNyZWF0ZSh0aGlzLnN0cm9rZS5jb2xvciwgdmFsdWUpO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJva2UgPSAoX2EgPSBkYXRhLnN0cm9rZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBkYXRhLmxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICB3aWR0aDogZGF0YS5saW5lV2lkdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdHJva2UubG9hZChzdHJva2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EcmF3ID0gRHJhdztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EcmF3U3Ryb2tlID0gdm9pZCAwO1xuY29uc3QgT3B0aW9uc0NvbG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vT3B0aW9ucy9DbGFzc2VzL09wdGlvbnNDb2xvclwiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vVXRpbHNcIik7XG5jbGFzcyBEcmF3U3Ryb2tlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBPcHRpb25zQ29sb3JfMS5PcHRpb25zQ29sb3IoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IDAuNTtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IE9wdGlvbnNDb2xvcl8xLk9wdGlvbnNDb2xvci5jcmVhdGUodGhpcy5jb2xvciwgZGF0YS5jb2xvcik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sb3IudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAoX2EgPSBVdGlsc18xLkNvbG9yVXRpbHMuc3RyaW5nVG9BbHBoYSh0aGlzLmNvbG9yLnZhbHVlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EcmF3U3Ryb2tlID0gRHJhd1N0cm9rZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmxpbmUgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uLy4uL0VudW1zXCIpO1xuY2xhc3MgSW5saW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQub25lUGVyUG9pbnQ7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5hcnJhbmdlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IGRhdGEuYXJyYW5nZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLklubGluZSA9IElubGluZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2NhbFN2ZyA9IHZvaWQgMDtcbmNsYXNzIExvY2FsU3ZnIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gW107XG4gICAgICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gZGF0YS5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZS53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZS53aWR0aCA9IGRhdGEuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2l6ZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gZGF0YS5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxvY2FsU3ZnID0gTG9jYWxTdmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW92ZSA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jbGFzcyBNb3ZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAxMDtcbiAgICAgICAgdGhpcy50eXBlID0gRW51bXNfMS5Nb3ZlVHlwZS5wYXRoO1xuICAgIH1cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb3ZlID0gTW92ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uTWFzayA9IHZvaWQgMDtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi4vLi4vRW51bXNcIik7XG5jb25zdCBEcmF3XzEgPSByZXF1aXJlKFwiLi9EcmF3XCIpO1xuY29uc3QgTW92ZV8xID0gcmVxdWlyZShcIi4vTW92ZVwiKTtcbmNvbnN0IElubGluZV8xID0gcmVxdWlyZShcIi4vSW5saW5lXCIpO1xuY29uc3QgTG9jYWxTdmdfMSA9IHJlcXVpcmUoXCIuL0xvY2FsU3ZnXCIpO1xuY29uc3QgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9VdGlsc1wiKTtcbmNsYXNzIFBvbHlnb25NYXNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kcmF3ID0gbmV3IERyYXdfMS5EcmF3KCk7XG4gICAgICAgIHRoaXMuZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbmV3IElubGluZV8xLklubGluZSgpO1xuICAgICAgICB0aGlzLm1vdmUgPSBuZXcgTW92ZV8xLk1vdmUoKTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IDE7XG4gICAgICAgIHRoaXMudHlwZSA9IEVudW1zXzEuVHlwZS5ub25lO1xuICAgIH1cbiAgICBnZXQgaW5saW5lQXJyYW5nZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlubGluZS5hcnJhbmdlbWVudDtcbiAgICB9XG4gICAgc2V0IGlubGluZUFycmFuZ2VtZW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5saW5lLmFycmFuZ2VtZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhdy5sb2FkKGRhdGEuZHJhdyk7XG4gICAgICAgICAgICBjb25zdCBpbmxpbmUgPSAoX2EgPSBkYXRhLmlubGluZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgIGFycmFuZ2VtZW50OiBkYXRhLmlubGluZUFycmFuZ2VtZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbmxpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lLmxvYWQoaW5saW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92ZS5sb2FkKGRhdGEubW92ZSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZSA9IGRhdGEuc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5lbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlID0gZGF0YS5lbmFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSA9IHRoaXMudHlwZSAhPT0gRW51bXNfMS5UeXBlLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXJsID0gZGF0YS51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTG9jYWxTdmdfMS5Mb2NhbFN2ZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEubG9hZChkYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gVXRpbHNfMS5VdGlscy5kZWVwRXh0ZW5kKHt9LCBkYXRhLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUG9seWdvbk1hc2sgPSBQb2x5Z29uTWFzaztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbHlnb25NYXNrSW5zdGFuY2UgPSB2b2lkIDA7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxzXCIpO1xuY29uc3QgUG9seWdvbk1hc2tfMSA9IHJlcXVpcmUoXCIuL09wdGlvbnMvQ2xhc3Nlcy9Qb2x5Z29uTWFza1wiKTtcbmZ1bmN0aW9uIHBvbHlnb25Cb3VuY2UocGFydGljbGUpIHtcbiAgICBwYXJ0aWNsZS52ZWxvY2l0eS54ID0gcGFydGljbGUudmVsb2NpdHkueSAvIDIgLSBwYXJ0aWNsZS52ZWxvY2l0eS54O1xuICAgIHBhcnRpY2xlLnZlbG9jaXR5LnkgPSBwYXJ0aWNsZS52ZWxvY2l0eS54IC8gMiAtIHBhcnRpY2xlLnZlbG9jaXR5Lnk7XG59XG5mdW5jdGlvbiBkcmF3UG9seWdvbk1hc2soY29udGV4dCwgcmF3RGF0YSwgc3Ryb2tlKSB7XG4gICAgY29uc3QgY29sb3IgPSBVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihzdHJva2UuY29sb3IpO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHJhd0RhdGFbMF0ueCwgcmF3RGF0YVswXS55KTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmF3RGF0YSkge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhpdGVtLngsIGl0ZW0ueSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IoY29sb3IpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlLndpZHRoO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG59XG5mdW5jdGlvbiBkcmF3UG9seWdvbk1hc2tQYXRoKGNvbnRleHQsIHBhdGgsIHN0cm9rZSwgcG9zaXRpb24pIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICBjb25zdCBjb2xvciA9IFV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKHN0cm9rZS5jb2xvcik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGNvbG9yLCBzdHJva2Uub3BhY2l0eSk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2Uud2lkdGg7XG4gICAgY29udGV4dC5zdHJva2UocGF0aCk7XG59XG5mdW5jdGlvbiBwYXJzZVBhdGhzKHBhdGhzLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5lbGVtZW50LnBhdGhTZWdMaXN0O1xuICAgICAgICBjb25zdCBsZW4gPSBzZWdtZW50cy5udW1iZXJPZkl0ZW1zO1xuICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50cy5nZXRJdGVtKGkpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnUGF0aFNlZyA9IHdpbmRvdy5TVkdQYXRoU2VnO1xuICAgICAgICAgICAgc3dpdGNoIChzZWdtZW50LnBhdGhTZWdUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX0FCUzpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fQUJTOlxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fQ1VCSUNfQUJTOlxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX0FCUzpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19BUkNfQUJTOlxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0NVUlZFVE9fQ1VCSUNfU01PT1RIX0FCUzpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfQUJTOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFic1NlZyA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHAueCA9IGFic1NlZy54O1xuICAgICAgICAgICAgICAgICAgICBwLnkgPSBhYnNTZWcueTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19IT1JJWk9OVEFMX0FCUzpcbiAgICAgICAgICAgICAgICAgICAgcC54ID0gc2VnbWVudC54O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19MSU5FVE9fVkVSVElDQUxfQUJTOlxuICAgICAgICAgICAgICAgICAgICBwLnkgPSBzZWdtZW50Lnk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19SRUw6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfTU9WRVRPX1JFTDpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1JFTDpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19SRUw6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQVJDX1JFTDpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DVVJWRVRPX0NVQklDX1NNT09USF9SRUw6XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfU01PT1RIX1JFTDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxTZWcgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICBwLnggKz0gcmVsU2VnLng7XG4gICAgICAgICAgICAgICAgICAgIHAueSArPSByZWxTZWcueTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2Ugc3ZnUGF0aFNlZy5QQVRIU0VHX0xJTkVUT19IT1JJWk9OVEFMX1JFTDpcbiAgICAgICAgICAgICAgICAgICAgcC54ICs9IHNlZ21lbnQueDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfTElORVRPX1ZFUlRJQ0FMX1JFTDpcbiAgICAgICAgICAgICAgICAgICAgcC55ICs9IHNlZ21lbnQueTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzdmdQYXRoU2VnLlBBVEhTRUdfVU5LTk9XTjpcbiAgICAgICAgICAgICAgICBjYXNlIHN2Z1BhdGhTZWcuUEFUSFNFR19DTE9TRVBBVEg6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IHAueCAqIHNjYWxlICsgb2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgeTogcC55ICogc2NhbGUgKyBvZmZzZXQueSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5jbGFzcyBQb2x5Z29uTWFza0luc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGF0aDJEU3VwcG9ydGVkID0gISF3aW5kb3cuUGF0aDJEO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXcgUG9seWdvbk1hc2tfMS5Qb2x5Z29uTWFzaygpO1xuICAgICAgICB0aGlzLnBvbHlnb25NYXNrTW92ZVJhZGl1cyA9IHRoaXMub3B0aW9ucy5tb3ZlLnJhZGl1cyAqIGNvbnRhaW5lci5yZXRpbmEucGl4ZWxSYXRpbztcbiAgICB9XG4gICAgaW5pdEFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2FkKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb2x5Z29uKTtcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb25NYXNrT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMucG9seWdvbk1hc2tNb3ZlUmFkaXVzID0gcG9seWdvbk1hc2tPcHRpb25zLm1vdmUucmFkaXVzICogdGhpcy5jb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAocG9seWdvbk1hc2tPcHRpb25zLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuaW5pdFJhd0RhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghKG9wdGlvbnMuZW5hYmxlICYmIG9wdGlvbnMudHlwZSAhPT0gRW51bXNfMS5UeXBlLm5vbmUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkcmF3VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVkcmF3VGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRyYXdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbml0UmF3RGF0YSh0cnVlKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wYXJ0aWNsZXMucmVkcmF3KCk7XG4gICAgICAgIH0pLCAyNTApO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXc7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhdGhzO1xuICAgIH1cbiAgICBwYXJ0aWNsZXNJbml0aWFsaXphdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlICYmXG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09IEVudW1zXzEuVHlwZS5pbmxpbmUgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmlubGluZS5hcnJhbmdlbWVudCA9PT0gRW51bXNfMS5JbmxpbmVBcnJhbmdlbWVudC5vbmVQZXJQb2ludCB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5saW5lLmFycmFuZ2VtZW50ID09PSBFbnVtc18xLklubGluZUFycmFuZ2VtZW50LnBlclBvaW50KSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3UG9pbnRzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBhcnRpY2xlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCEob3B0aW9ucy5lbmFibGUgJiYgKChfYiA9IChfYSA9IHRoaXMucmF3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMuZGVlcEV4dGVuZCh7fSwgcG9zaXRpb24gPyBwb3NpdGlvbiA6IHRoaXMucmFuZG9tUG9pbnQoKSk7XG4gICAgfVxuICAgIHBhcnRpY2xlQm91bmNlKHBhcnRpY2xlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLmVuYWJsZSAmJiBvcHRpb25zLnR5cGUgIT09IEVudW1zXzEuVHlwZS5ub25lICYmIG9wdGlvbnMudHlwZSAhPT0gRW51bXNfMS5UeXBlLmlubGluZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrSW5zaWRlUG9seWdvbihwYXJ0aWNsZS5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHBvbHlnb25Cb3VuY2UocGFydGljbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZW5hYmxlICYmIG9wdGlvbnMudHlwZSA9PT0gRW51bXNfMS5UeXBlLmlubGluZSAmJiBwYXJ0aWNsZS5pbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKHBhcnRpY2xlLmluaXRpYWxQb3NpdGlvbiwgcGFydGljbGUuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA+IHRoaXMucG9seWdvbk1hc2tNb3ZlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgcG9seWdvbkJvdW5jZShwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGlja1Bvc2l0aW9uVmFsaWQocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmVuYWJsZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy50eXBlICE9PSBFbnVtc18xLlR5cGUubm9uZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy50eXBlICE9PSBFbnVtc18xLlR5cGUuaW5saW5lICYmXG4gICAgICAgICAgICB0aGlzLmNoZWNrSW5zaWRlUG9seWdvbihwb3NpdGlvbikpO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLnBhdGhzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBvbHlnb25EcmF3ID0gb3B0aW9ucy5kcmF3O1xuICAgICAgICBpZiAoIShvcHRpb25zLmVuYWJsZSAmJiBwb2x5Z29uRHJhdy5lbmFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3RGF0YSA9IHRoaXMucmF3O1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5wYXRocykge1xuICAgICAgICAgICAgY29uc3QgcGF0aDJkID0gcGF0aC5wYXRoMmQ7XG4gICAgICAgICAgICBjb25zdCBwYXRoMmRTdXBwb3J0ZWQgPSB0aGlzLnBhdGgyRFN1cHBvcnRlZDtcbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgyZFN1cHBvcnRlZCAmJiBwYXRoMmQgJiYgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBkcmF3UG9seWdvbk1hc2tQYXRoKGNvbnRleHQsIHBhdGgyZCwgcG9seWdvbkRyYXcuc3Ryb2tlLCB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYXdEYXRhKSB7XG4gICAgICAgICAgICAgICAgZHJhd1BvbHlnb25NYXNrKGNvbnRleHQsIHJhd0RhdGEsIHBvbHlnb25EcmF3LnN0cm9rZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbnNpZGVQb2x5Z29uKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlIHx8IG9wdGlvbnMudHlwZSA9PT0gRW51bXNfMS5UeXBlLm5vbmUgfHwgb3B0aW9ucy50eXBlID09PSBFbnVtc18xLlR5cGUuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHNfMS5Db25zdGFudHMubm9Qb2x5Z29uRm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSBjb250YWluZXIuY2FudmFzLnNpemU7XG4gICAgICAgIGNvbnN0IHggPSAoX2EgPSBwb3NpdGlvbiA9PT0gbnVsbCB8fCBwb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9zaXRpb24ueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTWF0aC5yYW5kb20oKSAqIGNhbnZhc1NpemUud2lkdGg7XG4gICAgICAgIGNvbnN0IHkgPSAoX2IgPSBwb3NpdGlvbiA9PT0gbnVsbCB8fCBwb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9zaXRpb24ueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTWF0aC5yYW5kb20oKSAqIGNhbnZhc1NpemUuaGVpZ2h0O1xuICAgICAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5yYXcubGVuZ3RoIC0gMTsgaSA8IHRoaXMucmF3Lmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGkgPSB0aGlzLnJhd1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBqID0gdGhpcy5yYXdbal07XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSBwaS55ID4geSAhPT0gcGoueSA+IHkgJiYgeCA8ICgocGoueCAtIHBpLngpICogKHkgLSBwaS55KSkgLyAocGoueSAtIHBpLnkpICsgcGkueDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLnR5cGUgPT09IEVudW1zXzEuVHlwZS5pbnNpZGUgPyBpbnNpZGUgOiBvcHRpb25zLnR5cGUgPT09IEVudW1zXzEuVHlwZS5vdXRzaWRlID8gIWluc2lkZSA6IGZhbHNlO1xuICAgIH1cbiAgICBwYXJzZVN2Z1BhdGgoeG1sLCBmb3JjZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZm9yY2VEb3dubG9hZCA9IGZvcmNlICE9PSBudWxsICYmIGZvcmNlICE9PSB2b2lkIDAgPyBmb3JjZSA6IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wYXRocyAhPT0gdW5kZWZpbmVkICYmICFmb3JjZURvd25sb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYXc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3QgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsIFwiaW1hZ2Uvc3ZnK3htbFwiKTtcbiAgICAgICAgY29uc3Qgc3ZnID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdO1xuICAgICAgICBsZXQgc3ZnUGF0aHMgPSBzdmcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXRoXCIpO1xuICAgICAgICBpZiAoIXN2Z1BhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3ZnUGF0aHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdmdQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHN2Z1BhdGhzLml0ZW0oaSk7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcGF0aC5nZXRUb3RhbExlbmd0aCgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB4UmF0aW8gPSBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5zY2FsZSAvIHB4UmF0aW87XG4gICAgICAgIHRoaXMuZGltZW5zaW9uLndpZHRoID0gcGFyc2VGbG9hdCgoX2EgPSBzdmcuZ2V0QXR0cmlidXRlKFwid2lkdGhcIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiMFwiKSAqIHNjYWxlO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbi5oZWlnaHQgPSBwYXJzZUZsb2F0KChfYiA9IHN2Zy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiMFwiKSAqIHNjYWxlO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IChfYyA9IG9wdGlvbnMucG9zaXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHtcbiAgICAgICAgICAgIHg6IDUwLFxuICAgICAgICAgICAgeTogNTAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgICAgICAgeDogKGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCAqIHBvc2l0aW9uLngpIC8gKDEwMCAqIHB4UmF0aW8pIC0gdGhpcy5kaW1lbnNpb24ud2lkdGggLyAyLFxuICAgICAgICAgICAgeTogKGNvbnRhaW5lci5jYW52YXMuc2l6ZS5oZWlnaHQgKiBwb3NpdGlvbi55KSAvICgxMDAgKiBweFJhdGlvKSAtIHRoaXMuZGltZW5zaW9uLmhlaWdodCAvIDIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJzZVBhdGhzKHRoaXMucGF0aHMsIHNjYWxlLCB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIGRvd25sb2FkU3ZnUGF0aChzdmdVcmwsIGZvcmNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gc3ZnVXJsIHx8IG9wdGlvbnMudXJsO1xuICAgICAgICAgICAgY29uc3QgZm9yY2VEb3dubG9hZCA9IGZvcmNlICE9PSBudWxsICYmIGZvcmNlICE9PSB2b2lkIDAgPyBmb3JjZSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF1cmwgfHwgKHRoaXMucGF0aHMgIT09IHVuZGVmaW5lZCAmJiAhZm9yY2VEb3dubG9hZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXEgPSB5aWVsZCBmZXRjaCh1cmwpO1xuICAgICAgICAgICAgaWYgKCFyZXEub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0c1BhcnRpY2xlcyBFcnJvciAtIEVycm9yIG9jY3VycmVkIGR1cmluZyBwb2x5Z29uIG1hc2sgZG93bmxvYWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN2Z1BhdGgoeWllbGQgcmVxLnRleHQoKSwgZm9yY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhd1BvaW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnJhdykge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucGFydGljbGVzLmFkZFBhcnRpY2xlKHtcbiAgICAgICAgICAgICAgICB4OiBpdGVtLngsXG4gICAgICAgICAgICAgICAgeTogaXRlbS55LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmFuZG9tUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBsZXQgcG9zaXRpb247XG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IEVudW1zXzEuVHlwZS5pbmxpbmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5pbmxpbmUuYXJyYW5nZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQucmFuZG9tUG9pbnQ6XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRSYW5kb21Qb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQucmFuZG9tTGVuZ3RoOlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UmFuZG9tUG9pbnRCeUxlbmd0aCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEVudW1zXzEuSW5saW5lQXJyYW5nZW1lbnQuZXF1aWRpc3RhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50QnlJbmRleChjb250YWluZXIucGFydGljbGVzLmNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBFbnVtc18xLklubGluZUFycmFuZ2VtZW50Lm9uZVBlclBvaW50OlxuICAgICAgICAgICAgICAgIGNhc2UgRW51bXNfMS5JbmxpbmVBcnJhbmdlbWVudC5wZXJQb2ludDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRCeUluZGV4KGNvbnRhaW5lci5wYXJ0aWNsZXMuY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIGNvbnRhaW5lci5jYW52YXMuc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJhbmRvbSgpICogY29udGFpbmVyLmNhbnZhcy5zaXplLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJbnNpZGVQb2x5Z29uKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFuZG9tUG9pbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSYW5kb21Qb2ludCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhdyB8fCAhdGhpcy5yYXcubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHNfMS5Db25zdGFudHMubm9Qb2x5Z29uRGF0YUxvYWRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29vcmRzID0gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KHRoaXMucmF3KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNvb3Jkcy54LFxuICAgICAgICAgICAgeTogY29vcmRzLnksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJhbmRvbVBvaW50QnlMZW5ndGgoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMucmF3IHx8ICF0aGlzLnJhdy5sZW5ndGggfHwgISgoX2EgPSB0aGlzLnBhdGhzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzXzEuQ29uc3RhbnRzLm5vUG9seWdvbkRhdGFMb2FkZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBVdGlsc18xLlV0aWxzLml0ZW1Gcm9tQXJyYXkodGhpcy5wYXRocyk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGF0aC5sZW5ndGgpICsgMTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXRoLmVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aChkaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwb2ludC54ICogb3B0aW9ucy5zY2FsZSArICgoKF9iID0gdGhpcy5vZmZzZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi54KSB8fCAwKSxcbiAgICAgICAgICAgIHk6IHBvaW50LnkgKiBvcHRpb25zLnNjYWxlICsgKCgoX2MgPSB0aGlzLm9mZnNldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnkpIHx8IDApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRFcXVpZGlzdGFudFBvaW50QnlJbmRleChpbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICBjb25zdCBwb2x5Z29uTWFza09wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy5yYXcgfHwgIXRoaXMucmF3Lmxlbmd0aCB8fCAhKChfYSA9IHRoaXMucGF0aHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzXzEuQ29uc3RhbnRzLm5vUG9seWdvbkRhdGFMb2FkZWQpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IHRoaXMucGF0aHMucmVkdWNlKCh0b3QsIHBhdGgpID0+IHRvdCArIHBhdGgubGVuZ3RoLCAwKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0b3RhbExlbmd0aCAvIG9wdGlvbnMucGFydGljbGVzLm51bWJlci52YWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhEaXN0YW5jZSA9IGRpc3RhbmNlICogaW5kZXggLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAocGF0aERpc3RhbmNlIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwYXRoLmVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aChwYXRoRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoKF9iID0gcG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50LngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApICogcG9seWdvbk1hc2tPcHRpb25zLnNjYWxlICsgKChfZCA9IChfYyA9IHRoaXMub2Zmc2V0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCksXG4gICAgICAgICAgICB5OiAoKF9lID0gcG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvaW50LnkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDApICogcG9seWdvbk1hc2tPcHRpb25zLnNjYWxlICsgKChfZyA9IChfZiA9IHRoaXMub2Zmc2V0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YueSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFBvaW50QnlJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucmF3IHx8ICF0aGlzLnJhdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlsc18xLkNvbnN0YW50cy5ub1BvbHlnb25EYXRhTG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZHMgPSB0aGlzLnJhd1tpbmRleCAlIHRoaXMucmF3Lmxlbmd0aF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgIHk6IGNvb3Jkcy55LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVQYXRoMkQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy5wYXRoMkRTdXBwb3J0ZWQgfHwgISgoX2EgPSB0aGlzLnBhdGhzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoRGF0YSA9IChfYiA9IHBhdGguZWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldEF0dHJpYnV0ZShcImRcIik7XG4gICAgICAgICAgICBpZiAocGF0aERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoMmQgPSBuZXcgUGF0aDJEKHBhdGhEYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRyaXggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKS5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbWF0cml4LnNjYWxlKG9wdGlvbnMuc2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbFBhdGguYWRkUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFBhdGguYWRkUGF0aChwYXRoMmQsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucGF0aDJkID0gZmluYWxQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdGgucGF0aDJkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXRoLnBhdGgyZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoLnBhdGgyZCB8fCAhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGgucGF0aDJkID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgICAgcGF0aC5wYXRoMmQubW92ZVRvKHRoaXMucmF3WzBdLngsIHRoaXMucmF3WzBdLnkpO1xuICAgICAgICAgICAgdGhpcy5yYXcuZm9yRWFjaCgocG9zLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBwYXRoLnBhdGgyZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxpbmVUbyhwb3MueCwgcG9zLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGF0aC5wYXRoMmQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFJhd0RhdGEoZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9IHlpZWxkIHRoaXMuZG93bmxvYWRTdmdQYXRoKG9wdGlvbnMudXJsLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICAgICAgICAgIGxldCBzdmc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkYXRhLnBhdGggaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhLnBhdGgubWFwKCh0KSA9PiBgPHBhdGggZD1cIiR7dH1cIiAvPmApLmpvaW4oXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYDxwYXRoIGQ9XCIke2RhdGEucGF0aH1cIiAvPmA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZXMgPSAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJztcbiAgICAgICAgICAgICAgICAgICAgc3ZnID0gYDxzdmcgJHtuYW1lc3BhY2VzfSB3aWR0aD1cIiR7ZGF0YS5zaXplLndpZHRofVwiIGhlaWdodD1cIiR7ZGF0YS5zaXplLmhlaWdodH1cIj4ke3BhdGh9PC9zdmc+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN2ZyA9IGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmF3ID0gdGhpcy5wYXJzZVN2Z1BhdGgoc3ZnLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBhdGgyRCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBvbHlnb25NYXNrSW5zdGFuY2UgPSBQb2x5Z29uTWFza0luc3RhbmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9seWdvbk1hc2tQbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBQb2x5Z29uTWFza0luc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uTWFza0luc3RhbmNlXCIpO1xuY29uc3QgUG9seWdvbk1hc2tfMSA9IHJlcXVpcmUoXCIuL09wdGlvbnMvQ2xhc3Nlcy9Qb2x5Z29uTWFza1wiKTtcbmNvbnN0IEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbmNsYXNzIFBvbHlnb25NYXNrUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pZCA9IFwicG9seWdvbk1hc2tcIjtcbiAgICB9XG4gICAgZ2V0UGx1Z2luKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25NYXNrSW5zdGFuY2VfMS5Qb2x5Z29uTWFza0luc3RhbmNlKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIG5lZWRzUGx1Z2luKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9seWdvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuYWJsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKCgoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9seWdvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUpICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5wb2x5Z29uLnR5cGUgIT09IEVudW1zXzEuVHlwZS5ub25lKTtcbiAgICB9XG4gICAgbG9hZE9wdGlvbnMob3B0aW9ucywgc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWVkc1BsdWdpbihzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9uc0Nhc3QgPSBvcHRpb25zO1xuICAgICAgICBsZXQgcG9seWdvbk9wdGlvbnMgPSBvcHRpb25zQ2FzdC5wb2x5Z29uO1xuICAgICAgICBpZiAoKHBvbHlnb25PcHRpb25zID09PSBudWxsIHx8IHBvbHlnb25PcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2x5Z29uT3B0aW9ucy5sb2FkKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zQ2FzdC5wb2x5Z29uID0gcG9seWdvbk9wdGlvbnMgPSBuZXcgUG9seWdvbk1hc2tfMS5Qb2x5Z29uTWFzaygpO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb25PcHRpb25zLmxvYWQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLnBvbHlnb24pO1xuICAgIH1cbn1cbmNvbnN0IHBsdWdpbiA9IG5ldyBQb2x5Z29uTWFza1BsdWdpbigpO1xuZXhwb3J0cy5Qb2x5Z29uTWFza1BsdWdpbiA9IHBsdWdpbjtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FbnVtc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2lyY2xlRHJhd2VyID0gdm9pZCAwO1xuY2xhc3MgQ2lyY2xlRHJhd2VyIHtcbiAgICBnZXRTaWRlc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gMTI7XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCwgcGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaXJjbGVEcmF3ZXIgPSBDaXJjbGVEcmF3ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbWFnZURyYXdlciA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vVXRpbHNcIik7XG5jb25zdCBFbnVtc18xID0gcmVxdWlyZShcIi4uL0VudW1zXCIpO1xuY2xhc3MgSW1hZ2VEcmF3ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIH1cbiAgICBnZXRTaWRlc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gMTI7XG4gICAgfVxuICAgIGdldEltYWdlcyhjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVySW1hZ2VzID0gdGhpcy5pbWFnZXMuZmlsdGVyKCh0KSA9PiB0LmlkID09PSBjb250YWluZXIuaWQpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lckltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBjb250YWluZXIuaWQsXG4gICAgICAgICAgICAgICAgaW1hZ2VzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1hZ2VzKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lckltYWdlc1swXTtcbiAgICB9XG4gICAgYWRkSW1hZ2UoY29udGFpbmVyLCBpbWFnZSkge1xuICAgICAgICBjb25zdCBjb250YWluZXJJbWFnZXMgPSB0aGlzLmdldEltYWdlcyhjb250YWluZXIpO1xuICAgICAgICBjb250YWluZXJJbWFnZXMgPT09IG51bGwgfHwgY29udGFpbmVySW1hZ2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250YWluZXJJbWFnZXMuaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgIH1cbiAgICBpbml0KGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzaGFwZU9wdGlvbnMgPSBvcHRpb25zLnBhcnRpY2xlcy5zaGFwZTtcbiAgICAgICAgICAgIGlmICghVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5TaGFwZVR5cGUuaW1hZ2UsIHNoYXBlT3B0aW9ucy50eXBlKSAmJlxuICAgICAgICAgICAgICAgICFVdGlsc18xLlV0aWxzLmlzSW5BcnJheShFbnVtc18xLlNoYXBlVHlwZS5pbWFnZXMsIHNoYXBlT3B0aW9ucy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGltYWdlT3B0aW9ucyA9IChfYSA9IHNoYXBlT3B0aW9ucy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmltYWdlc10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNoYXBlT3B0aW9ucy5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmltYWdlXTtcbiAgICAgICAgICAgIGlmIChpbWFnZU9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uc0ltYWdlIG9mIGltYWdlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmxvYWRJbWFnZVNoYXBlKGNvbnRhaW5lciwgb3B0aW9uc0ltYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmxvYWRJbWFnZVNoYXBlKGNvbnRhaW5lciwgaW1hZ2VPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgfVxuICAgIGxvYWRJbWFnZVNoYXBlKGNvbnRhaW5lciwgaW1hZ2VTaGFwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlU2hhcGUucmVwbGFjZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgID8geWllbGQgVXRpbHNfMS5VdGlscy5kb3dubG9hZFN2Z0ltYWdlKGltYWdlU2hhcGUuc3JjKVxuICAgICAgICAgICAgICAgICAgICA6IHlpZWxkIFV0aWxzXzEuVXRpbHMubG9hZEltYWdlKGltYWdlU2hhcGUuc3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbWFnZShjb250YWluZXIsIGltYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHRzUGFydGljbGVzIGVycm9yIC0gJHtpbWFnZVNoYXBlLnNyY30gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2UgPSBwYXJ0aWNsZS5pbWFnZTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IChfYSA9IGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxlbWVudDtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF0aW8gPSAoX2IgPSBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UucmF0aW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XG4gICAgICAgIGNvbnN0IHBvcyA9IHtcbiAgICAgICAgICAgIHg6IC1yYWRpdXMsXG4gICAgICAgICAgICB5OiAtcmFkaXVzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIShpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuZGF0YS5zdmdEYXRhKSB8fCAhKGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5yZXBsYWNlQ29sb3IpKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVtZW50LCBwb3MueCwgcG9zLnksIHJhZGl1cyAqIDIsIChyYWRpdXMgKiAyKSAvIHJhdGlvKTtcbiAgICAgICAgaWYgKCEoaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLmRhdGEuc3ZnRGF0YSkgfHwgIShpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UucmVwbGFjZUNvbG9yKSkge1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkltYWdlRHJhd2VyID0gSW1hZ2VEcmF3ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGluZURyYXdlciA9IHZvaWQgMDtcbmNsYXNzIExpbmVEcmF3ZXIge1xuICAgIGdldFNpZGVzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLXJhZGl1cyAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCByYWRpdXMgLyAyKTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmVEcmF3ZXIgPSBMaW5lRHJhd2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbHlnb25EcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBQb2x5Z29uRHJhd2VyQmFzZV8xID0gcmVxdWlyZShcIi4vUG9seWdvbkRyYXdlckJhc2VcIik7XG5jbGFzcyBQb2x5Z29uRHJhd2VyIGV4dGVuZHMgUG9seWdvbkRyYXdlckJhc2VfMS5Qb2x5Z29uRHJhd2VyQmFzZSB7XG4gICAgZ2V0U2lkZXNEYXRhKHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcG9seWdvbiA9IHBhcnRpY2xlLnNoYXBlRGF0YTtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSAoX2IgPSAoX2EgPSBwb2x5Z29uID09PSBudWxsIHx8IHBvbHlnb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvbHlnb24uc2lkZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvbHlnb24gPT09IG51bGwgfHwgcG9seWdvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9seWdvbi5uYl9zaWRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogNTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgICAgICAgZGVub21pbmF0b3I6IDEsXG4gICAgICAgICAgICAgICAgbnVtZXJhdG9yOiBzaWRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IChyYWRpdXMgKiAyLjY2KSAvIChzaWRlcyAvIDMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDZW50ZXIocGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXNDb3VudChwYXJ0aWNsZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAtcmFkaXVzIC8gKHNpZGVzIC8gMy41KSxcbiAgICAgICAgICAgIHk6IC1yYWRpdXMgLyAoMi42NiAvIDMuNSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Qb2x5Z29uRHJhd2VyID0gUG9seWdvbkRyYXdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2x5Z29uRHJhd2VyQmFzZSA9IHZvaWQgMDtcbmNsYXNzIFBvbHlnb25EcmF3ZXJCYXNlIHtcbiAgICBnZXRTaWRlc0NvdW50KHBhcnRpY2xlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBvbHlnb24gPSBwYXJ0aWNsZS5zaGFwZURhdGE7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBwb2x5Z29uID09PSBudWxsIHx8IHBvbHlnb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvbHlnb24uc2lkZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvbHlnb24gPT09IG51bGwgfHwgcG9seWdvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9seWdvbi5uYl9zaWRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogNTtcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5nZXRDZW50ZXIocGFydGljbGUsIHJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHNpZGUgPSB0aGlzLmdldFNpZGVzRGF0YShwYXJ0aWNsZSwgcmFkaXVzKTtcbiAgICAgICAgY29uc3Qgc2lkZUNvdW50ID0gc2lkZS5jb3VudC5udW1lcmF0b3IgKiBzaWRlLmNvdW50LmRlbm9taW5hdG9yO1xuICAgICAgICBjb25zdCBkZWNpbWFsU2lkZXMgPSBzaWRlLmNvdW50Lm51bWVyYXRvciAvIHNpZGUuY291bnQuZGVub21pbmF0b3I7XG4gICAgICAgIGNvbnN0IGludGVyaW9yQW5nbGVEZWdyZWVzID0gKDE4MCAqIChkZWNpbWFsU2lkZXMgLSAyKSkgLyBkZWNpbWFsU2lkZXM7XG4gICAgICAgIGNvbnN0IGludGVyaW9yQW5nbGUgPSBNYXRoLlBJIC0gKE1hdGguUEkgKiBpbnRlcmlvckFuZ2xlRGVncmVlcykgLyAxODA7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oc2lkZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoc2lkZS5sZW5ndGgsIDApO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoaW50ZXJpb3JBbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBvbHlnb25EcmF3ZXJCYXNlID0gUG9seWdvbkRyYXdlckJhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3F1YXJlRHJhd2VyID0gdm9pZCAwO1xuY2xhc3MgU3F1YXJlRHJhd2VyIHtcbiAgICBnZXRTaWRlc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZHJhdyhjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQucmVjdCgtcmFkaXVzLCAtcmFkaXVzLCByYWRpdXMgKiAyLCByYWRpdXMgKiAyKTtcbiAgICB9XG59XG5leHBvcnRzLlNxdWFyZURyYXdlciA9IFNxdWFyZURyYXdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFyRHJhd2VyID0gdm9pZCAwO1xuY2xhc3MgU3RhckRyYXdlciB7XG4gICAgZ2V0U2lkZXNDb3VudChwYXJ0aWNsZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzdGFyID0gcGFydGljbGUuc2hhcGVEYXRhO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gc3RhciA9PT0gbnVsbCB8fCBzdGFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFyLnNpZGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGFyID09PSBudWxsIHx8IHN0YXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXIubmJfc2lkZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDU7XG4gICAgfVxuICAgIGRyYXcoY29udGV4dCwgcGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBwYXJ0aWNsZS5zaGFwZURhdGE7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gdGhpcy5nZXRTaWRlc0NvdW50KHBhcnRpY2xlKTtcbiAgICAgICAgY29uc3QgaW5zZXQgPSAoX2EgPSBzdGFyID09PSBudWxsIHx8IHN0YXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXIuaW5zZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDI7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSByYWRpdXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHQucm90YXRlKE1hdGguUEkgLyBzaWRlcyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAwIC0gcmFkaXVzICogaW5zZXQpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoTWF0aC5QSSAvIHNpZGVzKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIDAgLSByYWRpdXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdGFyRHJhd2VyID0gU3RhckRyYXdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRleHREcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBVdGlsc18xID0gcmVxdWlyZShcIi4uL1V0aWxzXCIpO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbmNsYXNzIFRleHREcmF3ZXIge1xuICAgIGdldFNpZGVzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gICAgaW5pdChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zO1xuICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNJbkFycmF5KEVudW1zXzEuU2hhcGVUeXBlLmNoYXIsIG9wdGlvbnMucGFydGljbGVzLnNoYXBlLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgVXRpbHNfMS5VdGlscy5pc0luQXJyYXkoRW51bXNfMS5TaGFwZVR5cGUuY2hhcmFjdGVyLCBvcHRpb25zLnBhcnRpY2xlcy5zaGFwZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlT3B0aW9ucyA9ICgoX2EgPSBvcHRpb25zLnBhcnRpY2xlcy5zaGFwZS5vcHRpb25zW0VudW1zXzEuU2hhcGVUeXBlLmNoYXJhY3Rlcl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMucGFydGljbGVzLnNoYXBlLm9wdGlvbnNbRW51bXNfMS5TaGFwZVR5cGUuY2hhcl0pO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZU9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXJhY3RlciBvZiBzaGFwZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFV0aWxzXzEuVXRpbHMubG9hZEZvbnQoY2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBVdGlsc18xLlV0aWxzLmxvYWRGb250KHNoYXBlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyID0gcGFydGljbGUuc2hhcGVEYXRhO1xuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0RGF0YSA9IGNoYXJhY3Rlci52YWx1ZTtcbiAgICAgICAgaWYgKHRleHREYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0UGFydGljbGUgPSBwYXJ0aWNsZTtcbiAgICAgICAgaWYgKHRleHRQYXJ0aWNsZS50ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRleHRQYXJ0aWNsZS50ZXh0ID1cbiAgICAgICAgICAgICAgICB0ZXh0RGF0YSBpbnN0YW5jZW9mIEFycmF5ID8gVXRpbHNfMS5VdGlscy5pdGVtRnJvbUFycmF5KHRleHREYXRhLCBwYXJ0aWNsZS5yYW5kb21JbmRleERhdGEpIDogdGV4dERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IHRleHRQYXJ0aWNsZS50ZXh0O1xuICAgICAgICBjb25zdCBzdHlsZSA9IGNoYXJhY3Rlci5zdHlsZTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gY2hhcmFjdGVyLndlaWdodDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQocmFkaXVzKSAqIDI7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBjaGFyYWN0ZXIuZm9udDtcbiAgICAgICAgY29uc3QgZmlsbCA9IHBhcnRpY2xlLmZpbGw7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSAodGV4dC5sZW5ndGggKiByYWRpdXMpIC8gMjtcbiAgICAgICAgY29udGV4dC5mb250ID0gYCR7c3R5bGV9ICR7d2VpZ2h0fSAke3NpemV9cHggXCIke2ZvbnR9XCJgO1xuICAgICAgICBjb25zdCBwb3MgPSB7XG4gICAgICAgICAgICB4OiAtb2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IHJhZGl1cyAvIDIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHBvcy54LCBwb3MueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGV4dERyYXdlciA9IFRleHREcmF3ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJpYW5nbGVEcmF3ZXIgPSB2b2lkIDA7XG5jb25zdCBQb2x5Z29uRHJhd2VyQmFzZV8xID0gcmVxdWlyZShcIi4vUG9seWdvbkRyYXdlckJhc2VcIik7XG5jbGFzcyBUcmlhbmdsZURyYXdlciBleHRlbmRzIFBvbHlnb25EcmF3ZXJCYXNlXzEuUG9seWdvbkRyYXdlckJhc2Uge1xuICAgIGdldFNpZGVzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBnZXRTaWRlc0RhdGEocGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICAgICAgICBkZW5vbWluYXRvcjogMixcbiAgICAgICAgICAgICAgICBudW1lcmF0b3I6IDMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiByYWRpdXMgKiAyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDZW50ZXIocGFydGljbGUsIHJhZGl1cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogLXJhZGl1cyxcbiAgICAgICAgICAgIHk6IHJhZGl1cyAvIDEuNjYsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UcmlhbmdsZURyYXdlciA9IFRyaWFuZ2xlRHJhd2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmFuZ2VWYWx1ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVjdXJzaXZlUGFydGlhbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU2hhcGVEYXRhXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TaGFwZURyYXdlckZ1bmN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU2luZ2xlT3JNdWx0aXBsZVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FudmFzVXRpbHMgPSB2b2lkIDA7XG5jb25zdCBDb2xvclV0aWxzXzEgPSByZXF1aXJlKFwiLi9Db2xvclV0aWxzXCIpO1xuY29uc3QgTnVtYmVyVXRpbHNfMSA9IHJlcXVpcmUoXCIuL051bWJlclV0aWxzXCIpO1xuZnVuY3Rpb24gZHJhd0xpbmUoY29udGV4dCwgYmVnaW4sIGVuZCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYmVnaW4ueCwgYmVnaW4ueSk7XG4gICAgY29udGV4dC5saW5lVG8oZW5kLngsIGVuZC55KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGNvbnRleHQsIHAxLCBwMiwgcDMpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgIGNvbnRleHQubGluZVRvKHAyLngsIHAyLnkpO1xuICAgIGNvbnRleHQubGluZVRvKHAzLngsIHAzLnkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59XG5jbGFzcyBDYW52YXNVdGlscyB7XG4gICAgc3RhdGljIHBhaW50QmFzZShjb250ZXh0LCBkaW1lbnNpb24sIGJhc2VDb2xvcikge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBiYXNlQ29sb3IgIT09IG51bGwgJiYgYmFzZUNvbG9yICE9PSB2b2lkIDAgPyBiYXNlQ29sb3IgOiBcInJnYmEoMCwwLDAsMClcIjtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgc3RhdGljIGNsZWFyKGNvbnRleHQsIGRpbWVuc2lvbikge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd0xpbmtMaW5lKGNvbnRleHQsIHdpZHRoLCBiZWdpbiwgZW5kLCBtYXhEaXN0YW5jZSwgY2FudmFzU2l6ZSwgd2FycCwgYmFja2dyb3VuZE1hc2ssIGNvbXBvc2l0ZSwgY29sb3JMaW5lLCBvcGFjaXR5LCBzaGFkb3cpIHtcbiAgICAgICAgbGV0IGRyYXduID0gZmFsc2U7XG4gICAgICAgIGlmIChOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLmdldERpc3RhbmNlKGJlZ2luLCBlbmQpIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICBkcmF3TGluZShjb250ZXh0LCBiZWdpbiwgZW5kKTtcbiAgICAgICAgICAgIGRyYXduID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YXJwKSB7XG4gICAgICAgICAgICBsZXQgcGkxO1xuICAgICAgICAgICAgbGV0IHBpMjtcbiAgICAgICAgICAgIGNvbnN0IGVuZE5FID0ge1xuICAgICAgICAgICAgICAgIHg6IGVuZC54IC0gY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiBlbmQueSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkMSA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKGJlZ2luLCBlbmRORSk7XG4gICAgICAgICAgICBpZiAoZDEuZGlzdGFuY2UgPD0gbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5aSA9IGJlZ2luLnkgLSAoZDEuZHkgLyBkMS5keCkgKiBiZWdpbi54O1xuICAgICAgICAgICAgICAgIHBpMSA9IHsgeDogMCwgeTogeWkgfTtcbiAgICAgICAgICAgICAgICBwaTIgPSB7IHg6IGNhbnZhc1NpemUud2lkdGgsIHk6IHlpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRTVyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZW5kLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGVuZC55IC0gY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBkMiA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKGJlZ2luLCBlbmRTVyk7XG4gICAgICAgICAgICAgICAgaWYgKGQyLmRpc3RhbmNlIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlpID0gYmVnaW4ueSAtIChkMi5keSAvIGQyLmR4KSAqIGJlZ2luLng7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhpID0gLXlpIC8gKGQyLmR5IC8gZDIuZHgpO1xuICAgICAgICAgICAgICAgICAgICBwaTEgPSB7IHg6IHhpLCB5OiAwIH07XG4gICAgICAgICAgICAgICAgICAgIHBpMiA9IHsgeDogeGksIHk6IGNhbnZhc1NpemUuaGVpZ2h0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRTRSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGVuZC54IC0gY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGVuZC55IC0gY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQzID0gTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5nZXREaXN0YW5jZXMoYmVnaW4sIGVuZFNFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQzLmRpc3RhbmNlIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5aSA9IGJlZ2luLnkgLSAoZDMuZHkgLyBkMy5keCkgKiBiZWdpbi54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGkgPSAteWkgLyAoZDMuZHkgLyBkMy5keCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaTEgPSB7IHg6IHhpLCB5OiB5aSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGkyID0geyB4OiBwaTEueCArIGNhbnZhc1NpemUud2lkdGgsIHk6IHBpMS55ICsgY2FudmFzU2l6ZS5oZWlnaHQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaTEgJiYgcGkyKSB7XG4gICAgICAgICAgICAgICAgZHJhd0xpbmUoY29udGV4dCwgYmVnaW4sIHBpMSk7XG4gICAgICAgICAgICAgICAgZHJhd0xpbmUoY29udGV4dCwgZW5kLCBwaTIpO1xuICAgICAgICAgICAgICAgIGRyYXduID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYXduKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICAgICAgaWYgKGJhY2tncm91bmRNYXNrKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGNvbG9yTGluZSwgb3BhY2l0eSk7XG4gICAgICAgIGlmIChzaGFkb3cuZW5hYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkb3dDb2xvciA9IENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2Ioc2hhZG93LmNvbG9yKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2Ioc2hhZG93Q29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBkcmF3TGlua1RyaWFuZ2xlKGNvbnRleHQsIHBvczEsIHBvczIsIHBvczMsIGJhY2tncm91bmRNYXNrLCBjb21wb3NpdGUsIGNvbG9yVHJpYW5nbGUsIG9wYWNpdHlUcmlhbmdsZSkge1xuICAgICAgICBkcmF3VHJpYW5nbGUoY29udGV4dCwgcG9zMSwgcG9zMiwgcG9zMyk7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kTWFzaykge1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IoY29sb3JUcmlhbmdsZSwgb3BhY2l0eVRyaWFuZ2xlKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIHN0YXRpYyBkcmF3Q29ubmVjdExpbmUoY29udGV4dCwgd2lkdGgsIGxpbmVTdHlsZSwgYmVnaW4sIGVuZCkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgZHJhd0xpbmUoY29udGV4dCwgYmVnaW4sIGVuZCk7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBsaW5lU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ3JhZGllbnQoY29udGV4dCwgcDEsIHAyLCBvcGFjaXR5KSB7XG4gICAgICAgIGNvbnN0IGdyYWRTdG9wID0gTWF0aC5mbG9vcihwMi5nZXRSYWRpdXMoKSAvIHAxLmdldFJhZGl1cygpKTtcbiAgICAgICAgY29uc3QgY29sb3IxID0gcDEuZ2V0RmlsbENvbG9yKCk7XG4gICAgICAgIGNvbnN0IGNvbG9yMiA9IHAyLmdldEZpbGxDb2xvcigpO1xuICAgICAgICBpZiAoIWNvbG9yMSB8fCAhY29sb3IyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlUG9zID0gcDEuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgZGVzdFBvcyA9IHAyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IG1pZFJnYiA9IENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLm1peChjb2xvcjEsIGNvbG9yMiwgcDEuZ2V0UmFkaXVzKCksIHAyLmdldFJhZGl1cygpKTtcbiAgICAgICAgY29uc3QgZ3JhZCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoc291cmNlUG9zLngsIHNvdXJjZVBvcy55LCBkZXN0UG9zLngsIGRlc3RQb3MueSk7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDAsIENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbUhzbChjb2xvcjEsIG9wYWNpdHkpKTtcbiAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoZ3JhZFN0b3AgPiAxID8gMSA6IGdyYWRTdG9wLCBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IobWlkUmdiLCBvcGFjaXR5KSk7XG4gICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDEsIENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbUhzbChjb2xvcjIsIG9wYWNpdHkpKTtcbiAgICAgICAgcmV0dXJuIGdyYWQ7XG4gICAgfVxuICAgIHN0YXRpYyBkcmF3R3JhYkxpbmUoY29udGV4dCwgd2lkdGgsIGJlZ2luLCBlbmQsIGNvbG9yTGluZSwgb3BhY2l0eSkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgZHJhd0xpbmUoY29udGV4dCwgYmVnaW4sIGVuZCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2IoY29sb3JMaW5lLCBvcGFjaXR5KTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBkcmF3TGlnaHQoY29udGFpbmVyLCBjb250ZXh0LCBtb3VzZVBvcykge1xuICAgICAgICBjb25zdCBsaWdodE9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLmxpZ2h0LmFyZWE7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQuYXJjKG1vdXNlUG9zLngsIG1vdXNlUG9zLnksIGxpZ2h0T3B0aW9ucy5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgY29uc3QgZ3JhZGllbnRBbWJpZW50TGlnaHQgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG1vdXNlUG9zLngsIG1vdXNlUG9zLnksIDAsIG1vdXNlUG9zLngsIG1vdXNlUG9zLnksIGxpZ2h0T3B0aW9ucy5yYWRpdXMpO1xuICAgICAgICBjb25zdCBncmFkaWVudCA9IGxpZ2h0T3B0aW9ucy5ncmFkaWVudDtcbiAgICAgICAgY29uc3QgZ3JhZGllbnRSZ2IgPSB7XG4gICAgICAgICAgICBzdGFydDogQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuY29sb3JUb1JnYihncmFkaWVudC5zdGFydCksXG4gICAgICAgICAgICBzdG9wOiBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5jb2xvclRvUmdiKGdyYWRpZW50LnN0b3ApLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWdyYWRpZW50UmdiLnN0YXJ0IHx8ICFncmFkaWVudFJnYi5zdG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnRBbWJpZW50TGlnaHQuYWRkQ29sb3JTdG9wKDAsIENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmdldFN0eWxlRnJvbVJnYihncmFkaWVudFJnYi5zdGFydCkpO1xuICAgICAgICBncmFkaWVudEFtYmllbnRMaWdodC5hZGRDb2xvclN0b3AoMSwgQ29sb3JVdGlsc18xLkNvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tUmdiKGdyYWRpZW50UmdiLnN0b3ApKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudEFtYmllbnRMaWdodDtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIHN0YXRpYyBkcmF3UGFydGljbGVTaGFkb3coY29udGFpbmVyLCBjb250ZXh0LCBwYXJ0aWNsZSwgbW91c2VQb3MpIHtcbiAgICAgICAgY29uc3QgcG9zID0gcGFydGljbGUuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3Qgc2hhZG93T3B0aW9ucyA9IGNvbnRhaW5lci5hY3R1YWxPcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMubGlnaHQuc2hhZG93O1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gcGFydGljbGUuZ2V0UmFkaXVzKCk7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gcGFydGljbGUuc2lkZXM7XG4gICAgICAgIGNvbnN0IGZ1bGwgPSAoTWF0aC5QSSAqIDIpIC8gc2lkZXM7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gLXBhcnRpY2xlLnJvdGF0ZS52YWx1ZSArIE1hdGguUEkgLyA0O1xuICAgICAgICBjb25zdCBmYWN0b3IgPSAxO1xuICAgICAgICBjb25zdCBkb3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgICAgICAgZG90cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBwb3MueCArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlICsgZnVsbCAqIGkpICogZmFjdG9yLFxuICAgICAgICAgICAgICAgIHk6IHBvcy55ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUgKyBmdWxsICogaSkgKiBmYWN0b3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2hhZG93TGVuZ3RoID0gc2hhZG93T3B0aW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAoY29uc3QgZG90IG9mIGRvdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvdEFuZ2xlID0gTWF0aC5hdGFuMihtb3VzZVBvcy55IC0gZG90LnksIG1vdXNlUG9zLnggLSBkb3QueCk7XG4gICAgICAgICAgICBjb25zdCBlbmRYID0gZG90LnggKyBzaGFkb3dMZW5ndGggKiBNYXRoLnNpbigtZG90QW5nbGUgLSBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICBjb25zdCBlbmRZID0gZG90LnkgKyBzaGFkb3dMZW5ndGggKiBNYXRoLmNvcygtZG90QW5nbGUgLSBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5kWDogZW5kWCxcbiAgICAgICAgICAgICAgICBlbmRZOiBlbmRZLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogZG90LngsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiBkb3QueSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYWRvd1JnYiA9IENvbG9yVXRpbHNfMS5Db2xvclV0aWxzLmNvbG9yVG9SZ2Ioc2hhZG93T3B0aW9ucy5jb2xvcik7XG4gICAgICAgIGlmICghc2hhZG93UmdiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhZG93Q29sb3IgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2Ioc2hhZG93UmdiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IGkgPT0gcG9pbnRzLmxlbmd0aCAtIDEgPyAwIDogaSArIDE7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW2ldLnN0YXJ0WCwgcG9pbnRzW2ldLnN0YXJ0WSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbbl0uc3RhcnRYLCBwb2ludHNbbl0uc3RhcnRZKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tuXS5lbmRYLCBwb2ludHNbbl0uZW5kWSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaV0uZW5kWCwgcG9pbnRzW2ldLmVuZFkpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzaGFkb3dDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd1BhcnRpY2xlKGNvbnRhaW5lciwgY29udGV4dCwgcGFydGljbGUsIGRlbHRhLCBmaWxsQ29sb3JWYWx1ZSwgc3Ryb2tlQ29sb3JWYWx1ZSwgYmFja2dyb3VuZE1hc2ssIGNvbXBvc2l0ZSwgcmFkaXVzLCBvcGFjaXR5LCBzaGFkb3cpIHtcbiAgICAgICAgY29uc3QgcG9zID0gcGFydGljbGUuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gcGFydGljbGUucm90YXRlLnZhbHVlICsgKHBhcnRpY2xlLm9wdGlvbnMucm90YXRlLnBhdGggPyBwYXJ0aWNsZS52ZWxvY2l0eS5hbmdsZSA6IDApO1xuICAgICAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZE1hc2spIHtcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYWRvd0NvbG9yID0gcGFydGljbGUuc2hhZG93Q29sb3I7XG4gICAgICAgIGlmIChzaGFkb3cuZW5hYmxlICYmIHNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvclV0aWxzXzEuQ29sb3JVdGlscy5nZXRTdHlsZUZyb21SZ2Ioc2hhZG93Q29sb3IpO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldC54O1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldC55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsQ29sb3JWYWx1ZSkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsQ29sb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJva2UgPSBwYXJ0aWNsZS5zdHJva2U7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gcGFydGljbGUuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGlmIChzdHJva2VDb2xvclZhbHVlKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBDYW52YXNVdGlscy5kcmF3U2hhcGUoY29udGFpbmVyLCBjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzLCBvcGFjaXR5LCBkZWx0YSk7XG4gICAgICAgIGlmIChzdHJva2Uud2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWNsZS5jbG9zZSkge1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljbGUuZmlsbCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgICAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFja2dyb3VuZE1hc2spIHtcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlO1xuICAgICAgICB9XG4gICAgICAgIENhbnZhc1V0aWxzLmRyYXdTaGFwZUFmdGVyRWZmZWN0KGNvbnRhaW5lciwgY29udGV4dCwgcGFydGljbGUsIHJhZGl1cywgb3BhY2l0eSwgZGVsdGEpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgc3RhdGljIGRyYXdTaGFwZShjb250YWluZXIsIGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHksIGRlbHRhKSB7XG4gICAgICAgIGlmICghcGFydGljbGUuc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcmF3ZXIgPSBjb250YWluZXIuZHJhd2Vycy5nZXQocGFydGljbGUuc2hhcGUpO1xuICAgICAgICBpZiAoIWRyYXdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdlci5kcmF3KGNvbnRleHQsIHBhcnRpY2xlLCByYWRpdXMsIG9wYWNpdHksIGRlbHRhLCBjb250YWluZXIucmV0aW5hLnBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBzdGF0aWMgZHJhd1NoYXBlQWZ0ZXJFZmZlY3QoY29udGFpbmVyLCBjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzLCBvcGFjaXR5LCBkZWx0YSkge1xuICAgICAgICBpZiAoIXBhcnRpY2xlLnNoYXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJhd2VyID0gY29udGFpbmVyLmRyYXdlcnMuZ2V0KHBhcnRpY2xlLnNoYXBlKTtcbiAgICAgICAgaWYgKCEoZHJhd2VyID09PSBudWxsIHx8IGRyYXdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhd2VyLmFmdGVyRWZmZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdlci5hZnRlckVmZmVjdChjb250ZXh0LCBwYXJ0aWNsZSwgcmFkaXVzLCBvcGFjaXR5LCBkZWx0YSwgY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvKTtcbiAgICB9XG4gICAgc3RhdGljIGRyYXdQbHVnaW4oY29udGV4dCwgcGx1Z2luLCBkZWx0YSkge1xuICAgICAgICBpZiAocGx1Z2luLmRyYXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBwbHVnaW4uZHJhdyhjb250ZXh0LCBkZWx0YSk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FudmFzVXRpbHMgPSBDYW52YXNVdGlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaXJjbGUgPSB2b2lkIDA7XG5jb25zdCBSYW5nZV8xID0gcmVxdWlyZShcIi4vUmFuZ2VcIik7XG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBSYW5nZV8xLlJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCByYWRpdXMpIHtcbiAgICAgICAgc3VwZXIoeCwgeSk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIH1cbiAgICBjb250YWlucyhwb2ludCkge1xuICAgICAgICBjb25zdCBkID0gTWF0aC5wb3cocG9pbnQueCAtIHRoaXMucG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyhwb2ludC55IC0gdGhpcy5wb3NpdGlvbi55LCAyKTtcbiAgICAgICAgcmV0dXJuIGQgPD0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhyYW5nZSkge1xuICAgICAgICBjb25zdCByZWN0ID0gcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNpcmNsZSA9IHJhbmdlO1xuICAgICAgICBjb25zdCBwb3MxID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgcG9zMiA9IHJhbmdlLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB4RGlzdCA9IE1hdGguYWJzKHBvczIueCAtIHBvczEueCk7XG4gICAgICAgIGNvbnN0IHlEaXN0ID0gTWF0aC5hYnMocG9zMi55IC0gcG9zMS55KTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMucmFkaXVzO1xuICAgICAgICBpZiAoY2lyY2xlLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByU3VtID0gciArIGNpcmNsZS5yYWRpdXM7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KHhEaXN0ICogeERpc3QgKyB5RGlzdCArIHlEaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByU3VtID4gZGlzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN0LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdyA9IHJlY3Quc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGggPSByZWN0LnNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBNYXRoLnBvdyh4RGlzdCAtIHcsIDIpICsgTWF0aC5wb3coeURpc3QgLSBoLCAyKTtcbiAgICAgICAgICAgIGlmICh4RGlzdCA+IHIgKyB3IHx8IHlEaXN0ID4gciArIGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeERpc3QgPD0gdyB8fCB5RGlzdCA8PSBoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWRnZXMgPD0gciAqIHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNpcmNsZVdhcnAgPSB2b2lkIDA7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNvbnN0IENpcmNsZV8xID0gcmVxdWlyZShcIi4vQ2lyY2xlXCIpO1xuY2xhc3MgQ2lyY2xlV2FycCBleHRlbmRzIENpcmNsZV8xLkNpcmNsZSB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgcmFkaXVzLCBjYW52YXNTaXplKSB7XG4gICAgICAgIHN1cGVyKHgsIHksIHJhZGl1cyk7XG4gICAgICAgIHRoaXMuY2FudmFzU2l6ZSA9IGNhbnZhc1NpemU7XG4gICAgICAgIHRoaXMuY2FudmFzU2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29udGFpbnMocG9pbnQpIHtcbiAgICAgICAgaWYgKHN1cGVyLmNvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zTkUgPSB7XG4gICAgICAgICAgICB4OiBwb2ludC54IC0gdGhpcy5jYW52YXNTaXplLndpZHRoLFxuICAgICAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN1cGVyLmNvbnRhaW5zKHBvc05FKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zU0UgPSB7XG4gICAgICAgICAgICB4OiBwb2ludC54IC0gdGhpcy5jYW52YXNTaXplLndpZHRoLFxuICAgICAgICAgICAgeTogcG9pbnQueSAtIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzdXBlci5jb250YWlucyhwb3NTRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc1NXID0ge1xuICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgIHk6IHBvaW50LnkgLSB0aGlzLmNhbnZhc1NpemUuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3VwZXIuY29udGFpbnMocG9zU1cpO1xuICAgIH1cbiAgICBpbnRlcnNlY3RzKHJhbmdlKSB7XG4gICAgICAgIGlmIChzdXBlci5pbnRlcnNlY3RzKHJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjdCA9IHJhbmdlO1xuICAgICAgICBjb25zdCBjaXJjbGUgPSByYW5nZTtcbiAgICAgICAgY29uc3QgbmV3UG9zID0ge1xuICAgICAgICAgICAgeDogcmFuZ2UucG9zaXRpb24ueCAtIHRoaXMuY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHk6IHJhbmdlLnBvc2l0aW9uLnkgLSB0aGlzLmNhbnZhc1NpemUuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2lyY2xlLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBiaWdnZXJDaXJjbGUgPSBuZXcgQ2lyY2xlXzEuQ2lyY2xlKG5ld1Bvcy54LCBuZXdQb3MueSwgY2lyY2xlLnJhZGl1cyAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmludGVyc2VjdHMoYmlnZ2VyQ2lyY2xlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWN0LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVjdFNXID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZShuZXdQb3MueCwgbmV3UG9zLnksIHJlY3Quc2l6ZS53aWR0aCAqIDIsIHJlY3Quc2l6ZS5oZWlnaHQgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5pbnRlcnNlY3RzKHJlY3RTVyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2lyY2xlV2FycCA9IENpcmNsZVdhcnA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sb3JVdGlscyA9IHZvaWQgMDtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbmNvbnN0IENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xuY29uc3QgTnVtYmVyVXRpbHNfMSA9IHJlcXVpcmUoXCIuL051bWJlclV0aWxzXCIpO1xuZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgbGV0IHRDYWxjID0gdDtcbiAgICBpZiAodENhbGMgPCAwKSB7XG4gICAgICAgIHRDYWxjICs9IDE7XG4gICAgfVxuICAgIGlmICh0Q2FsYyA+IDEpIHtcbiAgICAgICAgdENhbGMgLT0gMTtcbiAgICB9XG4gICAgaWYgKHRDYWxjIDwgMSAvIDYpIHtcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHRDYWxjO1xuICAgIH1cbiAgICBpZiAodENhbGMgPCAxIC8gMikge1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgaWYgKHRDYWxjIDwgMiAvIDMpIHtcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdENhbGMpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1JnYmEoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcInJnYlwiKSkge1xuICAgICAgICBjb25zdCByZWdleCA9IC9yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKCxcXHMqKFtcXGQuXSspXFxzKik/XFwpL2k7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhOiByZXN1bHQubGVuZ3RoID4gNCA/IHBhcnNlRmxvYXQocmVzdWx0WzVdKSA6IDEsXG4gICAgICAgICAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxMCksXG4gICAgICAgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxMCksXG4gICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxMCksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQuc3RhcnRzV2l0aChcImhzbFwiKSkge1xuICAgICAgICBjb25zdCByZWdleCA9IC9oc2xhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyooLFxccyooW1xcZC5dKylcXHMqKT9cXCkvaTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgID8gQ29sb3JVdGlscy5oc2xhVG9SZ2JhKHtcbiAgICAgICAgICAgICAgICBhOiByZXN1bHQubGVuZ3RoID4gNCA/IHBhcnNlRmxvYXQocmVzdWx0WzVdKSA6IDEsXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJbnQocmVzdWx0WzFdLCAxMCksXG4gICAgICAgICAgICAgICAgbDogcGFyc2VJbnQocmVzdWx0WzNdLCAxMCksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJbnQocmVzdWx0WzJdLCAxMCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXCJoc3ZcIikpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSAvaHN2YT9cXChcXHMqKFxcZCspwrBcXHMqLFxccyooXFxkKyklXFxzKixcXHMqKFxcZCspJVxccyooLFxccyooW1xcZC5dKylcXHMqKT9cXCkvaTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgID8gQ29sb3JVdGlscy5oc3ZhVG9SZ2JhKHtcbiAgICAgICAgICAgICAgICBhOiByZXN1bHQubGVuZ3RoID4gNCA/IHBhcnNlRmxvYXQocmVzdWx0WzVdKSA6IDEsXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJbnQocmVzdWx0WzFdLCAxMCksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJbnQocmVzdWx0WzJdLCAxMCksXG4gICAgICAgICAgICAgICAgdjogcGFyc2VJbnQocmVzdWx0WzNdLCAxMCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pPyQvaTtcbiAgICAgICAgY29uc3QgaGV4Rml4ZWQgPSBpbnB1dC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCAoX20sIHIsIGcsIGIsIGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGIgKyAoYSAhPT0gdW5kZWZpbmVkID8gYSArIGEgOiBcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSk/JC9pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWdleC5leGVjKGhleEZpeGVkKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYTogcmVzdWx0WzRdICE9PSB1bmRlZmluZWQgPyBwYXJzZUludChyZXN1bHRbNF0sIDE2KSAvIDB4ZmYgOiAxLFxuICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpLFxuICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgQ29sb3JVdGlscyB7XG4gICAgc3RhdGljIGNvbG9yVG9SZ2IoaW5wdXQsIGluZGV4LCB1c2VJbmRleCA9IHRydWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3IgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyB7IHZhbHVlOiBpbnB1dCB9IDogaW5wdXQ7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChjb2xvci52YWx1ZSA9PT0gQ29uc3RhbnRzXzEuQ29uc3RhbnRzLnJhbmRvbUNvbG9yVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBDb2xvclV0aWxzLmdldFJhbmRvbVJnYkNvbG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBDb2xvclV0aWxzLnN0cmluZ1RvUmdiKGNvbG9yLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb2xvci52YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JTZWxlY3RlZCA9IFV0aWxzXzEuVXRpbHMuaXRlbUZyb21BcnJheShjb2xvci52YWx1ZSwgaW5kZXgsIHVzZUluZGV4KTtcbiAgICAgICAgICAgICAgICByZXMgPSBDb2xvclV0aWxzLmNvbG9yVG9SZ2IoeyB2YWx1ZTogY29sb3JTZWxlY3RlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBjb2xvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZ2JDb2xvciA9IChfYSA9IGNvbG9yVmFsdWUucmdiKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2xvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmdiQ29sb3IuciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJnYkNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHNsQ29sb3IgPSAoX2IgPSBjb2xvclZhbHVlLmhzbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29sb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoc2xDb2xvci5oICE9PSB1bmRlZmluZWQgJiYgaHNsQ29sb3IubCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBDb2xvclV0aWxzLmhzbFRvUmdiKGhzbENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhzdkNvbG9yID0gKF9jID0gY29sb3JWYWx1ZS5oc3YpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhzdkNvbG9yLmggIT09IHVuZGVmaW5lZCAmJiBoc3ZDb2xvci52ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBDb2xvclV0aWxzLmhzdlRvUmdiKGhzdkNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgY29sb3JUb0hzbChjb2xvciwgaW5kZXgsIHVzZUluZGV4ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCByZ2IgPSBDb2xvclV0aWxzLmNvbG9yVG9SZ2IoY29sb3IsIGluZGV4LCB1c2VJbmRleCk7XG4gICAgICAgIHJldHVybiByZ2IgIT09IHVuZGVmaW5lZCA/IENvbG9yVXRpbHMucmdiVG9Ic2wocmdiKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RhdGljIHJnYlRvSHNsKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHIxID0gY29sb3IuciAvIDI1NTtcbiAgICAgICAgY29uc3QgZzEgPSBjb2xvci5nIC8gMjU1O1xuICAgICAgICBjb25zdCBiMSA9IGNvbG9yLmIgLyAyNTU7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIxLCBnMSwgYjEpO1xuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyMSwgZzEsIGIxKTtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgaDogMCxcbiAgICAgICAgICAgIGw6IChtYXggKyBtaW4pIC8gMixcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXggIT0gbWluKSB7XG4gICAgICAgICAgICByZXMucyA9IHJlcy5sIDwgMC41ID8gKG1heCAtIG1pbikgLyAobWF4ICsgbWluKSA6IChtYXggLSBtaW4pIC8gKDIuMCAtIG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXMuaCA9XG4gICAgICAgICAgICAgICAgcjEgPT09IG1heFxuICAgICAgICAgICAgICAgICAgICA/IChnMSAtIGIxKSAvIChtYXggLSBtaW4pXG4gICAgICAgICAgICAgICAgICAgIDogKHJlcy5oID0gZzEgPT09IG1heCA/IDIuMCArIChiMSAtIHIxKSAvIChtYXggLSBtaW4pIDogNC4wICsgKHIxIC0gZzEpIC8gKG1heCAtIG1pbikpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5sICo9IDEwMDtcbiAgICAgICAgcmVzLnMgKj0gMTAwO1xuICAgICAgICByZXMuaCAqPSA2MDtcbiAgICAgICAgaWYgKHJlcy5oIDwgMCkge1xuICAgICAgICAgICAgcmVzLmggKz0gMzYwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdUb0FscGhhKGlucHV0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHN0cmluZ1RvUmdiYShpbnB1dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaW5nVG9SZ2IoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvUmdiYShpbnB1dCk7XG4gICAgfVxuICAgIHN0YXRpYyBoc2xUb1JnYihoc2wpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBiOiAwLCBnOiAwLCByOiAwIH07XG4gICAgICAgIGNvbnN0IGhzbFBlcmNlbnQgPSB7XG4gICAgICAgICAgICBoOiBoc2wuaCAvIDM2MCxcbiAgICAgICAgICAgIGw6IGhzbC5sIC8gMTAwLFxuICAgICAgICAgICAgczogaHNsLnMgLyAxMDAsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoc2xQZXJjZW50LnMgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5iID0gaHNsUGVyY2VudC5sO1xuICAgICAgICAgICAgcmVzdWx0LmcgPSBoc2xQZXJjZW50Lmw7XG4gICAgICAgICAgICByZXN1bHQuciA9IGhzbFBlcmNlbnQubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBoc2xQZXJjZW50LmwgPCAwLjVcbiAgICAgICAgICAgICAgICA/IGhzbFBlcmNlbnQubCAqICgxICsgaHNsUGVyY2VudC5zKVxuICAgICAgICAgICAgICAgIDogaHNsUGVyY2VudC5sICsgaHNsUGVyY2VudC5zIC0gaHNsUGVyY2VudC5sICogaHNsUGVyY2VudC5zO1xuICAgICAgICAgICAgY29uc3QgcCA9IDIgKiBoc2xQZXJjZW50LmwgLSBxO1xuICAgICAgICAgICAgcmVzdWx0LnIgPSBodWUycmdiKHAsIHEsIGhzbFBlcmNlbnQuaCArIDEgLyAzKTtcbiAgICAgICAgICAgIHJlc3VsdC5nID0gaHVlMnJnYihwLCBxLCBoc2xQZXJjZW50LmgpO1xuICAgICAgICAgICAgcmVzdWx0LmIgPSBodWUycmdiKHAsIHEsIGhzbFBlcmNlbnQuaCAtIDEgLyAzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuciA9IE1hdGguZmxvb3IocmVzdWx0LnIgKiAyNTUpO1xuICAgICAgICByZXN1bHQuZyA9IE1hdGguZmxvb3IocmVzdWx0LmcgKiAyNTUpO1xuICAgICAgICByZXN1bHQuYiA9IE1hdGguZmxvb3IocmVzdWx0LmIgKiAyNTUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgaHNsYVRvUmdiYShoc2xhKSB7XG4gICAgICAgIGNvbnN0IHJnYlJlc3VsdCA9IENvbG9yVXRpbHMuaHNsVG9SZ2IoaHNsYSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBoc2xhLmEsXG4gICAgICAgICAgICBiOiByZ2JSZXN1bHQuYixcbiAgICAgICAgICAgIGc6IHJnYlJlc3VsdC5nLFxuICAgICAgICAgICAgcjogcmdiUmVzdWx0LnIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBoc2xUb0hzdihoc2wpIHtcbiAgICAgICAgY29uc3QgbCA9IGhzbC5sIC8gMTAwLCBzbCA9IGhzbC5zIC8gMTAwO1xuICAgICAgICBjb25zdCB2ID0gbCArIHNsICogTWF0aC5taW4obCwgMSAtIGwpLCBzdiA9ICF2ID8gMCA6IDIgKiAoMSAtIGwgLyB2KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGg6IGhzbC5oLFxuICAgICAgICAgICAgczogc3YgKiAxMDAsXG4gICAgICAgICAgICB2OiB2ICogMTAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgaHNsYVRvSHN2YShoc2xhKSB7XG4gICAgICAgIGNvbnN0IGhzdlJlc3VsdCA9IENvbG9yVXRpbHMuaHNsVG9Ic3YoaHNsYSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBoc2xhLmEsXG4gICAgICAgICAgICBoOiBoc3ZSZXN1bHQuaCxcbiAgICAgICAgICAgIHM6IGhzdlJlc3VsdC5zLFxuICAgICAgICAgICAgdjogaHN2UmVzdWx0LnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBoc3ZUb0hzbChoc3YpIHtcbiAgICAgICAgY29uc3QgdiA9IGhzdi52IC8gMTAwLCBzdiA9IGhzdi5zIC8gMTAwO1xuICAgICAgICBjb25zdCBsID0gdiAqICgxIC0gc3YgLyAyKSwgc2wgPSBsID09PSAwIHx8IGwgPT09IDEgPyAwIDogKHYgLSBsKSAvIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGg6IGhzdi5oLFxuICAgICAgICAgICAgbDogbCAqIDEwMCxcbiAgICAgICAgICAgIHM6IHNsICogMTAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgaHN2YVRvSHNsYShoc3ZhKSB7XG4gICAgICAgIGNvbnN0IGhzbFJlc3VsdCA9IENvbG9yVXRpbHMuaHN2VG9Ic2woaHN2YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBoc3ZhLmEsXG4gICAgICAgICAgICBoOiBoc2xSZXN1bHQuaCxcbiAgICAgICAgICAgIGw6IGhzbFJlc3VsdC5sLFxuICAgICAgICAgICAgczogaHNsUmVzdWx0LnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBoc3ZUb1JnYihoc3YpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBiOiAwLCBnOiAwLCByOiAwIH07XG4gICAgICAgIGNvbnN0IGhzdlBlcmNlbnQgPSB7XG4gICAgICAgICAgICBoOiBoc3YuaCAvIDYwLFxuICAgICAgICAgICAgczogaHN2LnMgLyAxMDAsXG4gICAgICAgICAgICB2OiBoc3YudiAvIDEwMCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYyA9IGhzdlBlcmNlbnQudiAqIGhzdlBlcmNlbnQucywgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoc3ZQZXJjZW50LmggJSAyKSAtIDEpKTtcbiAgICAgICAgbGV0IHRlbXBSZ2I7XG4gICAgICAgIGlmIChoc3ZQZXJjZW50LmggPj0gMCAmJiBoc3ZQZXJjZW50LmggPD0gMSkge1xuICAgICAgICAgICAgdGVtcFJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiBjLFxuICAgICAgICAgICAgICAgIGc6IHgsXG4gICAgICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHN2UGVyY2VudC5oID4gMSAmJiBoc3ZQZXJjZW50LmggPD0gMikge1xuICAgICAgICAgICAgdGVtcFJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiB4LFxuICAgICAgICAgICAgICAgIGc6IGMsXG4gICAgICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHN2UGVyY2VudC5oID4gMiAmJiBoc3ZQZXJjZW50LmggPD0gMykge1xuICAgICAgICAgICAgdGVtcFJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgICAgIGc6IGMsXG4gICAgICAgICAgICAgICAgYjogeCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHN2UGVyY2VudC5oID4gMyAmJiBoc3ZQZXJjZW50LmggPD0gNCkge1xuICAgICAgICAgICAgdGVtcFJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgICAgIGc6IHgsXG4gICAgICAgICAgICAgICAgYjogYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHN2UGVyY2VudC5oID4gNCAmJiBoc3ZQZXJjZW50LmggPD0gNSkge1xuICAgICAgICAgICAgdGVtcFJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiB4LFxuICAgICAgICAgICAgICAgIGc6IDAsXG4gICAgICAgICAgICAgICAgYjogYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHN2UGVyY2VudC5oID4gNSAmJiBoc3ZQZXJjZW50LmggPD0gNikge1xuICAgICAgICAgICAgdGVtcFJnYiA9IHtcbiAgICAgICAgICAgICAgICByOiBjLFxuICAgICAgICAgICAgICAgIGc6IDAsXG4gICAgICAgICAgICAgICAgYjogeCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBSZ2IpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBoc3ZQZXJjZW50LnYgLSBjO1xuICAgICAgICAgICAgcmVzdWx0LnIgPSBNYXRoLmZsb29yKCh0ZW1wUmdiLnIgKyBtKSAqIDI1NSk7XG4gICAgICAgICAgICByZXN1bHQuZyA9IE1hdGguZmxvb3IoKHRlbXBSZ2IuZyArIG0pICogMjU1KTtcbiAgICAgICAgICAgIHJlc3VsdC5iID0gTWF0aC5mbG9vcigodGVtcFJnYi5iICsgbSkgKiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBoc3ZhVG9SZ2JhKGhzdmEpIHtcbiAgICAgICAgY29uc3QgcmdiUmVzdWx0ID0gQ29sb3JVdGlscy5oc3ZUb1JnYihoc3ZhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IGhzdmEuYSxcbiAgICAgICAgICAgIGI6IHJnYlJlc3VsdC5iLFxuICAgICAgICAgICAgZzogcmdiUmVzdWx0LmcsXG4gICAgICAgICAgICByOiByZ2JSZXN1bHQucixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHJnYlRvSHN2KHJnYikge1xuICAgICAgICBjb25zdCByZ2JQZXJjZW50ID0ge1xuICAgICAgICAgICAgcjogcmdiLnIgLyAyNTUsXG4gICAgICAgICAgICBnOiByZ2IuZyAvIDI1NSxcbiAgICAgICAgICAgIGI6IHJnYi5iIC8gMjU1LFxuICAgICAgICB9LCB4TWF4ID0gTWF0aC5tYXgocmdiUGVyY2VudC5yLCByZ2JQZXJjZW50LmcsIHJnYlBlcmNlbnQuYiksIHhNaW4gPSBNYXRoLm1pbihyZ2JQZXJjZW50LnIsIHJnYlBlcmNlbnQuZywgcmdiUGVyY2VudC5iKSwgdiA9IHhNYXgsIGMgPSB4TWF4IC0geE1pbjtcbiAgICAgICAgbGV0IGggPSAwO1xuICAgICAgICBpZiAodiA9PT0gcmdiUGVyY2VudC5yKSB7XG4gICAgICAgICAgICBoID0gNjAgKiAoKHJnYlBlcmNlbnQuZyAtIHJnYlBlcmNlbnQuYikgLyBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSByZ2JQZXJjZW50LmcpIHtcbiAgICAgICAgICAgIGggPSA2MCAqICgyICsgKHJnYlBlcmNlbnQuYiAtIHJnYlBlcmNlbnQucikgLyBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSByZ2JQZXJjZW50LmIpIHtcbiAgICAgICAgICAgIGggPSA2MCAqICg0ICsgKHJnYlBlcmNlbnQuciAtIHJnYlBlcmNlbnQuZykgLyBjKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzID0gIXYgPyAwIDogYyAvIHY7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgczogcyAqIDEwMCxcbiAgICAgICAgICAgIHY6IHYgKiAxMDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyByZ2JhVG9Ic3ZhKHJnYmEpIHtcbiAgICAgICAgY29uc3QgaHN2UmVzdWx0ID0gQ29sb3JVdGlscy5yZ2JUb0hzdihyZ2JhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHJnYmEuYSxcbiAgICAgICAgICAgIGg6IGhzdlJlc3VsdC5oLFxuICAgICAgICAgICAgczogaHN2UmVzdWx0LnMsXG4gICAgICAgICAgICB2OiBoc3ZSZXN1bHQudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFJhbmRvbVJnYkNvbG9yKG1pbikge1xuICAgICAgICBjb25zdCBmaXhlZE1pbiA9IG1pbiAhPT0gbnVsbCAmJiBtaW4gIT09IHZvaWQgMCA/IG1pbiA6IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiOiBNYXRoLmZsb29yKE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMucmFuZG9tSW5SYW5nZShOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUoZml4ZWRNaW4sIDI1NikpKSxcbiAgICAgICAgICAgIGc6IE1hdGguZmxvb3IoTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5yYW5kb21JblJhbmdlKE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuc2V0UmFuZ2VWYWx1ZShmaXhlZE1pbiwgMjU2KSkpLFxuICAgICAgICAgICAgcjogTWF0aC5mbG9vcihOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UoTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5zZXRSYW5nZVZhbHVlKGZpeGVkTWluLCAyNTYpKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTdHlsZUZyb21SZ2IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgcmV0dXJuIGByZ2JhKCR7Y29sb3Iucn0sICR7Y29sb3IuZ30sICR7Y29sb3IuYn0sICR7b3BhY2l0eSAhPT0gbnVsbCAmJiBvcGFjaXR5ICE9PSB2b2lkIDAgPyBvcGFjaXR5IDogMX0pYDtcbiAgICB9XG4gICAgc3RhdGljIGdldFN0eWxlRnJvbUhzbChjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICByZXR1cm4gYGhzbGEoJHtjb2xvci5ofSwgJHtjb2xvci5zfSUsICR7Y29sb3IubH0lLCAke29wYWNpdHkgIT09IG51bGwgJiYgb3BhY2l0eSAhPT0gdm9pZCAwID8gb3BhY2l0eSA6IDF9KWA7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTdHlsZUZyb21Ic3YoY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yVXRpbHMuZ2V0U3R5bGVGcm9tSHNsKENvbG9yVXRpbHMuaHN2VG9Ic2woY29sb3IpLCBvcGFjaXR5KTtcbiAgICB9XG4gICAgc3RhdGljIG1peChjb2xvcjEsIGNvbG9yMiwgc2l6ZTEsIHNpemUyKSB7XG4gICAgICAgIGxldCByZ2IxID0gY29sb3IxO1xuICAgICAgICBsZXQgcmdiMiA9IGNvbG9yMjtcbiAgICAgICAgaWYgKHJnYjEuciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZ2IxID0gQ29sb3JVdGlscy5oc2xUb1JnYihjb2xvcjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2IyLnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmdiMiA9IENvbG9yVXRpbHMuaHNsVG9SZ2IoY29sb3IyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYjogTnVtYmVyVXRpbHNfMS5OdW1iZXJVdGlscy5taXgocmdiMS5iLCByZ2IyLmIsIHNpemUxLCBzaXplMiksXG4gICAgICAgICAgICBnOiBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLm1peChyZ2IxLmcsIHJnYjIuZywgc2l6ZTEsIHNpemUyKSxcbiAgICAgICAgICAgIHI6IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMubWl4KHJnYjEuciwgcmdiMi5yLCBzaXplMSwgc2l6ZTIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgcmVwbGFjZUNvbG9yU3ZnKGltYWdlLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICBpZiAoIWltYWdlLnN2Z0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN2Z1htbCA9IGltYWdlLnN2Z0RhdGE7XG4gICAgICAgIGNvbnN0IHJnYkhleCA9IC8jKFswLTlBLUZdezMsNn0pL2dpO1xuICAgICAgICByZXR1cm4gc3ZnWG1sLnJlcGxhY2UocmdiSGV4LCAoKSA9PiBDb2xvclV0aWxzLmdldFN0eWxlRnJvbUhzbChjb2xvciwgb3BhY2l0eSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TGlua0NvbG9yKHAxLCBwMiwgbGlua0NvbG9yKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChsaW5rQ29sb3IgPT09IENvbnN0YW50c18xLkNvbnN0YW50cy5yYW5kb21Db2xvclZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29sb3JVdGlscy5nZXRSYW5kb21SZ2JDb2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmtDb2xvciA9PT0gXCJtaWRcIikge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQ29sb3IgPSAoX2EgPSBwMS5nZXRGaWxsQ29sb3IoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcDEuZ2V0U3Ryb2tlQ29sb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RDb2xvciA9IChfYiA9IHAyID09PSBudWxsIHx8IHAyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwMi5nZXRGaWxsQ29sb3IoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcDIgPT09IG51bGwgfHwgcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHAyLmdldFN0cm9rZUNvbG9yKCk7XG4gICAgICAgICAgICBpZiAoc291cmNlQ29sb3IgJiYgZGVzdENvbG9yICYmIHAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yVXRpbHMubWl4KHNvdXJjZUNvbG9yLCBkZXN0Q29sb3IsIHAxLmdldFJhZGl1cygpLCBwMi5nZXRSYWRpdXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoc2xDb2xvciA9IHNvdXJjZUNvbG9yICE9PSBudWxsICYmIHNvdXJjZUNvbG9yICE9PSB2b2lkIDAgPyBzb3VyY2VDb2xvciA6IGRlc3RDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoaHNsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yVXRpbHMuaHNsVG9SZ2IoaHNsQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rQ29sb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldExpbmtSYW5kb21Db2xvcihvcHRDb2xvciwgYmxpbmssIGNvbnNlbnQpIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0eXBlb2Ygb3B0Q29sb3IgPT09IFwic3RyaW5nXCIgPyBvcHRDb2xvciA6IG9wdENvbG9yLnZhbHVlO1xuICAgICAgICBpZiAoY29sb3IgPT09IENvbnN0YW50c18xLkNvbnN0YW50cy5yYW5kb21Db2xvclZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY29uc2VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb2xvclV0aWxzLmNvbG9yVG9SZ2Ioe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChibGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5Db25zdGFudHMucmFuZG9tQ29sb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5Db25zdGFudHMubWlkQ29sb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDb2xvclV0aWxzLmNvbG9yVG9SZ2Ioe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRIc2xGcm9tQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGg6IGFuaW1hdGlvbi5oLnZhbHVlLFxuICAgICAgICAgICAgICAgIHM6IGFuaW1hdGlvbi5zLnZhbHVlLFxuICAgICAgICAgICAgICAgIGw6IGFuaW1hdGlvbi5sLnZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5Db2xvclV0aWxzID0gQ29sb3JVdGlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25zdGFudHMgPSB2b2lkIDA7XG5jbGFzcyBDb25zdGFudHMge1xufVxuZXhwb3J0cy5Db25zdGFudHMgPSBDb25zdGFudHM7XG5Db25zdGFudHMuY2FudmFzQ2xhc3MgPSBcInRzcGFydGljbGVzLWNhbnZhcy1lbFwiO1xuQ29uc3RhbnRzLnJhbmRvbUNvbG9yVmFsdWUgPSBcInJhbmRvbVwiO1xuQ29uc3RhbnRzLm1pZENvbG9yVmFsdWUgPSBcIm1pZFwiO1xuQ29uc3RhbnRzLnRvdWNoRW5kRXZlbnQgPSBcInRvdWNoZW5kXCI7XG5Db25zdGFudHMubW91c2VEb3duRXZlbnQgPSBcIm1vdXNlZG93blwiO1xuQ29uc3RhbnRzLm1vdXNlVXBFdmVudCA9IFwibW91c2V1cFwiO1xuQ29uc3RhbnRzLm1vdXNlTW92ZUV2ZW50ID0gXCJtb3VzZW1vdmVcIjtcbkNvbnN0YW50cy50b3VjaFN0YXJ0RXZlbnQgPSBcInRvdWNoc3RhcnRcIjtcbkNvbnN0YW50cy50b3VjaE1vdmVFdmVudCA9IFwidG91Y2htb3ZlXCI7XG5Db25zdGFudHMubW91c2VMZWF2ZUV2ZW50ID0gXCJtb3VzZWxlYXZlXCI7XG5Db25zdGFudHMubW91c2VPdXRFdmVudCA9IFwibW91c2VvdXRcIjtcbkNvbnN0YW50cy50b3VjaENhbmNlbEV2ZW50ID0gXCJ0b3VjaGNhbmNlbFwiO1xuQ29uc3RhbnRzLnJlc2l6ZUV2ZW50ID0gXCJyZXNpemVcIjtcbkNvbnN0YW50cy52aXNpYmlsaXR5Q2hhbmdlRXZlbnQgPSBcInZpc2liaWxpdHljaGFuZ2VcIjtcbkNvbnN0YW50cy5ub1BvbHlnb25EYXRhTG9hZGVkID0gXCJObyBwb2x5Z29uIGRhdGEgbG9hZGVkLlwiO1xuQ29uc3RhbnRzLm5vUG9seWdvbkZvdW5kID0gXCJObyBwb2x5Z29uIGZvdW5kLCB5b3UgbmVlZCB0byBzcGVjaWZ5IFNWRyB1cmwgaW4gY29uZmlnLlwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50TGlzdGVuZXJzID0gdm9pZCAwO1xuY29uc3QgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbmNvbnN0IENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gbWFuYWdlTGlzdGVuZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGFkZCwgb3B0aW9ucykge1xuICAgIGlmIChhZGQpIHtcbiAgICAgICAgbGV0IGFkZE9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgYWRkT3B0aW9ucy5jYXB0dXJlID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgYWRkT3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZW1vdmVPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCByZW1vdmVPcHRpb25zKTtcbiAgICB9XG59XG5jbGFzcyBFdmVudExpc3RlbmVycyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSAoZSkgPT4gdGhpcy5tb3VzZVRvdWNoTW92ZShlKTtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0SGFuZGxlciA9IChlKSA9PiB0aGlzLm1vdXNlVG91Y2hNb3ZlKGUpO1xuICAgICAgICB0aGlzLnRvdWNoTW92ZUhhbmRsZXIgPSAoZSkgPT4gdGhpcy5tb3VzZVRvdWNoTW92ZShlKTtcbiAgICAgICAgdGhpcy50b3VjaEVuZEhhbmRsZXIgPSAoKSA9PiB0aGlzLm1vdXNlVG91Y2hGaW5pc2goKTtcbiAgICAgICAgdGhpcy5tb3VzZUxlYXZlSGFuZGxlciA9ICgpID0+IHRoaXMubW91c2VUb3VjaEZpbmlzaCgpO1xuICAgICAgICB0aGlzLnRvdWNoQ2FuY2VsSGFuZGxlciA9ICgpID0+IHRoaXMubW91c2VUb3VjaEZpbmlzaCgpO1xuICAgICAgICB0aGlzLnRvdWNoRW5kQ2xpY2tIYW5kbGVyID0gKGUpID0+IHRoaXMubW91c2VUb3VjaENsaWNrKGUpO1xuICAgICAgICB0aGlzLm1vdXNlVXBIYW5kbGVyID0gKGUpID0+IHRoaXMubW91c2VUb3VjaENsaWNrKGUpO1xuICAgICAgICB0aGlzLm1vdXNlRG93bkhhbmRsZXIgPSAoKSA9PiB0aGlzLm1vdXNlRG93bigpO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlV2luZG93UmVzaXplKCk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VMaXN0ZW5lcnModHJ1ZSk7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VMaXN0ZW5lcnMoZmFsc2UpO1xuICAgIH1cbiAgICBtYW5hZ2VMaXN0ZW5lcnMoYWRkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgZGV0ZWN0VHlwZSA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5kZXRlY3RzT247XG4gICAgICAgIGxldCBtb3VzZUxlYXZlRXZlbnQgPSBDb25zdGFudHNfMS5Db25zdGFudHMubW91c2VMZWF2ZUV2ZW50O1xuICAgICAgICBpZiAoZGV0ZWN0VHlwZSA9PT0gRW51bXNfMS5JbnRlcmFjdGl2aXR5RGV0ZWN0LndpbmRvdykge1xuICAgICAgICAgICAgY29udGFpbmVyLmludGVyYWN0aXZpdHkuZWxlbWVudCA9IHdpbmRvdztcbiAgICAgICAgICAgIG1vdXNlTGVhdmVFdmVudCA9IENvbnN0YW50c18xLkNvbnN0YW50cy5tb3VzZU91dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRldGVjdFR5cGUgPT09IEVudW1zXzEuSW50ZXJhY3Rpdml0eURldGVjdC5wYXJlbnQgJiYgY29udGFpbmVyLmNhbnZhcy5lbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXNFbCA9IGNvbnRhaW5lci5jYW52YXMuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnRlcmFjdGl2aXR5LmVsZW1lbnQgPSAoX2EgPSBjYW52YXNFbC5wYXJlbnRFbGVtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjYW52YXNFbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLmludGVyYWN0aXZpdHkuZWxlbWVudCA9IGNvbnRhaW5lci5jYW52YXMuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5RWwgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5lbGVtZW50O1xuICAgICAgICBpZiAoIWludGVyYWN0aXZpdHlFbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGh0bWwgPSBpbnRlcmFjdGl2aXR5RWw7XG4gICAgICAgIGlmIChvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uSG92ZXIuZW5hYmxlIHx8IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMub25DbGljay5lbmFibGUpIHtcbiAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLm1vdXNlTW92ZUV2ZW50LCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIENvbnN0YW50c18xLkNvbnN0YW50cy50b3VjaFN0YXJ0RXZlbnQsIHRoaXMudG91Y2hTdGFydEhhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIENvbnN0YW50c18xLkNvbnN0YW50cy50b3VjaE1vdmVFdmVudCwgdGhpcy50b3VjaE1vdmVIYW5kbGVyLCBhZGQpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uQ2xpY2suZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlTGlzdGVuZXIoaW50ZXJhY3Rpdml0eUVsLCBDb25zdGFudHNfMS5Db25zdGFudHMudG91Y2hFbmRFdmVudCwgdGhpcy50b3VjaEVuZEhhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIENvbnN0YW50c18xLkNvbnN0YW50cy50b3VjaEVuZEV2ZW50LCB0aGlzLnRvdWNoRW5kQ2xpY2tIYW5kbGVyLCBhZGQpO1xuICAgICAgICAgICAgICAgIG1hbmFnZUxpc3RlbmVyKGludGVyYWN0aXZpdHlFbCwgQ29uc3RhbnRzXzEuQ29uc3RhbnRzLm1vdXNlVXBFdmVudCwgdGhpcy5tb3VzZVVwSGFuZGxlciwgYWRkKTtcbiAgICAgICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIENvbnN0YW50c18xLkNvbnN0YW50cy5tb3VzZURvd25FdmVudCwgdGhpcy5tb3VzZURvd25IYW5kbGVyLCBhZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlTGlzdGVuZXIoaW50ZXJhY3Rpdml0eUVsLCBtb3VzZUxlYXZlRXZlbnQsIHRoaXMubW91c2VMZWF2ZUhhbmRsZXIsIGFkZCk7XG4gICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcihpbnRlcmFjdGl2aXR5RWwsIENvbnN0YW50c18xLkNvbnN0YW50cy50b3VjaENhbmNlbEV2ZW50LCB0aGlzLnRvdWNoQ2FuY2VsSGFuZGxlciwgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLmNhbnZhcy5lbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2FudmFzLmVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IGh0bWwgPT09IGNvbnRhaW5lci5jYW52YXMuZWxlbWVudCA/IFwiaW5pdGlhbFwiIDogXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5ldmVudHMucmVzaXplKSB7XG4gICAgICAgICAgICBtYW5hZ2VMaXN0ZW5lcih3aW5kb3csIENvbnN0YW50c18xLkNvbnN0YW50cy5yZXNpemVFdmVudCwgdGhpcy5yZXNpemVIYW5kbGVyLCBhZGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgbWFuYWdlTGlzdGVuZXIoZG9jdW1lbnQsIENvbnN0YW50c18xLkNvbnN0YW50cy52aXNpYmlsaXR5Q2hhbmdlRXZlbnQsIHRoaXMudmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIsIGFkZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbnRhaW5lci5jYW52YXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aW5kb3dSZXNpemUoKTtcbiAgICB9XG4gICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgdGhpcy5tb3VzZVRvdWNoRmluaXNoKCk7XG4gICAgICAgIGlmICghb3B0aW9ucy5wYXVzZU9uQmx1cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICBjb250YWluZXIucGFnZUhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICBjb250YWluZXIucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wYWdlSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmdldEFuaW1hdGlvblN0YXR1cygpKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnBsYXkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlRG93bigpIHtcbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpdml0eSA9IHRoaXMuY29udGFpbmVyLmludGVyYWN0aXZpdHk7XG4gICAgICAgIGlmIChpbnRlcmFjdGl2aXR5KSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZSA9IGludGVyYWN0aXZpdHkubW91c2U7XG4gICAgICAgICAgICBtb3VzZS5jbGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICBtb3VzZS5kb3duUG9zaXRpb24gPSBtb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZVRvdWNoTW92ZShlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgaWYgKCgoX2EgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZW1lbnQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5pbnNpZGUgPSB0cnVlO1xuICAgICAgICBsZXQgcG9zO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjb250YWluZXIuY2FudmFzLmVsZW1lbnQ7XG4gICAgICAgIGlmIChlLnR5cGUuc3RhcnRzV2l0aChcIm1vdXNlXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbW91c2VFdmVudCA9IGU7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmludGVyYWN0aXZpdHkuZWxlbWVudCA9PT0gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZUV2ZW50LmNsaWVudFggLSBjbGllbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZUV2ZW50LmNsaWVudFkgLSBjbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmludGVyYWN0aXZpdHkuZGV0ZWN0c09uID09PSBFbnVtc18xLkludGVyYWN0aXZpdHlEZXRlY3QucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbW91c2VFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbW91c2VFdmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc0VsID0gY29udGFpbmVyLmNhbnZhcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgJiYgdGFyZ2V0ICYmIGNhbnZhc0VsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXNFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbW91c2VFdmVudC5vZmZzZXRYICsgMiAqIHNvdXJjZVJlY3QubGVmdCAtICh0YXJnZXRSZWN0LmxlZnQgKyBjYW52YXNSZWN0LmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbW91c2VFdmVudC5vZmZzZXRZICsgMiAqIHNvdXJjZVJlY3QudG9wIC0gKHRhcmdldFJlY3QudG9wICsgY2FudmFzUmVjdC50b3ApLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogKF9iID0gbW91c2VFdmVudC5vZmZzZXRYKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBtb3VzZUV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAoX2MgPSBtb3VzZUV2ZW50Lm9mZnNldFkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG1vdXNlRXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW91c2VFdmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jYW52YXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAoX2QgPSBtb3VzZUV2ZW50Lm9mZnNldFgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG1vdXNlRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IChfZSA9IG1vdXNlRXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbW91c2VFdmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGUudHlwZSAhPT0gXCJ0b3VjaG1vdmVcIjtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoRXZlbnQgPSBlO1xuICAgICAgICAgICAgY29uc3QgbGFzdFRvdWNoID0gdG91Y2hFdmVudC50b3VjaGVzW3RvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMgPT09IG51bGwgfHwgY2FudmFzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogbGFzdFRvdWNoLmNsaWVudFggLSAoKF9mID0gY2FudmFzUmVjdCA9PT0gbnVsbCB8fCBjYW52YXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNSZWN0LmxlZnQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDApLFxuICAgICAgICAgICAgICAgIHk6IGxhc3RUb3VjaC5jbGllbnRZIC0gKChfZyA9IGNhbnZhc1JlY3QgPT09IG51bGwgfHwgY2FudmFzUmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FudmFzUmVjdC50b3ApICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBweFJhdGlvID0gY29udGFpbmVyLnJldGluYS5waXhlbFJhdGlvO1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBwb3MueCAqPSBweFJhdGlvO1xuICAgICAgICAgICAgcG9zLnkgKj0gcHhSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5wb3NpdGlvbiA9IHBvcztcbiAgICAgICAgY29udGFpbmVyLmludGVyYWN0aXZpdHkuc3RhdHVzID0gQ29uc3RhbnRzXzEuQ29uc3RhbnRzLm1vdXNlTW92ZUV2ZW50O1xuICAgIH1cbiAgICBtb3VzZVRvdWNoRmluaXNoKCkge1xuICAgICAgICBjb25zdCBpbnRlcmFjdGl2aXR5ID0gdGhpcy5jb250YWluZXIuaW50ZXJhY3Rpdml0eTtcbiAgICAgICAgaWYgKGludGVyYWN0aXZpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdXNlID0gaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgZGVsZXRlIG1vdXNlLnBvc2l0aW9uO1xuICAgICAgICBkZWxldGUgbW91c2UuY2xpY2tQb3NpdGlvbjtcbiAgICAgICAgZGVsZXRlIG1vdXNlLmRvd25Qb3NpdGlvbjtcbiAgICAgICAgaW50ZXJhY3Rpdml0eS5zdGF0dXMgPSBDb25zdGFudHNfMS5Db25zdGFudHMubW91c2VMZWF2ZUV2ZW50O1xuICAgICAgICBtb3VzZS5pbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgbW91c2UuY2xpY2tpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbW91c2VUb3VjaENsaWNrKGUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250YWluZXIuYWN0dWFsT3B0aW9ucztcbiAgICAgICAgY29uc3QgbW91c2UgPSBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZTtcbiAgICAgICAgbW91c2UuaW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbW91c2VQb3NpdGlvbiA9IG1vdXNlLnBvc2l0aW9uO1xuICAgICAgICBpZiAobW91c2VQb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8ICFvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uQ2xpY2suZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIGNvbnRhaW5lci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLmNsaWNrUG9zaXRpb25WYWxpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHBsdWdpbi5jbGlja1Bvc2l0aW9uVmFsaWQobW91c2VQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICAgICAgdGhpcy5kb01vdXNlVG91Y2hDbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZS5jbGlja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICBkb01vdXNlVG91Y2hDbGljayhlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlUG9zID0gY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UucG9zaXRpb247XG4gICAgICAgICAgICBpZiAobW91c2VQb3MpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1Bvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZVBvcy54LFxuICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZVBvcy55LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuaW50ZXJhY3Rpdml0eS5tb3VzZS5jbGlja1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IG9uQ2xpY2sgPSBvcHRpb25zLmludGVyYWN0aXZpdHkuZXZlbnRzLm9uQ2xpY2s7XG4gICAgICAgICAgICBpZiAob25DbGljay5tb2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZGUgb2Ygb25DbGljay5tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2tNb2RlKG1vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2tNb2RlKG9uQ2xpY2subW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0b3VjaGVuZFwiKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubW91c2VUb3VjaEZpbmlzaCgpLCA1MDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsaWNrTW9kZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gY29udGFpbmVyLmFjdHVhbE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHB1c2hOYiA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5wdXNoLnF1YW50aXR5O1xuICAgICAgICBjb25zdCByZW1vdmVOYiA9IG9wdGlvbnMuaW50ZXJhY3Rpdml0eS5tb2Rlcy5yZW1vdmUucXVhbnRpdHk7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLkNsaWNrTW9kZS5wdXNoOiB7XG4gICAgICAgICAgICAgICAgaWYgKHB1c2hOYiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBhcnRpY2xlcy5wdXNoKHB1c2hOYiwgY29udGFpbmVyLmludGVyYWN0aXZpdHkubW91c2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5DbGlja01vZGUucmVtb3ZlOlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXJ0aWNsZXMucmVtb3ZlUXVhbnRpdHkocmVtb3ZlTmIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLkNsaWNrTW9kZS5idWJibGU6XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmJ1YmJsZS5jbGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVudW1zXzEuQ2xpY2tNb2RlLnJlcHVsc2U6XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlcHVsc2UuY2xpY2tpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZXB1bHNlLmNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2xlIG9mIGNvbnRhaW5lci5yZXB1bHNlLnBhcnRpY2xlcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS5zZXRUbyhwYXJ0aWNsZS5pbml0aWFsVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5maW5pc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVwdWxzZS5jbGlja2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcmFjdGl2aXR5Lm1vZGVzLnJlcHVsc2UuZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRW51bXNfMS5DbGlja01vZGUuYXR0cmFjdDpcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXR0cmFjdC5jbGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHJhY3QuY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljbGUgb2YgY29udGFpbmVyLmF0dHJhY3QucGFydGljbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnNldFRvKHBhcnRpY2xlLmluaXRpYWxWZWxvY2l0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyYWN0LnBhcnRpY2xlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyYWN0LmZpbmlzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyYWN0LmNsaWNraW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVyYWN0aXZpdHkubW9kZXMuYXR0cmFjdC5kdXJhdGlvbiAqIDEwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFbnVtc18xLkNsaWNrTW9kZS5wYXVzZTpcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLmdldEFuaW1hdGlvblN0YXR1cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbLCBwbHVnaW5dIG9mIGNvbnRhaW5lci5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAocGx1Z2luLmhhbmRsZUNsaWNrTW9kZSkge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5oYW5kbGVDbGlja01vZGUobW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkV2ZW50TGlzdGVuZXJzID0gRXZlbnRMaXN0ZW5lcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnVtYmVyVXRpbHMgPSB2b2lkIDA7XG5jb25zdCBEaXJlY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vRW51bXMvRGlyZWN0aW9uc1wiKTtcbmNvbnN0IFZlY3Rvcl8xID0gcmVxdWlyZShcIi4uL0NvcmUvUGFydGljbGUvVmVjdG9yXCIpO1xuY2xhc3MgTnVtYmVyVXRpbHMge1xuICAgIHN0YXRpYyBjbGFtcChudW0sIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW0sIG1pbiksIG1heCk7XG4gICAgfVxuICAgIHN0YXRpYyBtaXgoY29tcDEsIGNvbXAyLCB3ZWlnaHQxLCB3ZWlnaHQyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChjb21wMSAqIHdlaWdodDEgKyBjb21wMiAqIHdlaWdodDIpIC8gKHdlaWdodDEgKyB3ZWlnaHQyKSk7XG4gICAgfVxuICAgIHN0YXRpYyByYW5kb21JblJhbmdlKHIpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyVXRpbHMuZ2V0UmFuZ2VNYXgocik7XG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXJVdGlscy5nZXRSYW5nZU1pbihyKTtcbiAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfVxuICAgIHN0YXRpYyBnZXRSYW5nZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IE51bWJlclV0aWxzLnJhbmRvbUluUmFuZ2UodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UmFuZ2VNaW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWUubWluO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UmFuZ2VNYXgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWUubWF4O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0UmFuZ2VWYWx1ZShzb3VyY2UsIHZhbHVlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT09IHZhbHVlIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzb3VyY2UgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlclV0aWxzLmdldFJhbmdlTWluKHNvdXJjZSksIG1heCA9IE51bWJlclV0aWxzLmdldFJhbmdlTWF4KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBtaW46IE1hdGgubWluKG1pbiwgdmFsdWUpLFxuICAgICAgICAgICAgICAgIG1heDogTWF0aC5tYXgobWF4LCB2YWx1ZSksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IE51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUobWluLCBtYXgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VmFsdWUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByYW5kb20gPSBvcHRpb25zLnJhbmRvbTtcbiAgICAgICAgY29uc3QgeyBlbmFibGUsIG1pbmltdW1WYWx1ZSB9ID0gdHlwZW9mIHJhbmRvbSA9PT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZTogcmFuZG9tLCBtaW5pbXVtVmFsdWU6IDAgfSA6IHJhbmRvbTtcbiAgICAgICAgcmV0dXJuIGVuYWJsZVxuICAgICAgICAgICAgPyBOdW1iZXJVdGlscy5nZXRSYW5nZVZhbHVlKE51bWJlclV0aWxzLnNldFJhbmdlVmFsdWUob3B0aW9ucy52YWx1ZSwgbWluaW11bVZhbHVlKSlcbiAgICAgICAgICAgIDogTnVtYmVyVXRpbHMuZ2V0UmFuZ2VWYWx1ZShvcHRpb25zLnZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGdldERpc3RhbmNlcyhwb2ludEEsIHBvaW50Qikge1xuICAgICAgICBjb25zdCBkeCA9IHBvaW50QS54IC0gcG9pbnRCLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9pbnRBLnkgLSBwb2ludEIueTtcbiAgICAgICAgcmV0dXJuIHsgZHg6IGR4LCBkeTogZHksIGRpc3RhbmNlOiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXREaXN0YW5jZShwb2ludEEsIHBvaW50Qikge1xuICAgICAgICByZXR1cm4gTnVtYmVyVXRpbHMuZ2V0RGlzdGFuY2VzKHBvaW50QSwgcG9pbnRCKS5kaXN0YW5jZTtcbiAgICB9XG4gICAgc3RhdGljIGdldFBhcnRpY2xlQmFzZVZlbG9jaXR5KGRpcmVjdGlvbikge1xuICAgICAgICBjb25zdCBiYXNlVmVsb2NpdHkgPSBWZWN0b3JfMS5WZWN0b3Iub3JpZ2luO1xuICAgICAgICBiYXNlVmVsb2NpdHkubGVuZ3RoID0gMTtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uc18xLk1vdmVEaXJlY3Rpb24udG9wOlxuICAgICAgICAgICAgICAgIGJhc2VWZWxvY2l0eS5hbmdsZSA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uc18xLk1vdmVEaXJlY3Rpb24udG9wUmlnaHQ6XG4gICAgICAgICAgICAgICAgYmFzZVZlbG9jaXR5LmFuZ2xlID0gLU1hdGguUEkgLyA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5yaWdodDpcbiAgICAgICAgICAgICAgICBiYXNlVmVsb2NpdHkuYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5ib3R0b21SaWdodDpcbiAgICAgICAgICAgICAgICBiYXNlVmVsb2NpdHkuYW5nbGUgPSBNYXRoLlBJIC8gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uc18xLk1vdmVEaXJlY3Rpb24uYm90dG9tOlxuICAgICAgICAgICAgICAgIGJhc2VWZWxvY2l0eS5hbmdsZSA9IE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5ib3R0b21MZWZ0OlxuICAgICAgICAgICAgICAgIGJhc2VWZWxvY2l0eS5hbmdsZSA9ICgzICogTWF0aC5QSSkgLyA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5sZWZ0OlxuICAgICAgICAgICAgICAgIGJhc2VWZWxvY2l0eS5hbmdsZSA9IE1hdGguUEk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERpcmVjdGlvbnNfMS5Nb3ZlRGlyZWN0aW9uLnRvcExlZnQ6XG4gICAgICAgICAgICAgICAgYmFzZVZlbG9jaXR5LmFuZ2xlID0gKC0zICogTWF0aC5QSSkgLyA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb25zXzEuTW92ZURpcmVjdGlvbi5ub25lOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBiYXNlVmVsb2NpdHkuYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VWZWxvY2l0eTtcbiAgICB9XG4gICAgc3RhdGljIHJvdGF0ZVZlbG9jaXR5KHZlbG9jaXR5LCBhbmdsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogdmVsb2NpdHkuaG9yaXpvbnRhbCAqIE1hdGguY29zKGFuZ2xlKSAtIHZlbG9jaXR5LnZlcnRpY2FsICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgdmVydGljYWw6IHZlbG9jaXR5Lmhvcml6b250YWwgKiBNYXRoLnNpbihhbmdsZSkgKyB2ZWxvY2l0eS52ZXJ0aWNhbCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGNvbGxpc2lvblZlbG9jaXR5KHYxLCB2MiwgbTEsIG0yKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JfMS5WZWN0b3IuY3JlYXRlKCh2MS54ICogKG0xIC0gbTIpKSAvIChtMSArIG0yKSArICh2Mi54ICogMiAqIG0yKSAvIChtMSArIG0yKSwgdjEueSk7XG4gICAgfVxufVxuZXhwb3J0cy5OdW1iZXJVdGlscyA9IE51bWJlclV0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsdWdpbnMgPSB2b2lkIDA7XG5jb25zdCBwbHVnaW5zID0gW107XG5jb25zdCBwcmVzZXRzID0gbmV3IE1hcCgpO1xuY29uc3QgZHJhd2VycyA9IG5ldyBNYXAoKTtcbmNvbnN0IHBhdGhHZW5lcmF0b3JzID0gbmV3IE1hcCgpO1xuY2xhc3MgUGx1Z2lucyB7XG4gICAgc3RhdGljIGdldFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbnMuZmluZCgodCkgPT4gdC5pZCA9PT0gcGx1Z2luKTtcbiAgICB9XG4gICAgc3RhdGljIGFkZFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKCFQbHVnaW5zLmdldFBsdWdpbihwbHVnaW4uaWQpKSB7XG4gICAgICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0QXZhaWxhYmxlUGx1Z2lucyhjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoIXBsdWdpbi5uZWVkc1BsdWdpbihjb250YWluZXIuYWN0dWFsT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5zZXQocGx1Z2luLmlkLCBwbHVnaW4uZ2V0UGx1Z2luKGNvbnRhaW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkT3B0aW9ucyhvcHRpb25zLCBzb3VyY2VPcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgIHBsdWdpbi5sb2FkT3B0aW9ucyhvcHRpb25zLCBzb3VyY2VPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0UHJlc2V0KHByZXNldCkge1xuICAgICAgICByZXR1cm4gcHJlc2V0cy5nZXQocHJlc2V0KTtcbiAgICB9XG4gICAgc3RhdGljIGFkZFByZXNldChwcmVzZXRLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFQbHVnaW5zLmdldFByZXNldChwcmVzZXRLZXkpKSB7XG4gICAgICAgICAgICBwcmVzZXRzLnNldChwcmVzZXRLZXksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhZGRTaGFwZURyYXdlcih0eXBlLCBkcmF3ZXIpIHtcbiAgICAgICAgaWYgKCFQbHVnaW5zLmdldFNoYXBlRHJhd2VyKHR5cGUpKSB7XG4gICAgICAgICAgICBkcmF3ZXJzLnNldCh0eXBlLCBkcmF3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFwZURyYXdlcih0eXBlKSB7XG4gICAgICAgIHJldHVybiBkcmF3ZXJzLmdldCh0eXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFN1cHBvcnRlZFNoYXBlcygpIHtcbiAgICAgICAgcmV0dXJuIGRyYXdlcnMua2V5cygpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGF0aEdlbmVyYXRvcih0eXBlKSB7XG4gICAgICAgIHJldHVybiBwYXRoR2VuZXJhdG9ycy5nZXQodHlwZSk7XG4gICAgfVxuICAgIHN0YXRpYyBhZGRQYXRoR2VuZXJhdG9yKHR5cGUsIHBhdGhHZW5lcmF0b3IpIHtcbiAgICAgICAgaWYgKCFQbHVnaW5zLmdldFBhdGhHZW5lcmF0b3IodHlwZSkpIHtcbiAgICAgICAgICAgIHBhdGhHZW5lcmF0b3JzLnNldCh0eXBlLCBwYXRoR2VuZXJhdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2lucyA9IFBsdWdpbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9pbnQgPSB2b2lkIDA7XG5jbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb24sIHBhcnRpY2xlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZSA9IHBhcnRpY2xlO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWFkVHJlZSA9IHZvaWQgMDtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xuY29uc3QgQ2lyY2xlXzEgPSByZXF1aXJlKFwiLi9DaXJjbGVcIik7XG5jb25zdCBDaXJjbGVXYXJwXzEgPSByZXF1aXJlKFwiLi9DaXJjbGVXYXJwXCIpO1xuY2xhc3MgUXVhZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHJlY3RhbmdsZSwgY2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXZpZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHN1YmRpdmlkZSgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMucmVjdGFuZ2xlLnBvc2l0aW9uLng7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnJlY3RhbmdsZS5wb3NpdGlvbi55O1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5yZWN0YW5nbGUuc2l6ZS53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMucmVjdGFuZ2xlLnNpemUuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjYXBhY2l0eSA9IHRoaXMuY2FwYWNpdHk7XG4gICAgICAgIHRoaXMubm9ydGhFYXN0ID0gbmV3IFF1YWRUcmVlKG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoeCwgeSwgdyAvIDIsIGggLyAyKSwgY2FwYWNpdHkpO1xuICAgICAgICB0aGlzLm5vcnRoV2VzdCA9IG5ldyBRdWFkVHJlZShuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHggKyB3IC8gMiwgeSwgdyAvIDIsIGggLyAyKSwgY2FwYWNpdHkpO1xuICAgICAgICB0aGlzLnNvdXRoRWFzdCA9IG5ldyBRdWFkVHJlZShuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHgsIHkgKyBoIC8gMiwgdyAvIDIsIGggLyAyKSwgY2FwYWNpdHkpO1xuICAgICAgICB0aGlzLnNvdXRoV2VzdCA9IG5ldyBRdWFkVHJlZShuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHggKyB3IC8gMiwgeSArIGggLyAyLCB3IC8gMiwgaCAvIDIpLCBjYXBhY2l0eSk7XG4gICAgICAgIHRoaXMuZGl2aWRlZCA9IHRydWU7XG4gICAgfVxuICAgIGluc2VydChwb2ludCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBpZiAoIXRoaXMucmVjdGFuZ2xlLmNvbnRhaW5zKHBvaW50LnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPCB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kaXZpZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmRpdmlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKF9lID0gKCgoX2EgPSB0aGlzLm5vcnRoRWFzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluc2VydChwb2ludCkpIHx8XG4gICAgICAgICAgICAoKF9iID0gdGhpcy5ub3J0aFdlc3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnNlcnQocG9pbnQpKSB8fFxuICAgICAgICAgICAgKChfYyA9IHRoaXMuc291dGhFYXN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5zZXJ0KHBvaW50KSkgfHxcbiAgICAgICAgICAgICgoX2QgPSB0aGlzLnNvdXRoV2VzdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluc2VydChwb2ludCkpKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2UpO1xuICAgIH1cbiAgICBxdWVyeUNpcmNsZShwb3NpdGlvbiwgcmFkaXVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KG5ldyBDaXJjbGVfMS5DaXJjbGUocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcmFkaXVzKSk7XG4gICAgfVxuICAgIHF1ZXJ5Q2lyY2xlV2FycChwb3NpdGlvbiwgcmFkaXVzLCBjb250YWluZXJPclNpemUpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyT3JTaXplO1xuICAgICAgICBjb25zdCBzaXplID0gY29udGFpbmVyT3JTaXplO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeShuZXcgQ2lyY2xlV2FycF8xLkNpcmNsZVdhcnAocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcmFkaXVzLCBjb250YWluZXIuY2FudmFzICE9PSB1bmRlZmluZWQgPyBjb250YWluZXIuY2FudmFzLnNpemUgOiBzaXplKSk7XG4gICAgfVxuICAgIHF1ZXJ5UmVjdGFuZ2xlKHBvc2l0aW9uLCBzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpKTtcbiAgICB9XG4gICAgcXVlcnkocmFuZ2UsIGZvdW5kKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgcmVzID0gZm91bmQgIT09IG51bGwgJiYgZm91bmQgIT09IHZvaWQgMCA/IGZvdW5kIDogW107XG4gICAgICAgIGlmICghcmFuZ2UuaW50ZXJzZWN0cyh0aGlzLnJlY3RhbmdsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBvaW50cykge1xuICAgICAgICAgICAgICAgIGlmICghcmFuZ2UuY29udGFpbnMocC5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHAucGFydGljbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGl2aWRlZCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubm9ydGhFYXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnkocmFuZ2UsIHJlcyk7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5ub3J0aFdlc3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5xdWVyeShyYW5nZSwgcmVzKTtcbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnNvdXRoRWFzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnF1ZXJ5KHJhbmdlLCByZXMpO1xuICAgICAgICAgICAgICAgIChfZCA9IHRoaXMuc291dGhXZXN0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucXVlcnkocmFuZ2UsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5leHBvcnRzLlF1YWRUcmVlID0gUXVhZFRyZWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmFuZ2UgPSB2b2lkIDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlY3RhbmdsZSA9IHZvaWQgMDtcbmNvbnN0IFJhbmdlXzEgPSByZXF1aXJlKFwiLi9SYW5nZVwiKTtcbmNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIFJhbmdlXzEuUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoeCwgeSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb250YWlucyhwb2ludCkge1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5zaXplLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5zaXplLmhlaWdodDtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gcG9zLnggJiYgcG9pbnQueCA8PSBwb3MueCArIHcgJiYgcG9pbnQueSA+PSBwb3MueSAmJiBwb2ludC55IDw9IHBvcy55ICsgaDtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhyYW5nZSkge1xuICAgICAgICBjb25zdCByZWN0ID0gcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNpcmNsZSA9IHJhbmdlO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5zaXplLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5zaXplLmhlaWdodDtcbiAgICAgICAgY29uc3QgcG9zMSA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHBvczIgPSByYW5nZS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKGNpcmNsZS5yYWRpdXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNpcmNsZS5pbnRlcnNlY3RzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlY3Quc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplMiA9IHJlY3Quc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHcyID0gc2l6ZTIud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoMiA9IHNpemUyLmhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBwb3MyLnggPCBwb3MxLnggKyB3ICYmIHBvczIueCArIHcyID4gcG9zMS54ICYmIHBvczIueSA8IHBvczEueSArIGggJiYgcG9zMi55ICsgaDIgPiBwb3MxLnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXRpbHMgPSB2b2lkIDA7XG5jb25zdCBPdXRNb2RlRGlyZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vRW51bXMvRGlyZWN0aW9ucy9PdXRNb2RlRGlyZWN0aW9uXCIpO1xuY29uc3QgTnVtYmVyVXRpbHNfMSA9IHJlcXVpcmUoXCIuL051bWJlclV0aWxzXCIpO1xuZnVuY3Rpb24gcmVjdFNpZGVCb3VuY2UocFNpZGUsIHBPdGhlclNpZGUsIHJlY3RTaWRlLCByZWN0T3RoZXJTaWRlLCB2ZWxvY2l0eSwgZmFjdG9yKSB7XG4gICAgY29uc3QgcmVzID0geyBib3VuY2VkOiBmYWxzZSB9O1xuICAgIGlmIChwT3RoZXJTaWRlLm1pbiA+PSByZWN0T3RoZXJTaWRlLm1pbiAmJlxuICAgICAgICBwT3RoZXJTaWRlLm1pbiA8PSByZWN0T3RoZXJTaWRlLm1heCAmJlxuICAgICAgICBwT3RoZXJTaWRlLm1heCA+PSByZWN0T3RoZXJTaWRlLm1pbiAmJlxuICAgICAgICBwT3RoZXJTaWRlLm1heCA8PSByZWN0T3RoZXJTaWRlLm1heCkge1xuICAgICAgICBpZiAoKHBTaWRlLm1heCA+PSByZWN0U2lkZS5taW4gJiYgcFNpZGUubWF4IDw9IChyZWN0U2lkZS5tYXggKyByZWN0U2lkZS5taW4pIC8gMiAmJiB2ZWxvY2l0eSA+IDApIHx8XG4gICAgICAgICAgICAocFNpZGUubWluIDw9IHJlY3RTaWRlLm1heCAmJiBwU2lkZS5taW4gPiAocmVjdFNpZGUubWF4ICsgcmVjdFNpZGUubWluKSAvIDIgJiYgdmVsb2NpdHkgPCAwKSkge1xuICAgICAgICAgICAgcmVzLnZlbG9jaXR5ID0gdmVsb2NpdHkgKiAtZmFjdG9yO1xuICAgICAgICAgICAgcmVzLmJvdW5jZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIGlmIChzZWxlY3RvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9ycyk7XG4gICAgfVxufVxuY2xhc3MgVXRpbHMge1xuICAgIHN0YXRpYyBpc1NzcigpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIXdpbmRvdztcbiAgICB9XG4gICAgc3RhdGljIGdldCBhbmltYXRlKCkge1xuICAgICAgICByZXR1cm4gVXRpbHMuaXNTc3IoKVxuICAgICAgICAgICAgPyAoY2FsbGJhY2spID0+IHNldFRpbWVvdXQoY2FsbGJhY2spXG4gICAgICAgICAgICA6IChjYWxsYmFjaykgPT4gKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQpKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5pc1NzcigpXG4gICAgICAgICAgICA/IChoYW5kbGUpID0+IGNsZWFyVGltZW91dChoYW5kbGUpXG4gICAgICAgICAgICA6IChoYW5kbGUpID0+ICh3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1zQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCkoaGFuZGxlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5BcnJheSh2YWx1ZSwgYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBhcnJheSB8fCAoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSAmJiBhcnJheS5pbmRleE9mKHZhbHVlKSA+IC0xKTtcbiAgICB9XG4gICAgc3RhdGljIGxvYWRGb250KGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBkb2N1bWVudC5mb250cy5sb2FkKGAke2NoYXJhY3Rlci53ZWlnaHR9IDM2cHggJyR7Y2hhcmFjdGVyLmZvbnR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgYXJyYXlSYW5kb21JbmRleChhcnJheSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIGl0ZW1Gcm9tQXJyYXkoYXJyYXksIGluZGV4LCB1c2VJbmRleCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZml4ZWRJbmRleCA9IGluZGV4ICE9PSB1bmRlZmluZWQgJiYgdXNlSW5kZXggPyBpbmRleCAlIGFycmF5Lmxlbmd0aCA6IFV0aWxzLmFycmF5UmFuZG9tSW5kZXgoYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXJyYXlbZml4ZWRJbmRleF07XG4gICAgfVxuICAgIHN0YXRpYyBpc1BvaW50SW5zaWRlKHBvaW50LCBzaXplLCByYWRpdXMsIGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gVXRpbHMuYXJlQm91bmRzSW5zaWRlKFV0aWxzLmNhbGN1bGF0ZUJvdW5kcyhwb2ludCwgcmFkaXVzICE9PSBudWxsICYmIHJhZGl1cyAhPT0gdm9pZCAwID8gcmFkaXVzIDogMCksIHNpemUsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBhcmVCb3VuZHNJbnNpZGUoYm91bmRzLCBzaXplLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgbGV0IGluc2lkZSA9IHRydWU7XG4gICAgICAgIGlmICghZGlyZWN0aW9uIHx8IGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24uYm90dG9tKSB7XG4gICAgICAgICAgICBpbnNpZGUgPSBib3VuZHMudG9wIDwgc2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2lkZSAmJiAoIWRpcmVjdGlvbiB8fCBkaXJlY3Rpb24gPT09IE91dE1vZGVEaXJlY3Rpb25fMS5PdXRNb2RlRGlyZWN0aW9uLmxlZnQpKSB7XG4gICAgICAgICAgICBpbnNpZGUgPSBib3VuZHMucmlnaHQgPiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNpZGUgJiYgKCFkaXJlY3Rpb24gfHwgZGlyZWN0aW9uID09PSBPdXRNb2RlRGlyZWN0aW9uXzEuT3V0TW9kZURpcmVjdGlvbi5yaWdodCkpIHtcbiAgICAgICAgICAgIGluc2lkZSA9IGJvdW5kcy5sZWZ0IDwgc2l6ZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zaWRlICYmICghZGlyZWN0aW9uIHx8IGRpcmVjdGlvbiA9PT0gT3V0TW9kZURpcmVjdGlvbl8xLk91dE1vZGVEaXJlY3Rpb24udG9wKSkge1xuICAgICAgICAgICAgaW5zaWRlID0gYm91bmRzLmJvdHRvbSA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9XG4gICAgc3RhdGljIGNhbGN1bGF0ZUJvdW5kcyhwb2ludCwgcmFkaXVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3R0b206IHBvaW50LnkgKyByYWRpdXMsXG4gICAgICAgICAgICBsZWZ0OiBwb2ludC54IC0gcmFkaXVzLFxuICAgICAgICAgICAgcmlnaHQ6IHBvaW50LnggKyByYWRpdXMsXG4gICAgICAgICAgICB0b3A6IHBvaW50LnkgLSByYWRpdXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkSW1hZ2Uoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIkVycm9yIHRzUGFydGljbGVzIC0gTm8gaW1hZ2Uuc3JjXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0ge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNvdXJjZS5zdWJzdHIoc291cmNlLmxlbmd0aCAtIDMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpbWFnZS5lbGVtZW50ID0gaW1nO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoYEVycm9yIHRzUGFydGljbGVzIC0gbG9hZGluZyBpbWFnZTogJHtzb3VyY2V9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBzb3VyY2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZG93bmxvYWRTdmdJbWFnZShzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHNQYXJ0aWNsZXMgLSBObyBpbWFnZS5zcmNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBzb3VyY2Uuc3Vic3RyKHNvdXJjZS5sZW5ndGggLSAzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW1hZ2UudHlwZSAhPT0gXCJzdmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5sb2FkSW1hZ2Uoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaW1hZ2Uuc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0c1BhcnRpY2xlcyAtIEltYWdlIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlLnN2Z0RhdGEgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZGVlcEV4dGVuZChkZXN0aW5hdGlvbiwgLi4uc291cmNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQgfHwgc291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VJc0FycmF5ICYmICh0eXBlb2YgZGVzdGluYXRpb24gIT09IFwib2JqZWN0XCIgfHwgIWRlc3RpbmF0aW9uIHx8ICFBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNvdXJjZUlzQXJyYXkgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGRlc3RpbmF0aW9uICE9PSBcIm9iamVjdFwiIHx8ICFkZXN0aW5hdGlvbiB8fCBBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlRGljdCA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZURpY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc09iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0RGljdCA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgIGRlc3REaWN0W2tleV0gPVxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS5tYXAoKHYpID0+IFV0aWxzLmRlZXBFeHRlbmQoZGVzdERpY3Rba2V5XSwgdikpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFV0aWxzLmRlZXBFeHRlbmQoZGVzdERpY3Rba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgc3RhdGljIGlzRGl2TW9kZUVuYWJsZWQobW9kZSwgZGl2cykge1xuICAgICAgICByZXR1cm4gZGl2cyBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICA/ICEhZGl2cy5maW5kKCh0KSA9PiB0LmVuYWJsZSAmJiBVdGlscy5pc0luQXJyYXkobW9kZSwgdC5tb2RlKSlcbiAgICAgICAgICAgIDogVXRpbHMuaXNJbkFycmF5KG1vZGUsIGRpdnMubW9kZSk7XG4gICAgfVxuICAgIHN0YXRpYyBkaXZNb2RlRXhlY3V0ZShtb2RlLCBkaXZzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoZGl2cyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRpdiBvZiBkaXZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGl2TW9kZSA9IGRpdi5tb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpdkVuYWJsZWQgPSBkaXYuZW5hYmxlO1xuICAgICAgICAgICAgICAgIGlmIChkaXZFbmFibGVkICYmIFV0aWxzLmlzSW5BcnJheShtb2RlLCBkaXZNb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5zaW5nbGVEaXZNb2RlRXhlY3V0ZShkaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkaXZNb2RlID0gZGl2cy5tb2RlO1xuICAgICAgICAgICAgY29uc3QgZGl2RW5hYmxlZCA9IGRpdnMuZW5hYmxlO1xuICAgICAgICAgICAgaWYgKGRpdkVuYWJsZWQgJiYgVXRpbHMuaXNJbkFycmF5KG1vZGUsIGRpdk1vZGUpKSB7XG4gICAgICAgICAgICAgICAgVXRpbHMuc2luZ2xlRGl2TW9kZUV4ZWN1dGUoZGl2cywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBzaW5nbGVEaXZNb2RlRXhlY3V0ZShkaXYsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IGRpdi5zZWxlY3RvcnM7XG4gICAgICAgIGlmIChzZWxlY3RvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxlY3RvciwgZGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGVjdG9ycywgZGl2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGl2TW9kZShkaXZzLCBlbGVtZW50KSB7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZGl2cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXZzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXZzLmZpbmQoKGQpID0+IGNoZWNrU2VsZWN0b3IoZWxlbWVudCwgZC5zZWxlY3RvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGVja1NlbGVjdG9yKGVsZW1lbnQsIGRpdnMuc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpdnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNpcmNsZUJvdW5jZURhdGFGcm9tUGFydGljbGUocCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246IHAuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIHJhZGl1czogcC5nZXRSYWRpdXMoKSxcbiAgICAgICAgICAgIG1hc3M6IHAuZ2V0TWFzcygpLFxuICAgICAgICAgICAgdmVsb2NpdHk6IHAudmVsb2NpdHksXG4gICAgICAgICAgICBmYWN0b3I6IHtcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKHAub3B0aW9ucy5ib3VuY2UuaG9yaXpvbnRhbCksXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUocC5vcHRpb25zLmJvdW5jZS52ZXJ0aWNhbCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY2lyY2xlQm91bmNlKHAxLCBwMikge1xuICAgICAgICBjb25zdCB4VmVsb2NpdHlEaWZmID0gcDEudmVsb2NpdHkueDtcbiAgICAgICAgY29uc3QgeVZlbG9jaXR5RGlmZiA9IHAxLnZlbG9jaXR5Lnk7XG4gICAgICAgIGNvbnN0IHBvczEgPSBwMS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgcG9zMiA9IHAyLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB4RGlzdCA9IHBvczIueCAtIHBvczEueDtcbiAgICAgICAgY29uc3QgeURpc3QgPSBwb3MyLnkgLSBwb3MxLnk7XG4gICAgICAgIGlmICh4VmVsb2NpdHlEaWZmICogeERpc3QgKyB5VmVsb2NpdHlEaWZmICogeURpc3QgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSAtTWF0aC5hdGFuMihwb3MyLnkgLSBwb3MxLnksIHBvczIueCAtIHBvczEueCk7XG4gICAgICAgICAgICBjb25zdCBtMSA9IHAxLm1hc3M7XG4gICAgICAgICAgICBjb25zdCBtMiA9IHAyLm1hc3M7XG4gICAgICAgICAgICBjb25zdCB1MSA9IHAxLnZlbG9jaXR5LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB1MiA9IHAyLnZlbG9jaXR5LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB2MSA9IE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuY29sbGlzaW9uVmVsb2NpdHkodTEsIHUyLCBtMSwgbTIpO1xuICAgICAgICAgICAgY29uc3QgdjIgPSBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLmNvbGxpc2lvblZlbG9jaXR5KHUyLCB1MSwgbTEsIG0yKTtcbiAgICAgICAgICAgIGNvbnN0IHZGaW5hbDEgPSB2MS5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHZGaW5hbDIgPSB2Mi5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgICAgIHAxLnZlbG9jaXR5LnggPSB2RmluYWwxLnggKiBwMS5mYWN0b3IuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHAxLnZlbG9jaXR5LnkgPSB2RmluYWwxLnkgKiBwMS5mYWN0b3IudmVydGljYWw7XG4gICAgICAgICAgICBwMi52ZWxvY2l0eS54ID0gdkZpbmFsMi54ICogcDIuZmFjdG9yLmhvcml6b250YWw7XG4gICAgICAgICAgICBwMi52ZWxvY2l0eS55ID0gdkZpbmFsMi55ICogcDIuZmFjdG9yLnZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyByZWN0Qm91bmNlKHBhcnRpY2xlLCBkaXZCb3VuZHMpIHtcbiAgICAgICAgY29uc3QgcFBvcyA9IHBhcnRpY2xlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJ0aWNsZS5nZXRSYWRpdXMoKTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gVXRpbHMuY2FsY3VsYXRlQm91bmRzKHBQb3MsIHNpemUpO1xuICAgICAgICBjb25zdCByZXNIID0gcmVjdFNpZGVCb3VuY2Uoe1xuICAgICAgICAgICAgbWluOiBib3VuZHMubGVmdCxcbiAgICAgICAgICAgIG1heDogYm91bmRzLnJpZ2h0LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW46IGJvdW5kcy50b3AsXG4gICAgICAgICAgICBtYXg6IGJvdW5kcy5ib3R0b20sXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbjogZGl2Qm91bmRzLmxlZnQsXG4gICAgICAgICAgICBtYXg6IGRpdkJvdW5kcy5yaWdodCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluOiBkaXZCb3VuZHMudG9wLFxuICAgICAgICAgICAgbWF4OiBkaXZCb3VuZHMuYm90dG9tLFxuICAgICAgICB9LCBwYXJ0aWNsZS52ZWxvY2l0eS54LCBOdW1iZXJVdGlsc18xLk51bWJlclV0aWxzLmdldFZhbHVlKHBhcnRpY2xlLm9wdGlvbnMuYm91bmNlLmhvcml6b250YWwpKTtcbiAgICAgICAgaWYgKHJlc0guYm91bmNlZCkge1xuICAgICAgICAgICAgaWYgKHJlc0gudmVsb2NpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnggPSByZXNILnZlbG9jaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc0gucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnggPSByZXNILnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc1YgPSByZWN0U2lkZUJvdW5jZSh7XG4gICAgICAgICAgICBtaW46IGJvdW5kcy50b3AsXG4gICAgICAgICAgICBtYXg6IGJvdW5kcy5ib3R0b20sXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbjogYm91bmRzLmxlZnQsXG4gICAgICAgICAgICBtYXg6IGJvdW5kcy5yaWdodCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluOiBkaXZCb3VuZHMudG9wLFxuICAgICAgICAgICAgbWF4OiBkaXZCb3VuZHMuYm90dG9tLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW46IGRpdkJvdW5kcy5sZWZ0LFxuICAgICAgICAgICAgbWF4OiBkaXZCb3VuZHMucmlnaHQsXG4gICAgICAgIH0sIHBhcnRpY2xlLnZlbG9jaXR5LnksIE51bWJlclV0aWxzXzEuTnVtYmVyVXRpbHMuZ2V0VmFsdWUocGFydGljbGUub3B0aW9ucy5ib3VuY2UudmVydGljYWwpKTtcbiAgICAgICAgaWYgKHJlc1YuYm91bmNlZCkge1xuICAgICAgICAgICAgaWYgKHJlc1YudmVsb2NpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5LnkgPSByZXNWLnZlbG9jaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc1YucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnBvc2l0aW9uLnkgPSByZXNWLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5VdGlscyA9IFV0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9DYW52YXNVdGlsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2lyY2xlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9DaXJjbGVXYXJwXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db2xvclV0aWxzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db25zdGFudHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0V2ZW50TGlzdGVuZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9OdW1iZXJVdGlsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGx1Z2luc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUG9pbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1F1YWRUcmVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9SYW5nZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9VdGlsc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50c1BhcnRpY2xlcyA9IGV4cG9ydHMucEpTRG9tID0gZXhwb3J0cy5wYXJ0aWNsZXNKUyA9IGV4cG9ydHMuTWFpbiA9IGV4cG9ydHMuVXRpbHMgPSBleHBvcnRzLkNvbnN0YW50cyA9IGV4cG9ydHMuQ29sb3JVdGlscyA9IGV4cG9ydHMuQ2FudmFzVXRpbHMgPSB2b2lkIDA7XG5jb25zdCBwanNfMSA9IHJlcXVpcmUoXCIuL3Bqc1wiKTtcbmNvbnN0IG1haW5fMSA9IHJlcXVpcmUoXCIuL21haW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYWluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWluXzEuTWFpbjsgfSB9KTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbnZhc1V0aWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBVdGlsc18xLkNhbnZhc1V0aWxzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29sb3JVdGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVXRpbHNfMS5Db2xvclV0aWxzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uc3RhbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBVdGlsc18xLkNvbnN0YW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0aWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBVdGlsc18xLlV0aWxzOyB9IH0pO1xuY29uc3QgdHNQYXJ0aWNsZXMgPSBuZXcgbWFpbl8xLk1haW4oKTtcbmV4cG9ydHMudHNQYXJ0aWNsZXMgPSB0c1BhcnRpY2xlcztcbnRzUGFydGljbGVzLmluaXQoKTtcbmNvbnN0IHsgcGFydGljbGVzSlMsIHBKU0RvbSB9ID0gcGpzXzEuaW5pdFBqcyh0c1BhcnRpY2xlcyk7XG5leHBvcnRzLnBhcnRpY2xlc0pTID0gcGFydGljbGVzSlM7XG5leHBvcnRzLnBKU0RvbSA9IHBKU0RvbTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db3JlL1BhcnRpY2xlL1ZlY3RvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29yZS9Db250YWluZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0VudW1zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QbHVnaW5zL0Fic29yYmVycy9FbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGx1Z2lucy9FbWl0dGVycy9FbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGx1Z2lucy9Qb2x5Z29uTWFzay9FbnVtc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1haW4gPSB2b2lkIDA7XG5jb25zdCBtYWluX3NsaW1fMSA9IHJlcXVpcmUoXCIuL21haW4uc2xpbVwiKTtcbmNvbnN0IEFic29yYmVyc1BsdWdpbl8xID0gcmVxdWlyZShcIi4vUGx1Z2lucy9BYnNvcmJlcnMvQWJzb3JiZXJzUGx1Z2luXCIpO1xuY29uc3QgRW1pdHRlcnNQbHVnaW5fMSA9IHJlcXVpcmUoXCIuL1BsdWdpbnMvRW1pdHRlcnMvRW1pdHRlcnNQbHVnaW5cIik7XG5jb25zdCBQb2x5Z29uTWFza1BsdWdpbl8xID0gcmVxdWlyZShcIi4vUGx1Z2lucy9Qb2x5Z29uTWFzay9Qb2x5Z29uTWFza1BsdWdpblwiKTtcbmNsYXNzIE1haW4gZXh0ZW5kcyBtYWluX3NsaW1fMS5NYWluU2xpbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWRkUGx1Z2luKEFic29yYmVyc1BsdWdpbl8xLkFic29yYmVyc1BsdWdpbik7XG4gICAgICAgIHRoaXMuYWRkUGx1Z2luKEVtaXR0ZXJzUGx1Z2luXzEuRW1pdHRlcnNQbHVnaW4pO1xuICAgICAgICB0aGlzLmFkZFBsdWdpbihQb2x5Z29uTWFza1BsdWdpbl8xLlBvbHlnb25NYXNrUGx1Z2luKTtcbiAgICB9XG59XG5leHBvcnRzLk1haW4gPSBNYWluO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX2luaXRpYWxpemVkO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWluU2xpbSA9IHZvaWQgMDtcbmNvbnN0IFNxdWFyZURyYXdlcl8xID0gcmVxdWlyZShcIi4vU2hhcGVEcmF3ZXJzL1NxdWFyZURyYXdlclwiKTtcbmNvbnN0IFRleHREcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9UZXh0RHJhd2VyXCIpO1xuY29uc3QgSW1hZ2VEcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9JbWFnZURyYXdlclwiKTtcbmNvbnN0IFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbmNvbnN0IFR5cGVzXzEgPSByZXF1aXJlKFwiLi9FbnVtcy9UeXBlc1wiKTtcbmNvbnN0IExpbmVEcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9MaW5lRHJhd2VyXCIpO1xuY29uc3QgQ2lyY2xlRHJhd2VyXzEgPSByZXF1aXJlKFwiLi9TaGFwZURyYXdlcnMvQ2lyY2xlRHJhd2VyXCIpO1xuY29uc3QgVHJpYW5nbGVEcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9UcmlhbmdsZURyYXdlclwiKTtcbmNvbnN0IFN0YXJEcmF3ZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXBlRHJhd2Vycy9TdGFyRHJhd2VyXCIpO1xuY29uc3QgUG9seWdvbkRyYXdlcl8xID0gcmVxdWlyZShcIi4vU2hhcGVEcmF3ZXJzL1BvbHlnb25EcmF3ZXJcIik7XG5jb25zdCBMb2FkZXJfMSA9IHJlcXVpcmUoXCIuL0NvcmUvTG9hZGVyXCIpO1xuY2xhc3MgTWFpblNsaW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfaW5pdGlhbGl6ZWQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX2luaXRpYWxpemVkLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHNxdWFyZURyYXdlciA9IG5ldyBTcXVhcmVEcmF3ZXJfMS5TcXVhcmVEcmF3ZXIoKTtcbiAgICAgICAgY29uc3QgdGV4dERyYXdlciA9IG5ldyBUZXh0RHJhd2VyXzEuVGV4dERyYXdlcigpO1xuICAgICAgICBjb25zdCBpbWFnZURyYXdlciA9IG5ldyBJbWFnZURyYXdlcl8xLkltYWdlRHJhd2VyKCk7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRTaGFwZURyYXdlcihUeXBlc18xLlNoYXBlVHlwZS5saW5lLCBuZXcgTGluZURyYXdlcl8xLkxpbmVEcmF3ZXIoKSk7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRTaGFwZURyYXdlcihUeXBlc18xLlNoYXBlVHlwZS5jaXJjbGUsIG5ldyBDaXJjbGVEcmF3ZXJfMS5DaXJjbGVEcmF3ZXIoKSk7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRTaGFwZURyYXdlcihUeXBlc18xLlNoYXBlVHlwZS5lZGdlLCBzcXVhcmVEcmF3ZXIpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuc3F1YXJlLCBzcXVhcmVEcmF3ZXIpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUudHJpYW5nbGUsIG5ldyBUcmlhbmdsZURyYXdlcl8xLlRyaWFuZ2xlRHJhd2VyKCkpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuc3RhciwgbmV3IFN0YXJEcmF3ZXJfMS5TdGFyRHJhd2VyKCkpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUucG9seWdvbiwgbmV3IFBvbHlnb25EcmF3ZXJfMS5Qb2x5Z29uRHJhd2VyKCkpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuY2hhciwgdGV4dERyYXdlcik7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRTaGFwZURyYXdlcihUeXBlc18xLlNoYXBlVHlwZS5jaGFyYWN0ZXIsIHRleHREcmF3ZXIpO1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkU2hhcGVEcmF3ZXIoVHlwZXNfMS5TaGFwZVR5cGUuaW1hZ2UsIGltYWdlRHJhd2VyKTtcbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKFR5cGVzXzEuU2hhcGVUeXBlLmltYWdlcywgaW1hZ2VEcmF3ZXIpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2luaXRpYWxpemVkKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfaW5pdGlhbGl6ZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWRGcm9tQXJyYXkodGFnSWQsIG9wdGlvbnMsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyXzEuTG9hZGVyLmxvYWQodGFnSWQsIG9wdGlvbnMsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWQodGFnSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2FkZXJfMS5Mb2FkZXIubG9hZCh0YWdJZCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQoaWQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2FkZXJfMS5Mb2FkZXIuc2V0KGlkLCBlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRKU09OKHRhZ0lkLCBwYXRoQ29uZmlnSnNvbiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIExvYWRlcl8xLkxvYWRlci5sb2FkSlNPTih0YWdJZCwgcGF0aENvbmZpZ0pzb24sIGluZGV4KTtcbiAgICB9XG4gICAgc2V0T25DbGlja0hhbmRsZXIoY2FsbGJhY2spIHtcbiAgICAgICAgTG9hZGVyXzEuTG9hZGVyLnNldE9uQ2xpY2tIYW5kbGVyKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZG9tKCkge1xuICAgICAgICByZXR1cm4gTG9hZGVyXzEuTG9hZGVyLmRvbSgpO1xuICAgIH1cbiAgICBkb21JdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBMb2FkZXJfMS5Mb2FkZXIuZG9tSXRlbShpbmRleCk7XG4gICAgfVxuICAgIGFkZFNoYXBlKHNoYXBlLCBkcmF3ZXIsIGluaXQsIGFmdGVyRWZmZWN0LCBkZXN0cm95KSB7XG4gICAgICAgIGxldCBjdXN0b21EcmF3ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhd2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGN1c3RvbURyYXdlciA9IHtcbiAgICAgICAgICAgICAgICBhZnRlckVmZmVjdDogYWZ0ZXJFZmZlY3QsXG4gICAgICAgICAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgICAgICAgICBkcmF3OiBkcmF3ZXIsXG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXN0b21EcmF3ZXIgPSBkcmF3ZXI7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHNfMS5QbHVnaW5zLmFkZFNoYXBlRHJhd2VyKHNoYXBlLCBjdXN0b21EcmF3ZXIpO1xuICAgIH1cbiAgICBhZGRQcmVzZXQocHJlc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRQcmVzZXQocHJlc2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYWRkUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBVdGlsc18xLlBsdWdpbnMuYWRkUGx1Z2luKHBsdWdpbik7XG4gICAgfVxuICAgIGFkZFBhdGhHZW5lcmF0b3IobmFtZSwgZ2VuZXJhdG9yKSB7XG4gICAgICAgIFV0aWxzXzEuUGx1Z2lucy5hZGRQYXRoR2VuZXJhdG9yKG5hbWUsIGdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5NYWluU2xpbSA9IE1haW5TbGltO1xuX2luaXRpYWxpemVkID0gbmV3IFdlYWtNYXAoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0UGpzID0gdm9pZCAwO1xuY29uc3QgaW5pdFBqcyA9IChtYWluKSA9PiB7XG4gICAgY29uc3QgcGFydGljbGVzSlMgPSAodGFnSWQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIG1haW4ubG9hZCh0YWdJZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBwYXJ0aWNsZXNKUy5sb2FkID0gKHRhZ0lkLCBwYXRoQ29uZmlnSnNvbiwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgbWFpbi5sb2FkSlNPTih0YWdJZCwgcGF0aENvbmZpZ0pzb24pLnRoZW4oKGNvbnRhaW5lcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcGFydGljbGVzSlMuc2V0T25DbGlja0hhbmRsZXIgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgbWFpbi5zZXRPbkNsaWNrSGFuZGxlcihjYWxsYmFjayk7XG4gICAgfTtcbiAgICBjb25zdCBwSlNEb20gPSBtYWluLmRvbSgpO1xuICAgIHJldHVybiB7IHBhcnRpY2xlc0pTLCBwSlNEb20gfTtcbn07XG5leHBvcnRzLmluaXRQanMgPSBpbml0UGpzO1xuIiwiaW1wb3J0IEhlYWQgZnJvbSBcIm5leHQvaGVhZFwiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XG5pbXBvcnQgUGFydGljbGVzIGZyb20gJ3JlYWN0LXBhcnRpY2xlcy1qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZC1mbGV4IGZsZXgtY29sdW1uXCI+XG4gICAgICAgIDxQYXJ0aWNsZXMgd2lkdGg9eycxMDB2dyd9IGhlaWdodD17Jzk2dmgnfVxuICAgICAgICAgIHBhcmFtcz17e1xuICAgICAgICAgICAgcG9seWdvbjoge1xuICAgICAgICAgICAgICBzY2FsZTogMixcbiAgICAgICAgICAgICAgbW92ZToge1xuICAgICAgICAgICAgICAgIHJhZGl1czogM1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkcmF3OiB7IHN0cm9rZTogeyBjb2xvcjogJ3JnYig1MSwgMTY4LCAxNDMpJyB9IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fSAvPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiY29udGFpbmVyIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXIganVzdGlmeS1jb250ZW50LWNlbnRlciBhbGlnbi1zZWxmLWNlbnRlclwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiOTB2aFwiXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImQtZmxleCBmbGV4LWNvbHVtbiBhbGlnbi1pdGVtcy1jZW50ZXIganVzdGlmeS1jb250ZW50LWFyb3VuZFwiXG4gICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IFwiNDB2aFwiIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICBzcmM9XCIvYXNzZXRzL2ltYWdlcy9TcGFjZVhMb2dvRnVsbC5wbmdcIlxuICAgICAgICAgICAgICBhbHQ9XCJTcGFjZVggTG9nb1wiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImltZy1mbHVpZCBkLWJsb2NrXCJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKFwiaHR0cHM6Ly93d3cuc3BhY2V4LmNvbS9cIiwgXCJfIGJsYW5rXCIpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogNzAwLCBjdXJzb3I6IFwicG9pbnRlclwiIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkLWZsZXggdy01MCBqdXN0aWZ5LWNvbnRlbnQtYXJvdW5kIGZsZXgtd3JhcFwiPlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgbWItNFwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gcm91dGVyLnB1c2goXCJsYXVuY2hfZ2VuZXJhdG9yXCIpfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgTGF1bmNoIEdlbmVyYXRvclxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IG1iLTRcIj5cbiAgICAgICAgICAgICAgICBMYXVuY2ggU2VhcmNoXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGZvb3RlciBjbGFzc05hbWU9J3RleHQtY2VudGVyJyBzdHlsZT17eyBwb3NpdGlvbjogJ2Fic29sdXRlJywgYm90dG9tOiA0MCwgd2lkdGg6ICcxMDAlJyB9fT5cbiAgICAgICAgICBEZXZlbG9wZWQgYnkgPGEgaHJlZj1cImh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vYW5keXR1YmVlZVwiPkFuZHJldyBZYW5nPC9hPiAmY29weTsge25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX1cbiAgICAgICAgPC9mb290ZXI+XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=